<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Beej의 네트워크 프로그래밍 안내서</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono&display=swap" rel="stylesheet"> 
  <link rel="stylesheet" as="style" crossorigin="None" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.6/dist/web/static/pretendard.css" />
  <!-- BG custom styling -->
  <style type="text/css">
  /* Fix for line numbers not visible */
  pre.numberSource code > span {
      left: -1em;
  }
  pre.numberSource {
      margin-left: initial;
  }
  
  /* Put some space after the section numbers */
  span.toc-section-number::after {
      content: "\a0\a0\a0";  /* non-breaking whitespace */
  }
  
  /* Hide underlines on code number links */
  pre > code.sourceCode > span > a:first-child::before {
      text-decoration: none;
  }
  
  /* Color the source blocks */
  div.sourceCode {
      background-color: #f0f0f0;
  }
  
  /* Fix iOS big text rendering issue */
  pre > code.sourceCode > span {
      display: initial;
  }
  
  
  /* Color the inline code */
  code:not(.sourceCode) {
      background: #f0f0f0;
      padding-left: 0.2em;
      padding-right: 0.2em;
      border-radius: 0.2em;
  }
  
  /* Keep code tags from wrapping in tables */
  tbody code {
      white-space: nowrap;
  }
  
  td {
      vertical-align: top;
  }
  
  body {
      font-size: 12pt;
      box-sizing: border-box;
      margin: 0;
      padding: 1em;
      max-width: min(43em, 100vw);
  }
  
  html {
      display: flex;
      justify-content: center;
      font-family: -apple-system, BlinkMacSystemFont, "Apple SD Gothic Neo", "Pretendard Variable", Pretendard, Roboto, "Noto Sans KR", "Segoe UI", "Malgun Gothic", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
  }
  
  figure {
      text-align: center;
  }
  </style>
</head>
<body>
<div style="text-align:center"><span><a href="약간-더-고급스러운-기술.html">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="man-pages.html">Next</a></span></div><hr>
<h1 id="일반적인-질문들"><span class="header-section-number">8</span> 일반적인 질문들</h1><p><strong>이 헤더파일들은 어디서 찾을 수 있을까요?</strong></p><p> 여러분의 시스템에 헤더파일이 없다면 아마도 그것이 필요하지 않을 것입니다. 사용중인 플랫폼의 설명서를 참고하세요.  Windows를 위해 작업하고 있다면 <code>#include &lt;winsock.h&gt;</code>만 하면 됩니다.</p><p><strong><code>bind()</code>가  “Address already in use” 를 보고하면 어떻게 해야하나요?</strong></p><p>리스닝 소켓에  <code>setsockopt()</code>를  <code>SO_REUSEADDR</code>옵션과 함께 사용해야 합니다. 예제가 필요하다면  <a href="시스템-콜이-아니면-죽음을.html#bind"><code>bind()</code>에 관한 절</a>과  <a href="약간-더-고급스러운-기술.html#select"><code>select()</code>에 관한 절</a>을 참고하세요.</p><p><strong>시스템에 열린 소켓의 목록을 얻으려면 어떻게 해야하나요?</strong></p><p> <code>netstat</code>를 사용하세요. 완전한 정보에 대해서는 <code>man</code> 을 참고해야 하지만 아래와 같이 입력해도 약간의 유용한 출력을 얻을 수 있습니다.</p><pre><code>$ netstat</code></pre><p>비결은 어떤 소켓이 어떤 프로그램과 연결되어 있는지 알아내는 것입니다. <code>:-)</code></p><p><strong>라우팅 테이블을 보려면 어떻게 해야하나요?</strong></p><p> <code>route</code>명령(대개의 리눅스 장치에서 <code>/sbin</code>에 있다) 을 실행하세요. 아니면  <code>netstat -r</code> 명령을 실행하세요. 혹은  <code>ip route</code> 명령일 수도 있습니다.</p><p><strong>컴퓨터가 하나밖에 없다면 어떻게 클라이언트와 서버 프로그램을 실행하나요? 네트워크 프로그램을 작성하려면 네트워크가 있어야 하는 것 아닌가요?</strong></p><p>여러분에게는 다행히고 사실상 모든 장치가 커널에 자리잡고 네트워크 카드인 척 하는  루프백 네트워크 “장치”를 구현합니다. (이것은 라우팅 테이블에서 “<code>lo</code>”라는 이름으로 표시되는 인터페이스입니다.)</p><p>여러분이  “<code>goat</code>”라는 이름의 장치에 로그인했다고 합시다. 클라이언트를 하나의 창에서 실행하고 서버를 다른 창에서 실행합시다. 아니면 서버를 백그라운드에서 실행하고(“<code>server &amp;</code>”) 클라이언트를 같은 창에서 실행합시다. 루프백 장치는 여러분이 <code>client goat</code>와  <code>client localhost</code>(“<code>localhost</code>”는 여러분의 <code>/etc/hosts</code>파일에 정의되어 있을 것입니다.) 중 어떤 것이든 할 수 있게 해 줄 것이고 네트워크 없이도 서버와 대화하는 클라이언트 프로그램을 시험할 수 있을 것입니다.</p><p>간단히 말하자면 네트워크 없는 단일 장치에서 코드를 실행하기 위해서 코드를 변경할 필요는 없습니다.</p><p><strong>원격지 측에서 연결을 닫았는지 어떻게 알 수 있을까요?</strong></p><p><code>recv()</code>가 <code>0</code>을 돌려주는 것으로 알 수 있습니다.</p><p><strong> “ping” 유틸리티를 만들려면 어떻게 해야하나요?  ICMP는 무엇인가?  raw 소켓과 <code>SOCK_RAW</code> 에 대해서는 어디에서 더 알아볼 수 있을까요?</strong></p><p></p><p>raw 소켓에 대한 모든 질문은 <a href="더-많은-참고문헌.html#books">W. Richard Stevens’ UNIX Network Programming books</a> 에서 답을 얻을 수 있습니다. 또한 <a href="http://www.unpbook.com/src.html">온라인으로 사용 가능한</a><a href="더-많은-참고문헌.html#fn43" class="footnote-ref" id="fnref43"><sup>43</sup></a> Stevens’ UNIX Network Programming source code에서 <code>ping/</code> 하위디렉터리를 살펴보세요.</p><p><strong><code>connect()</code>에 대한 제한시간을 변경하거나 단축할 수 있을까요?</strong></p><p>W. Richard Stevens이 여러분에게 줄 수 있는 답과 동일한 답을 드리는 대신, <a href="http://www.unpbook.com/src.html">UNIX Network Programming source code의 <code>lib/connect_nonb.c</code></a><a href="더-많은-참고문헌.html#fn44" class="footnote-ref" id="fnref44"><sup>44</sup></a> 를 안내해드리겠습니다.</p><p>요점은 <code>socket()</code>으로 소켓 설명자를 만든 후 <a href="약간-더-고급스러운-기술.html#blocking">논 블로킹으로 만든 후에</a> <code>connect()</code>를 호출할 때 모든 것이 잘 돌아간다면 <code>connect()</code>는 즉시 <code>-1</code>을 반환할 것이고 <code>errno</code>는 <code>EINPROGRESS</code>로 설정될 것이라는 것입니다. 그 후 <a href="약간-더-고급스러운-기술.html#select"><code>select()</code></a>를 호출할 때 소켓 설명자를 읽기와 쓰기 집합에 모두 넣으면서 여러분이 원하는 제한시간을 지정하면 됩니다. 시간초과가 발생하지 않으면 <code>connect()</code> 이 완료되었다는 의미다. 이 시점에서 <code>getsockopt()</code>을 <code>SO_ERROR</code>옵션과 함께 호출해서 <code>connect()</code>호출의 반환값을 얻을 수 있고, 오류가 없었다면 그 값은 0이어야 합니다.</p><p>마지막으로 여러분은 아마도 해당 소켓에 데이터를 전송하기 전에 소켓을 다시 블로킹 모드로 설정하고 싶을 것입니다.</p><p>이 방식은 프로그램이 연결을 시작하는 동안 다른 일을 할 수 있게 해 주는 장점도 있음에 주목하세요. 예를 들어 500ms정도의 짧은 제한시간을 설정한 후 <code>select()</code>를 다시 호출합시다. <code>select()</code>가 20번 정도 시간초과를 일으킨다면 연결을 포기할 때가 되었음을 알 수 있습니다.</p><p>위에서도 말씀드렸지만 완벽하게 훌륭한 예제가 필요하다면 Stevens의 코드를 참고하세요.</p><p><strong>Windows를 위해 빌드하려면 어떻게 하나요?</strong></p><p>먼저 윈도우를 삭제한 후 리눅스나 BSD를 설치하세요. <code>};-)</code>. 사실 그럴 필요는 없고, 도입부의 <a href="도입부.html#windows">윈도우즈에서 빌드하기를 위한 절</a>을 살펴보세요.</p><p><strong>Solaris/SunOS에서 빌드하려면 어떻게 하나요? 컴파일을 시도하면 계속 링커 오류가 발생합니다!</strong></p><p>링커 에러는 Sun사의 장치들이 자동적으로 소켓 라이브러리를 링크하지 않기 때문에 발생합니다. 컴파일을 위해서는 도입부의 <a href="도입부.html#solaris">Solaris/SunOS를 위한 절</a> 을 참고하세요.</p><p><strong>왜 <code>select()</code>가 시그널을 받으면 실패하나요?</strong></p><p>시그널은 중단된 시스템 콜이 <code>errno</code>를 <code>EINTR</code>로 설정하고 <code>-1</code>을 반환하게 만듭니다.  <code>sigaction()</code>으로 시그널 핸들러를 설정하면  <code>SA_RESTART</code> 플래그를 설정할 수 있는데 이것이 방해받은(Interrupted) 시스템 콜이 재개되게 해 줄 것입니다.</p><p>태생적으로 이런 방식이 늘 작동하는 것은 아닙니다.(역자 주 : 시스템콜/인터럽션과 관련된 처리는 시스템마다 다를 수 있습니다.)</p><p>제가 선호하는 해결책은  <code>goto</code>문을 쓰는 방법입니다. 물론 이것이 교수님들을 아주 짜증나게 할 수 있지만 쓸만합니다.</p><div class="sourceCode" id="cb78"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb78-1" title="1">select_restart:</a>
<a class="sourceLine" id="cb78-2" title="2"><span class="cf">if</span> ((err = select(fdmax+<span class="dv">1</span>, &amp;readfds, NULL, NULL, NULL)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb78-3" title="3">    <span class="cf">if</span> (errno == EINTR) {</a>
<a class="sourceLine" id="cb78-4" title="4">        <span class="co">// 어떤 시그널이 우리에게 인터럽트를 걸었습니다. 그러니 재시작합니다</span></a>
<a class="sourceLine" id="cb78-5" title="5">        <span class="cf">goto</span> select_restart;</a>
<a class="sourceLine" id="cb78-6" title="6">    }</a>
<a class="sourceLine" id="cb78-7" title="7">    <span class="co">// 진짜 오류는 여기서 처리합니다</span></a>
<a class="sourceLine" id="cb78-8" title="8">    perror(<span class="st">&quot;select&quot;</span>);</a>
<a class="sourceLine" id="cb78-9" title="9">}</a></code></pre></div><p>물론 여기에서 <code>goto</code>를 쓸 <em>필요</em>는 없습니다. 처리를 위해 다른 구조를 쓸 수 있습니다. 그러나 저는 <code>goto</code>문이 사실 더 깔끔하다고 생각합니다. (역자 주 : 필자의 의견에도 불구하고 역자는 goto문을 쓰는 일을 추천하지 않습니다.)</p><p><strong><code>recv()</code>에 대한 호출에 시간제한을 적용하려면 어떻게 해야하나요?</strong></p><p> <a href="약간-더-고급스러운-기술.html#select"><code>select()</code></a>를 사용하라! 그것이 읽어들이려는 소켓 설명자에 시간제한 매개변수를 지정할 수 있게 해줍니다. 아니면 모든 기능을 아래와 같이 하나의 함수에 감쌀 수 있습니다.</p><div class="sourceCode" id="cb79"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb79-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb79-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/time.h&gt;</span></a>
<a class="sourceLine" id="cb79-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb79-4" title="4"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb79-5" title="5"></a>
<a class="sourceLine" id="cb79-6" title="6"><span class="dt">int</span> recvtimeout(<span class="dt">int</span> s, <span class="dt">char</span> *buf, <span class="dt">int</span> len, <span class="dt">int</span> timeout)</a>
<a class="sourceLine" id="cb79-7" title="7">{</a>
<a class="sourceLine" id="cb79-8" title="8">    fd_set fds;</a>
<a class="sourceLine" id="cb79-9" title="9">    <span class="dt">int</span> n;</a>
<a class="sourceLine" id="cb79-10" title="10">    <span class="kw">struct</span> timeval tv;</a>
<a class="sourceLine" id="cb79-11" title="11"></a>
<a class="sourceLine" id="cb79-12" title="12">    <span class="co">// 파일 설명자 집합 생성</span></a>
<a class="sourceLine" id="cb79-13" title="13">    FD_ZERO(&amp;fds);</a>
<a class="sourceLine" id="cb79-14" title="14">    FD_SET(s, &amp;fds);</a>
<a class="sourceLine" id="cb79-15" title="15"></a>
<a class="sourceLine" id="cb79-16" title="16">    <span class="co">// 시간 제한을 위한 timeval 구조체 생성</span></a>
<a class="sourceLine" id="cb79-17" title="17">    tv.tv_sec = timeout;</a>
<a class="sourceLine" id="cb79-18" title="18">    tv.tv_usec = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb79-19" title="19"></a>
<a class="sourceLine" id="cb79-20" title="20">    <span class="co">// 데이터를 받거나 시간이 초과될 때까지 기다린다</span></a>
<a class="sourceLine" id="cb79-21" title="21">    n = select(s+<span class="dv">1</span>, &amp;fds, NULL, NULL, &amp;tv);</a>
<a class="sourceLine" id="cb79-22" title="22">    <span class="cf">if</span> (n == <span class="dv">0</span>) <span class="cf">return</span> <span class="dv">-2</span>; <span class="co">// timeout!</span></a>
<a class="sourceLine" id="cb79-23" title="23">    <span class="cf">if</span> (n == <span class="dv">-1</span>) <span class="cf">return</span> <span class="dv">-1</span>; <span class="co">// error</span></a>
<a class="sourceLine" id="cb79-24" title="24"></a>
<a class="sourceLine" id="cb79-25" title="25">    <span class="co">// 여기에 데이터가 있어야합니다. 그러니 평범한 recv()를 합니다</span></a>
<a class="sourceLine" id="cb79-26" title="26">    <span class="cf">return</span> recv(s, buf, len, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb79-27" title="27">}</a>
<a class="sourceLine" id="cb79-28" title="28">.</a>
<a class="sourceLine" id="cb79-29" title="29">.</a>
<a class="sourceLine" id="cb79-30" title="30">.</a>
<a class="sourceLine" id="cb79-31" title="31"><span class="co">// recvtimeout()에 대한 호출 예시</span></a>
<a class="sourceLine" id="cb79-32" title="32">n = recvtimeout(s, buf, <span class="kw">sizeof</span> buf, <span class="dv">10</span>); <span class="co">// 시간제한 10초</span></a>
<a class="sourceLine" id="cb79-33" title="33"></a>
<a class="sourceLine" id="cb79-34" title="34"><span class="cf">if</span> (n == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb79-35" title="35">    <span class="co">// 오류가 발생했습니다</span></a>
<a class="sourceLine" id="cb79-36" title="36">    perror(<span class="st">&quot;recvtimeout&quot;</span>);</a>
<a class="sourceLine" id="cb79-37" title="37">}</a>
<a class="sourceLine" id="cb79-38" title="38"><span class="cf">else</span> <span class="cf">if</span> (n == <span class="dv">-2</span>) {</a>
<a class="sourceLine" id="cb79-39" title="39">    <span class="co">// 시간이 초과되었습니다</span></a>
<a class="sourceLine" id="cb79-40" title="40">} <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb79-41" title="41">    <span class="co">// 버퍼에 데이터가 들어있습니다</span></a>
<a class="sourceLine" id="cb79-42" title="42">}</a>
<a class="sourceLine" id="cb79-43" title="43">.</a>
<a class="sourceLine" id="cb79-44" title="44">.</a>
<a class="sourceLine" id="cb79-45" title="45">.</a></code></pre></div><p> <code>recvtimeout()</code>이 시간초과 상황에서 <code>-2</code>를 돌려준다는 점에 주목하세요. 왜 <code>0</code>이 아닌지 궁금한가요? <code>recv()</code>가 원격지 연결이 닫혔을 때 <code>0</code>을 돌려준다는 점을 떠올려봅시다. 그러니 그 값은 쓸 수가 없고, <code>-1</code>은 “오류”를 의미합니다. 그래서 저는 시간초과를 가리키는 값으로 <code>-2</code>를 썼습니다.</p><p><strong>소켓에 데이터를 보내기 전에  암호화하거나 압축하려면 어떻게 해야하나요?</strong></p><p>데이터를 암호화 하기 위한 간편한 방법 중 하나는  SSL (secure sockets layer)를 사용하는 것입니다. 그러나 그것은 이 안내서의 범위를 벗어납니다.  (더 많은 정보가 필요하면 <a href="https://www.openssl.org/">OpenSSL 프로젝트</a><a href="더-많은-참고문헌.html#fn45" class="footnote-ref" id="fnref45"><sup>45</sup></a>를 확인하세요.)</p><p>그러나 만약 여러분이 자신만의  압축기나 암호화 체계를 만들거나 써 보고 싶다면, 여러분의 데이터가 양 끝 사이에서 정해진 단계를 거친다는 점을 생각해보세요. 각 단계는 데이터를 특정한 방법으로 바꿉니다.</p><ol type="1"><li>서버가 데이터를 파일(또는 다른 것)에서 읽어들입니다</li><li>서버가 데이터를 암호화/압축합니다(여러분이 이 단계를 추가합니다)</li><li>서버가 암호화된 데이터를 <code>send()</code>합니다</li></ol><p>반대편은 이렇습니다.</p><ol type="1"><li>클라이언트가 암호화된 데이터를 <code>recv()</code>합니다</li><li>클라이언트가 데이터를 복호화/압축해제합니다(여러분이 이 단계를 추가합니다)</li><li>클라이언트가 데이터를 파일(또는 다른 것)에 씁니다</li></ol><p>만약 압축과 암호화를 모두 할 생각이라면 압축을 먼저 해야한다는 점을 기억하세요. <code>:-)</code> (역자 주 : 최소한 순서는 일관되어야 합니다.)</p><p>클라이언트가 서버가 했던 작업을 제대로 거꾸로 수행하기만 한다면 여러분이 얼마나 많은 단계를 추가하던 데이터는 무사히 도착할 것입니다.</p><p>그러므로 여러분이 저의 코드를 쓰기 위해서 할 일은 데이터를 네트워크에서 읽고 보내는 코드의 중간 지점을 찾아내서 암호화를 하는 코드를 끼워넣는 것입니다.</p><p><strong>“<code>PF_INET</code>”이 계속 등장하는데 무엇인가요? <code>AF_INET</code>와 관계가 있을까요?</strong></p><p> </p><p>그렇습니다. 관계가 있습니다. 자세한 사항은 <a href="시스템-콜이-아니면-죽음을.html#socket"><code>socket()</code>에 대한 절</a>을 참고하세요.</p><p><strong>클라이언트에게서 셀 커맨드를 받아서 실행하는 서버는 어떻게 만드나요?</strong></p><p>단순함을 위해서 클라이언트가 <code>connect()</code>와 <code>send()</code> 후에 연결을 <code>close()</code> 처리한다고 가정합시다. (즉 클라이언트가 연결을 닫지 않고 후속 시스템 콜을 보내는 일은 없다는 의미입니다.)</p><p>클라이언트의 과정은 이렇습니다.</p><ol type="1"><li>서버에 <code>connect()</code></li><li><code>send(&quot;/sbin/ls &gt; /tmp/client.out&quot;)</code></li><li>연결에 대한 <code>close()</code> 처리</li></ol><p>한편 서버는 데이터를 받아서 실행합니다.</p><ol type="1"><li>클라이언트의 연결 요청에 대한 <code>accept()</code></li><li>명령 문자열에 대한 <code>recv(str)</code></li><li>연결에 대한 <code>close()</code></li><li>명령을 실행하기 위해서 <code>system(str)</code></li></ol><p> <em>주의하세요!</em> 클라이언트가 말하는 것을 서버가 실행한다는 것은 원격 셀 접근 권한을 주는 것과 비슷한 일이고 그들이 서버에 접속할 때 여러분의 계정으로 무엇인가 할 수 있다는 의미입니다. 위의 예제에서 클라이언트가 “<code>rm -rf ~</code>”를 보내면 어떻게 될까요? 여러분의 계정이 가진 모든 것을 삭제할 것입니다!</p><p>그러니 여러분이 현명하다면 안전하다고 확신하는 몇 개의 유틸리티, 예를 들어 <code>foobar</code> 외의 것을 클라이언트가 실행하지 못하도록 하는 것이 좋습니다.</p><div class="sourceCode" id="cb80"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb80-1" title="1"><span class="cf">if</span> (!strncmp(str, <span class="st">&quot;foobar&quot;</span>, <span class="dv">6</span>)) {</a>
<a class="sourceLine" id="cb80-2" title="2">    sprintf(sysstr, <span class="st">&quot;%s &gt; /tmp/server.out&quot;</span>, str);</a>
<a class="sourceLine" id="cb80-3" title="3">    system(sysstr);</a>
<a class="sourceLine" id="cb80-4" title="4">}</a></code></pre></div><p>그러나 불행히도 이것만으로는 여전히 위험합니다. 클라이언트가 “<code>foobar; rm -rf ~</code>” 를 입력한다면 어떻게 될까요? 가장 안전한 방식은 명령의 매개변수에 들어가는 숫자나 영문자가 아닌 모든 문자(필요하다면 공백 문자도) 앞에 탈출 (“<code>\</code>”) 문자를 붙이는 것입니다.</p><p>보시다시피 보안은 클라이언트가 보낸 것을 서버가 실행할 때에 큰 문제가 됩니다.</p><p><strong>제가 꽤 큰 데이터를 보내는데 <code>recv()</code>를 해보면 한번에 536바이트나 1460바이트 씩만 받아옵니다. 그러나 이것을 로컬 장치에서 실행하면 한 번에 모든 데이터를 받아옵니다. 왜 이런 것인가요?</strong></p><p> MTU에 도달한 것입니다. 이것은 물리계층이 전송가능한 최대 크기입니다. 로컬 장치에서는 루프백 장치를 쓰기에 8K나 그 이상의 크기도 문제없이 다룰 수 있습니다. 그러나 이더넷에서는 헤더를 포함해 1500바이트가 한계입니다. 모뎀을 쓴다면 (마찬가지로 헤더를 포함해)576바이트가 한계입니다.</p><p>일단 모든 데이터가 전송되었음을 확실히 해야합니다. (자세한 정보는<a href="약간-더-고급스러운-기술.html#sendall"><code>sendall()</code></a> 함수의 구현을 확인하세요.) 전송이 잘 되었음이 확실하다면 모든 데이터를 읽어들일 때까지 <code>recv()</code>를 반복문 내부에서 호출해야 합니다.</p><p>여러 번의 <code>recv()</code>호출을 통해 완전한 패킷을 수신하는 작업에 대해 자세한 정보가 필요하다면 <a href="약간-더-고급스러운-기술.html#sonofdataencap">망할 데이터 캡슐화</a> 절을 참고하세요.</p><p><strong>저는 윈도우 장치를 써서 <code>fork()</code>시스템 호출이 없고 <code>struct sigaction</code>같은 것도 없습니다. 어떻게 해야하나요?</strong></p><p> 이것이 있다면 그것은 컴파일러와 함께 있는 POSIX 라이브러리에 있을 것입니다. 저는 윈도우 장치를 가지고 있지 않으므로 그에 대해 정확한 답을 줄 수 없습니다. 그러나 기억하기로는 마이크로소프트가 POSIX 호환성 계층을 만들었고 <code>fork()</code>도 거기에 있을 것입니다. (어쩌면 <code>sigaction</code>도 있을 것입니다.) (역자 주 : 그러나 윈도우에서는 윈도우의 처리법을 사용하는 것이 의도한 결과를 정확히 만드는 더 나은 방법이 될 것입니다.)</p><p>VC++에 딸려오는 도움말에서 “fork”나 “POSIX”를 검색하고 도움이 될만한 것이 있는지 살펴보세요. (역자 주 : VC++ 자체도 Visual Studio가 가진 기능 중 일부의 오래된 이름에 불과합니다. 이 글이 최초에 작성된 것은 90년대임을 기억하세요.)</p><p>그것이 전혀 작동하지 않는다면, <code>fork()</code>/<code>sigaction</code>과 관련된 것들을 떼어내고 그것의 Win32 대응인  <code>CreateProcess()</code>로 교체하세요. 저는 <code>CreateProcess()</code>를 어떻게 쓰는지는 모릅니다. 그것은 수억개의 인수를 받지만 아마도 VC++과 같이 오는 문서에 설명이 있을 것입니다.</p><p><strong> 저는 방화벽 뒤에 있습니다. 방화벽 너머의 사람들이 저의 IP 주소를 알고 저의 장치에 접근하게 하려면 어떻게 해야하나요?</strong></p><p>불행히도 방화벽의 목적은 방화벽 바깥의 사람들이 방화벽 안의 장치에 접근하는 것을 막는 것입니다. 그러므로 그것을 허용하는 것은 보안에 헛점을 만들게 됩니다.</p><p>그러나 모든 것이 안 된다고 말하려고 이 이야기를 꺼낸 것은 아닙니다. 방화벽이 마스커레이딩이나 NAT처리같은 것을 한다면 여전히 <code>connect()</code>로 방화벽 너머에 접근할 수 있습니다. 여러분의 프로그램이 언제나 연결을 게시하는 쪽이 되도록 한다면 문제는 없을 것입니다.</p><p> 만약 그것으로는 충분하지 않다면, 시스템 관리자에게 부탁해서 방화벽에 구멍을 내서 여러분에게 연결할 수 있도록 해야합니다. 방화벽은 그것의 NAT프로그램이나 프록시 등을 써서 여러분에게 연결을 전달(Forward) 해줄 수 있습니다.</p><p>방화벽의 구멍은 가볍게 볼 것이 아니라는 점을 기억하세요. 나쁜 사람들에게 내부 네트워크에 대한 접근 권한을 주지 않도록 해야합니다. 초보자라면 소프트웨어를 안전하게 만드는 것이 생각보다 어렵다는 것을 알아야합니다.</p><p>여러분의 시스템 관리자가 저를 탓하는 일이 없게 해주세요. <code>;-)</code></p><p><strong>  패킷 스니퍼는 어떻게 작성하나요? 어떻게 하면 제 이더넷 인터페이스를 무차별 모드로 설정할 수 있을까요?</strong></p><p>모르는 이들을 위해 설명하자면, 네트워크 카드가 “무차별 모드(promiscuous mode)” 일 때 목적지 주소가 실행중인 장치가 아닌 패킷까지 전부 운영체제에 전달합니다. (우리는 IP 주소가 아닌 이더넷 계층 주소에 대해서 이야기하는 것입니다. 그러나 이더넷은 IP보다 낮은 계층이므로, 사실상 모든 IP주소에 대한 통신이 전달됩니다. 더 자세한 내용은 <a href="소켓이란-무엇인가.html#lowlevel">저수준 넌센스와 네트워크 이론</a>을 참고하세요.)</p><p>이것이 패킷 스니퍼 동작의 기본 원리입니다. 패킷 스니퍼는 인터페이스를 무차별 모드로 만들고, 운영체제는 그 장치를 통해 전달되는 모든 패킷을 받게 됩니다. 여러분은 이런 데이터를 읽을 수 있는 몇 가지 종류의 소켓을 쓸 수 있습니다.</p><p>불행히도 질문에 대한 답은 플랫폼에 따라 다릅니다. 그러나 인터넷을 찾아보면, 예를 들어 “windows promiscuous  ioctl”을 검색한다면 도움이 되는 정볼르 얻을 수 있을것입니다. 리눅스를 위해서는 <a href="https://stackoverflow.com/questions/21323023/">useful Stack Overflow thread</a><a href="더-많은-참고문헌.html#fn46" class="footnote-ref" id="fnref46"><sup>46</sup></a> 같은 정보가 있습니다.</p><p><strong>어떻게 하면 TCP나 UDP소켓에 대해서 사용자 정의한  제한시간 값을 사용할 수 있을까요?</strong></p><p>시스템에 따라 다릅니다. 여러분의 시스템이 어떤 기능을 지원하는지 알아내기 위해서 (그리고 그것을  <code>setsockopt()</code>에 쓰기 위해서)  <code>SO_RCVTIMEO</code>나  <code>SO_SNDTIMEO</code> 같은 것을 인터넷에서 찾아봐야 할 것입니다.</p><p>리눅스의 맨페이지는 <code>alarm()</code>나 <code>setitimer()</code>를 대체재로 쓸 것을 권합니다.</p><p><strong>어떤 포트가 사용 가능한 상태인지는 어떻게 알아내나요? “공식적인” 포트 번호 목록같은 것이 있을까요?</strong></p><p>보통 이것은 문제가 되지 않습니다. 여러분이 웹 서버를 작성한다고 하면, 80번같이 잘 알려진 포트를 쓰는 것이 좋습니다. 여러분만의 특별한 목적의 서버를 작성한다면 무작위의 포트 번호(그러나 1023보다 큰 것으로)를 고르고 시도해보세요.</p><p>만약 포트가 이미 사용중이라면 <code>bind()</code>를 시도할 때 “Address already in use” 오류가 발생할 것입니다. 다른 포트를 고르세요. (여러분의 소프트웨어의 사용자가 설정 파일이나 명령줄 스위치로 대체 포트를 지정할 수 있게 하는 것이 좋습니다.)</p><p>인터넷 할당 번호 관리 기관(the Internet Assigned Numbers Authority, IANA) 이 관리하는 <a href="https://www.iana.org/assignments/port-numbers">공식 포트 번호</a><a href="더-많은-참고문헌.html#fn47" class="footnote-ref" id="fnref47"><sup>47</sup></a> 가 있습니다. (1023보다 큰) 어떤 번호가 저 목록에 없다고 해서 그 포트를 쓸 수 없는 것은 아닙니다. 예를 들어 Id Software의 DOOM은 “mdqs”(이것이 무엇이든) 와 같은 포트를 쓴다. 중요한 것은 <em>같은 장치</em>의 누구도 여러분이 그 포트를 쓰고 싶을 때 그 포트를 쓰고 있지 않으면 된다는 것입니다.</p><hr><div style="text-align:center"><span><a href="약간-더-고급스러운-기술.html">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="man-pages.html">Next</a></span></div></body>
</html>
