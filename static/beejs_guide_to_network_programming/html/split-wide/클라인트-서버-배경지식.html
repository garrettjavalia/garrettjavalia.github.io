<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Beej의 네트워크 프로그래밍 안내서</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono&display=swap" rel="stylesheet"> 
  <link rel="stylesheet" as="style" crossorigin="None" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.6/dist/web/static/pretendard.css" />
  <!-- BG custom styling -->
  <style type="text/css">
  /* Fix for line numbers not visible */
  pre.numberSource code > span {
      left: -1em;
  }
  pre.numberSource {
      margin-left: initial;
  }
  
  /* Put some space after the section numbers */
  span.toc-section-number::after {
      content: "\a0\a0\a0";  /* non-breaking whitespace */
  }
  
  /* Hide underlines on code number links */
  pre > code.sourceCode > span > a:first-child::before {
      text-decoration: none;
  }
  
  /* Color the source blocks */
  div.sourceCode {
      background-color: #f0f0f0;
  }
  
  /* Fix iOS big text rendering issue */
  pre > code.sourceCode > span {
      display: initial;
  }
  
  
  /* Color the inline code */
  code:not(.sourceCode) {
      background: #f0f0f0;
      padding-left: 0.2em;
      padding-right: 0.2em;
      border-radius: 0.2em;
  }
  
  /* Keep code tags from wrapping in tables */
  tbody code {
      white-space: nowrap;
  }
  
  td {
      vertical-align: top;
  }
  
  body {
      font-size: 12pt;
      box-sizing: border-box;
      margin: 0;
      padding: 1em;
      max-width: min(43em, 100vw);
  }
  
  html {
      display: flex;
      justify-content: center;
      font-family: -apple-system, BlinkMacSystemFont, "Apple SD Gothic Neo", "Pretendard Variable", Pretendard, Roboto, "Noto Sans KR", "Segoe UI", "Malgun Gothic", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
  }
  
  figure {
      text-align: center;
  }
  </style>
  <!-- BG custom styling for the wide body variant -->
  <!-- Gets appended after bg-css.html -->
  
  <style type="text/css">
  body {
      max-width: inherit;
  }
  </style>
</head>
<body>
<div style="text-align:center"><span><a href="시스템-콜이-아니면-죽음을.html">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="약간-더-고급스러운-기술.html">Next</a></span></div><hr>
<h1 id="클라인트-서버-배경지식"><span class="header-section-number">6</span> 클라인트-서버 배경지식</h1><p></p><p>클라이언트-서버에 대해 이야기할 차례이다. 통신망에 있는 거의 모든 것들은 서버 프로세스에게 이야기하는 클라이언트 프로세스를 상대하거나 그 반대이다. <code>telnet</code>을 예로 들어보자. 여러분이 텔넷(클라이언트)로 원격지 호스트의 23번 포트에 접속할 때 그 호스트의 프로그램(<code>telnetd</code>라고 불리는 서버)이 생명을 얻는다. 그것이 들어오는 텔넷 요청을 처리하고 당신에게 로그인 프롬프트를 띄워주는 등의 일을 처리한다.</p><figure><embed src="cs.svg" title="[클라이언트- 서버 상호작용 도표]" /><figcaption>클라이언트 - 서버 상호작용</figcaption></figure><p>위의 도표에 클라이언트와 서버의 정보 교환이 정리되어 있습니다.</p><p>클라이언트-서버 쌍은 <code>SOCK_STREAM</code>이나 <code>SOCK_DGRAM</code> 또는 다른 어떤 것이라도 말할 수 있음을 기억하십시오.(둘이 같은 방식으로 말하기만 한다면) 클라이언트-서버 쌍의 좋은 예시는 <code>telnet</code>/<code>telnetd</code>, <code>ftp</code>/<code>ftpd</code> 또는 <code>Firefox</code>/<code>Apache</code> 입니다. 당신이 <code>ftp</code>를 쓸 때마다 당신의 요청을 받아들이는 원격지 프로그램인 <code>ftpd</code>가 있습니다.</p><p>흔히 한 대의 장치에는 오직 하나의 서버만이 있을 것이며 그 서버는  <code>fork()</code> 를 통해서 여러 클라이언트를 처리할 것입니다.(역자 주 : 한 대의 장치에서 여러 개의 서버를 실행하는 많은 방법이 있지만 이 문서의 초판은 90년대에 작성되었습니다. ) 기본적인 과정은 아래와 같습니다. 서버가 연결을 기다리고, <code>accept()</code>한 후, 요청을 처리할 자식 프로세스를 <code>fork()</code>합니다. 이것이 다음 절에서 우리의 예제 서버가 하는 일입니다.</p><h2 id="단순한-스트림-서버"><span class="header-section-number">6.1</span> 단순한 스트림 서버</h2><p></p><p>이 서버가 하는 일은 스트림 연결에 “<code>Hello, world!</code>”을 전송하는 것 뿐입니다. 이 서버를 시험하기 위해서 할 일은 하나의 창에서 이것을 실행한 후 다른 창에서 텔넷에 아래 명령어로 접속하는 일 뿐입니다.</p><pre><code>$ telnet remotehostname 3490</code></pre><p><code>remotehostname</code>은 당신이 실행하는 장치의 아이피입니다.</p><p><a href="https://beej.us/guide/bgnet/examples/server.c">The server code</a><a href="more-references.html#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a>:</p><div class="sourceCode" id="cb47"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb47-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb47-2" title="2"><span class="co">** server.c -- a stream socket server demo</span></a>
<a class="sourceLine" id="cb47-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb47-4" title="4"></a>
<a class="sourceLine" id="cb47-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb47-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb47-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb47-8" title="8"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb47-9" title="9"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb47-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb47-11" title="11"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb47-12" title="12"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb47-13" title="13"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb47-14" title="14"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb47-15" title="15"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb47-16" title="16"><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb47-17" title="17"></a>
<a class="sourceLine" id="cb47-18" title="18"><span class="pp">#define PORT &quot;3490&quot;  </span><span class="co">// 사용자들이 접속할 포트</span></a>
<a class="sourceLine" id="cb47-19" title="19"></a>
<a class="sourceLine" id="cb47-20" title="20"><span class="pp">#define BACKLOG 10   </span><span class="co">// 몇 개의 대기중인 연결이 유지될 것인가</span></a>
<a class="sourceLine" id="cb47-21" title="21"></a>
<a class="sourceLine" id="cb47-22" title="22"><span class="dt">void</span> sigchld_handler(<span class="dt">int</span> s)</a>
<a class="sourceLine" id="cb47-23" title="23">{</a>
<a class="sourceLine" id="cb47-24" title="24">    <span class="co">// waitpid()이 errno를 덮어쓸 수 있으므로 저장했다가 되살린다.</span></a>
<a class="sourceLine" id="cb47-25" title="25">    <span class="dt">int</span> saved_errno = errno;</a>
<a class="sourceLine" id="cb47-26" title="26"></a>
<a class="sourceLine" id="cb47-27" title="27">    <span class="cf">while</span>(waitpid(-<span class="dv">1</span>, NULL, WNOHANG) &gt; <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb47-28" title="28"></a>
<a class="sourceLine" id="cb47-29" title="29">    errno = saved_errno;</a>
<a class="sourceLine" id="cb47-30" title="30">}</a>
<a class="sourceLine" id="cb47-31" title="31"></a>
<a class="sourceLine" id="cb47-32" title="32"></a>
<a class="sourceLine" id="cb47-33" title="33"><span class="co">// IPv4 또는 IPv6 sockaddr을 받아온다.</span></a>
<a class="sourceLine" id="cb47-34" title="34"><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</a>
<a class="sourceLine" id="cb47-35" title="35">{</a>
<a class="sourceLine" id="cb47-36" title="36">    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</a>
<a class="sourceLine" id="cb47-37" title="37">        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</a>
<a class="sourceLine" id="cb47-38" title="38">    }</a>
<a class="sourceLine" id="cb47-39" title="39"></a>
<a class="sourceLine" id="cb47-40" title="40">    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</a>
<a class="sourceLine" id="cb47-41" title="41">}</a>
<a class="sourceLine" id="cb47-42" title="42"></a>
<a class="sourceLine" id="cb47-43" title="43"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb47-44" title="44">{</a>
<a class="sourceLine" id="cb47-45" title="45">    <span class="dt">int</span> sockfd, new_fd;  <span class="co">// sock_fd에서 대기하고 들어오는 연결은 new_fd에 저장</span></a>
<a class="sourceLine" id="cb47-46" title="46">    <span class="kw">struct</span> addrinfo hints, *servinfo, *p;</a>
<a class="sourceLine" id="cb47-47" title="47">    <span class="kw">struct</span> sockaddr_storage their_addr; <span class="co">// 접속자의 주소 정보</span></a>
<a class="sourceLine" id="cb47-48" title="48">    socklen_t sin_size;</a>
<a class="sourceLine" id="cb47-49" title="49">    <span class="kw">struct</span> sigaction sa;</a>
<a class="sourceLine" id="cb47-50" title="50">    <span class="dt">int</span> yes=<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb47-51" title="51">    <span class="dt">char</span> s[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb47-52" title="52">    <span class="dt">int</span> rv;</a>
<a class="sourceLine" id="cb47-53" title="53"></a>
<a class="sourceLine" id="cb47-54" title="54">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb47-55" title="55">    hints.ai_family = AF_UNSPEC;</a>
<a class="sourceLine" id="cb47-56" title="56">    hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb47-57" title="57">    hints.ai_flags = AI_PASSIVE; <span class="co">// use my IP</span></a>
<a class="sourceLine" id="cb47-58" title="58"></a>
<a class="sourceLine" id="cb47-59" title="59">    <span class="cf">if</span> ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb47-60" title="60">        fprintf(stderr, <span class="st">&quot;getaddrinfo: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(rv));</a>
<a class="sourceLine" id="cb47-61" title="61">        <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb47-62" title="62">    }</a>
<a class="sourceLine" id="cb47-63" title="63"></a>
<a class="sourceLine" id="cb47-64" title="64">    <span class="co">// 모든 결과를 조회하고 쓸 수 있는 첫 번째 것을 사용</span></a>
<a class="sourceLine" id="cb47-65" title="65">    <span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb47-66" title="66">        <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</a>
<a class="sourceLine" id="cb47-67" title="67">                p-&gt;ai_protocol)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb47-68" title="68">            perror(<span class="st">&quot;server: socket&quot;</span>);</a>
<a class="sourceLine" id="cb47-69" title="69">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb47-70" title="70">        }</a>
<a class="sourceLine" id="cb47-71" title="71"></a>
<a class="sourceLine" id="cb47-72" title="72">        <span class="cf">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,</a>
<a class="sourceLine" id="cb47-73" title="73">                <span class="kw">sizeof</span>(<span class="dt">int</span>)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb47-74" title="74">            perror(<span class="st">&quot;setsockopt&quot;</span>);</a>
<a class="sourceLine" id="cb47-75" title="75">            exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb47-76" title="76">        }</a>
<a class="sourceLine" id="cb47-77" title="77"></a>
<a class="sourceLine" id="cb47-78" title="78">        <span class="cf">if</span> (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb47-79" title="79">            close(sockfd);</a>
<a class="sourceLine" id="cb47-80" title="80">            perror(<span class="st">&quot;server: bind&quot;</span>);</a>
<a class="sourceLine" id="cb47-81" title="81">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb47-82" title="82">        }</a>
<a class="sourceLine" id="cb47-83" title="83"></a>
<a class="sourceLine" id="cb47-84" title="84">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb47-85" title="85">    }</a>
<a class="sourceLine" id="cb47-86" title="86"></a>
<a class="sourceLine" id="cb47-87" title="87">    freeaddrinfo(servinfo); <span class="co">// 이 구조체는 더 이상 필요없음</span></a>
<a class="sourceLine" id="cb47-88" title="88"></a>
<a class="sourceLine" id="cb47-89" title="89">    <span class="cf">if</span> (p == NULL)  {</a>
<a class="sourceLine" id="cb47-90" title="90">        fprintf(stderr, <span class="st">&quot;server: failed to bind</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb47-91" title="91">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb47-92" title="92">    }</a>
<a class="sourceLine" id="cb47-93" title="93"></a>
<a class="sourceLine" id="cb47-94" title="94">    <span class="cf">if</span> (listen(sockfd, BACKLOG) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb47-95" title="95">        perror(<span class="st">&quot;listen&quot;</span>);</a>
<a class="sourceLine" id="cb47-96" title="96">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb47-97" title="97">    }</a>
<a class="sourceLine" id="cb47-98" title="98"></a>
<a class="sourceLine" id="cb47-99" title="99">    sa.sa_handler = sigchld_handler; <span class="co">// 죽은 프로세스를 다 거둬들이자</span></a>
<a class="sourceLine" id="cb47-100" title="100">    sigemptyset(&amp;sa.sa_mask);</a>
<a class="sourceLine" id="cb47-101" title="101">    sa.sa_flags =   ;</a>
<a class="sourceLine" id="cb47-102" title="102">    <span class="cf">if</span> (sigaction(SIGCHLD, &amp;sa, NULL) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb47-103" title="103">        perror(<span class="st">&quot;sigaction&quot;</span>);</a>
<a class="sourceLine" id="cb47-104" title="104">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb47-105" title="105">    }</a>
<a class="sourceLine" id="cb47-106" title="106"></a>
<a class="sourceLine" id="cb47-107" title="107">    printf(<span class="st">&quot;server: waiting for connections...</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb47-108" title="108"></a>
<a class="sourceLine" id="cb47-109" title="109">    <span class="cf">while</span>(<span class="dv">1</span>) {  <span class="co">// 주 accept() 루프</span></a>
<a class="sourceLine" id="cb47-110" title="110">        sin_size = <span class="kw">sizeof</span> their_addr;</a>
<a class="sourceLine" id="cb47-111" title="111">        new_fd = accept(sockfd, (<span class="kw">struct</span> sockaddr *)&amp;their_addr, &amp;sin_size);</a>
<a class="sourceLine" id="cb47-112" title="112">        <span class="cf">if</span> (new_fd == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb47-113" title="113">            perror(<span class="st">&quot;accept&quot;</span>);</a>
<a class="sourceLine" id="cb47-114" title="114">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb47-115" title="115">        }</a>
<a class="sourceLine" id="cb47-116" title="116"></a>
<a class="sourceLine" id="cb47-117" title="117">        inet_ntop(their_addr.ss_family,</a>
<a class="sourceLine" id="cb47-118" title="118">            get_in_addr((<span class="kw">struct</span> sockaddr *)&amp;their_addr),</a>
<a class="sourceLine" id="cb47-119" title="119">            s, <span class="kw">sizeof</span> s);</a>
<a class="sourceLine" id="cb47-120" title="120">        printf(<span class="st">&quot;server: got connection from %s</span><span class="sc">\n</span><span class="st">&quot;</span>, s);</a>
<a class="sourceLine" id="cb47-121" title="121"></a>
<a class="sourceLine" id="cb47-122" title="122">        <span class="cf">if</span> (!fork()) { <span class="co">// 자식 프로세스이다.</span></a>
<a class="sourceLine" id="cb47-123" title="123">            close(sockfd); <span class="co">// 자식은 리스너가 필요없다.</span></a>
<a class="sourceLine" id="cb47-124" title="124">            <span class="cf">if</span> (send(new_fd, <span class="st">&quot;Hello, world!&quot;</span>, <span class="dv">13</span>, <span class="dv">0</span>) == <span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb47-125" title="125">                perror(<span class="st">&quot;send&quot;</span>);</a>
<a class="sourceLine" id="cb47-126" title="126">            close(new_fd);</a>
<a class="sourceLine" id="cb47-127" title="127">            exit(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb47-128" title="128">        }</a>
<a class="sourceLine" id="cb47-129" title="129">        close(new_fd);  <span class="co">// 부모는 이것이 필요없다.</span></a>
<a class="sourceLine" id="cb47-130" title="130">    }</a>
<a class="sourceLine" id="cb47-131" title="131"></a>
<a class="sourceLine" id="cb47-132" title="132">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb47-133" title="133">}</a></code></pre></div><p>궁금한 독자들을 위해 덧붙이자면 구문의 명료함을 위해서 하나의 큰 <code>main()</code>함수 안에 모든 코드를 다 적었습니다. 원한다면 더 작은 함수들로 나누어도 좋습니다.</p><p>(아마도 이  <code>sigaction()</code>을 처음 볼 수도 있는데 괜찮다. 이 코드는 <code>fork()</code>된 자식 프로세스가 종료되면서 생기는 좀비 프로세스를 거둬들이는 데 사용된다. 좀비 프로세스를 많이 만들고 거둬들이지 않으면 시스템 관리자가 흥분할 것이다.)</p><p>다음 절에 나오는 클라이언트를 사용해서 이 서버로부터 데이터를 얻을 수 있다.</p><p></p><h2 id="단순한-스트림-클라이언트"><span class="header-section-number">6.2</span> 단순한 스트림 클라이언트</h2><p></p><p>이 녀석은 서버보다도 더 쉽다. 이 클라이언트가 하는 일은 당신이 명령줄에 지정한 호스트의 3490번 포트로 접속하는 것이다. 이것은 서버가 보낸 문자열을 받는다.</p><p><a href="https://beej.us/guide/bgnet/examples/client.c">The client source</a><a href="more-references.html#fn24" class="footnote-ref" id="fnref24"><sup>24</sup></a>:</p><div class="sourceCode" id="cb48"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb48-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb48-2" title="2"><span class="co">** client.c -- a stream socket client demo</span></a>
<a class="sourceLine" id="cb48-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb48-4" title="4"></a>
<a class="sourceLine" id="cb48-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb48-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb48-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb48-8" title="8"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb48-9" title="9"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb48-10" title="10"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb48-11" title="11"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb48-12" title="12"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb48-13" title="13"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb48-14" title="14"></a>
<a class="sourceLine" id="cb48-15" title="15"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb48-16" title="16"></a>
<a class="sourceLine" id="cb48-17" title="17"><span class="pp">#define PORT &quot;3490&quot; </span><span class="co">// 클라이언트가 접속할 포트</span></a>
<a class="sourceLine" id="cb48-18" title="18"></a>
<a class="sourceLine" id="cb48-19" title="19"><span class="pp">#define MAXDATASIZE 100 </span><span class="co">// 한 번에 받을 수 있는 최대 바이트 갯수</span></a>
<a class="sourceLine" id="cb48-20" title="20"></a>
<a class="sourceLine" id="cb48-21" title="21"><span class="co">// get sockaddr, IPv4 or IPv6:</span></a>
<a class="sourceLine" id="cb48-22" title="22"><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</a>
<a class="sourceLine" id="cb48-23" title="23">{</a>
<a class="sourceLine" id="cb48-24" title="24">    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</a>
<a class="sourceLine" id="cb48-25" title="25">        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</a>
<a class="sourceLine" id="cb48-26" title="26">    }</a>
<a class="sourceLine" id="cb48-27" title="27"></a>
<a class="sourceLine" id="cb48-28" title="28">    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</a>
<a class="sourceLine" id="cb48-29" title="29">}</a>
<a class="sourceLine" id="cb48-30" title="30"></a>
<a class="sourceLine" id="cb48-31" title="31"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb48-32" title="32">{</a>
<a class="sourceLine" id="cb48-33" title="33">    <span class="dt">int</span> sockfd, numbytes;</a>
<a class="sourceLine" id="cb48-34" title="34">    <span class="dt">char</span> buf[MAXDATASIZE];</a>
<a class="sourceLine" id="cb48-35" title="35">    <span class="kw">struct</span> addrinfo hints, *servinfo, *p;</a>
<a class="sourceLine" id="cb48-36" title="36">    <span class="dt">int</span> rv;</a>
<a class="sourceLine" id="cb48-37" title="37">    <span class="dt">char</span> s[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb48-38" title="38"></a>
<a class="sourceLine" id="cb48-39" title="39">    <span class="cf">if</span> (argc != <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb48-40" title="40">        fprintf(stderr,<span class="st">&quot;usage: client hostname</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb48-41" title="41">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb48-42" title="42">    }</a>
<a class="sourceLine" id="cb48-43" title="43"></a>
<a class="sourceLine" id="cb48-44" title="44">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb48-45" title="45">    hints.ai_family = AF_UNSPEC;</a>
<a class="sourceLine" id="cb48-46" title="46">    hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb48-47" title="47"></a>
<a class="sourceLine" id="cb48-48" title="48">    <span class="cf">if</span> ((rv = getaddrinfo(argv[<span class="dv">1</span>], PORT, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb48-49" title="49">        fprintf(stderr, <span class="st">&quot;getaddrinfo: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(rv));</a>
<a class="sourceLine" id="cb48-50" title="50">        <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb48-51" title="51">    }</a>
<a class="sourceLine" id="cb48-52" title="52"></a>
<a class="sourceLine" id="cb48-53" title="53">    <span class="co">// 모든 결과를 순회하면서 쓸 수 있는 가장 첫 번째 것을 씀</span></a>
<a class="sourceLine" id="cb48-54" title="54">    <span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb48-55" title="55">        <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</a>
<a class="sourceLine" id="cb48-56" title="56">                p-&gt;ai_protocol)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb48-57" title="57">            perror(<span class="st">&quot;client: socket&quot;</span>);</a>
<a class="sourceLine" id="cb48-58" title="58">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb48-59" title="59">        }</a>
<a class="sourceLine" id="cb48-60" title="60"></a>
<a class="sourceLine" id="cb48-61" title="61">        <span class="cf">if</span> (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb48-62" title="62">            close(sockfd);</a>
<a class="sourceLine" id="cb48-63" title="63">            perror(<span class="st">&quot;client: connect&quot;</span>);</a>
<a class="sourceLine" id="cb48-64" title="64">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb48-65" title="65">        }</a>
<a class="sourceLine" id="cb48-66" title="66"></a>
<a class="sourceLine" id="cb48-67" title="67">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb48-68" title="68">    }</a>
<a class="sourceLine" id="cb48-69" title="69"></a>
<a class="sourceLine" id="cb48-70" title="70">    <span class="cf">if</span> (p == NULL) {</a>
<a class="sourceLine" id="cb48-71" title="71">        fprintf(stderr, <span class="st">&quot;client: failed to connect</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb48-72" title="72">        <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb48-73" title="73">    }</a>
<a class="sourceLine" id="cb48-74" title="74"></a>
<a class="sourceLine" id="cb48-75" title="75">    inet_ntop(p-&gt;ai_family, get_in_addr((<span class="kw">struct</span> sockaddr *)p-&gt;ai_addr),</a>
<a class="sourceLine" id="cb48-76" title="76">            s, <span class="kw">sizeof</span> s);</a>
<a class="sourceLine" id="cb48-77" title="77">    printf(<span class="st">&quot;client: connecting to %s</span><span class="sc">\n</span><span class="st">&quot;</span>, s);</a>
<a class="sourceLine" id="cb48-78" title="78"></a>
<a class="sourceLine" id="cb48-79" title="79">    freeaddrinfo(servinfo); <span class="co">// 이 구조체는 더 이상 필요 없음</span></a>
<a class="sourceLine" id="cb48-80" title="80"></a>
<a class="sourceLine" id="cb48-81" title="81">    <span class="cf">if</span> ((numbytes = recv(sockfd, buf, MAXDATASIZE<span class="dv">-1</span>, <span class="dv">0</span>)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb48-82" title="82">        perror(<span class="st">&quot;recv&quot;</span>);</a>
<a class="sourceLine" id="cb48-83" title="83">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb48-84" title="84">    }</a>
<a class="sourceLine" id="cb48-85" title="85"></a>
<a class="sourceLine" id="cb48-86" title="86">    buf[numbytes] = &#39;\<span class="dv">0</span>&#39;;</a>
<a class="sourceLine" id="cb48-87" title="87"></a>
<a class="sourceLine" id="cb48-88" title="88">    printf(<span class="st">&quot;client: received &#39;%s&#39;</span><span class="sc">\n</span><span class="st">&quot;</span>,buf);</a>
<a class="sourceLine" id="cb48-89" title="89"></a>
<a class="sourceLine" id="cb48-90" title="90">    close(sockfd);</a>
<a class="sourceLine" id="cb48-91" title="91"></a>
<a class="sourceLine" id="cb48-92" title="92">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb48-93" title="93">}</a></code></pre></div><p>클라이언트를 실행하기 전에 서버를 실행하지 않으면 <code>connect()</code>는  “Connection refused”를 반환한다는 점을 기억하라. 아주 유용하다.</p><p></p><h2 id="datagram"><span class="header-section-number">6.3</span> 데이터그램 소켓</h2><p></p><p>위에서 <code>sendto()</code>과 <code>recvfrom()</code>에 대해 논의할 때 UDP 데이터그램 소켓의 기본에 대해서 이미 알아보았다. 그러므로 바로 2개의 예제 프로그램을 제시하겠다. <code>talker.c</code>와 <code>listener.c</code>이다.</p><p><code>listener</code>는 장치에서 포트 4950으로 들어오는 패킷을 대기한다. <code>talker</code>는 지정한 장치의 해당 포트로 사용자가 명령줄에 입력한 내용을 담은 패킷을 보낸다.</p><p>데이터그램 소켓은 연결이 없고 소켓을 이더넷에 발송한 후 성공 여부는 신경쓰지 않기 때문에 클라이언트와 서버에 IPv6을 사용하도록 명시할 것이다. 이렇게 하면 서버가 IPv6에서 듣고 클라이언트가 IPv4에서 발송해서 데이터를 받을 수 없는 상황을 피할 수 있을 것이다. (우리의 TCP 스트림 소켓 세상에서도 이런 불일치가 발생할 수 있지만 <code>connect()</code>에서 하나의 주소 체계에 대해 에러를 발생시키고 다른 주소체계를 쓰도록 해준다.)</p><p>여기에 <a href="https://beej.us/guide/bgnet/examples/listener.c"><code>listener.c</code>의 소스코드가 있다.</a><a href="more-references.html#fn25" class="footnote-ref" id="fnref25"><sup>25</sup></a>:</p><div class="sourceCode" id="cb49"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb49-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb49-2" title="2"><span class="co">** listener.c -- a datagram sockets &quot;server&quot; demo</span></a>
<a class="sourceLine" id="cb49-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb49-4" title="4"></a>
<a class="sourceLine" id="cb49-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb49-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb49-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb49-8" title="8"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb49-9" title="9"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb49-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb49-11" title="11"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb49-12" title="12"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb49-13" title="13"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb49-14" title="14"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb49-15" title="15"></a>
<a class="sourceLine" id="cb49-16" title="16"><span class="pp">#define MYPORT &quot;4950&quot;    </span><span class="co">// the port users will be connecting to</span></a>
<a class="sourceLine" id="cb49-17" title="17"></a>
<a class="sourceLine" id="cb49-18" title="18"><span class="pp">#define MAXBUFLEN 100</span></a>
<a class="sourceLine" id="cb49-19" title="19"></a>
<a class="sourceLine" id="cb49-20" title="20"><span class="co">// get sockaddr, IPv4 or IPv6:</span></a>
<a class="sourceLine" id="cb49-21" title="21"><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</a>
<a class="sourceLine" id="cb49-22" title="22">{</a>
<a class="sourceLine" id="cb49-23" title="23">    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</a>
<a class="sourceLine" id="cb49-24" title="24">        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</a>
<a class="sourceLine" id="cb49-25" title="25">    }</a>
<a class="sourceLine" id="cb49-26" title="26"></a>
<a class="sourceLine" id="cb49-27" title="27">    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</a>
<a class="sourceLine" id="cb49-28" title="28">}</a>
<a class="sourceLine" id="cb49-29" title="29"></a>
<a class="sourceLine" id="cb49-30" title="30"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb49-31" title="31">{</a>
<a class="sourceLine" id="cb49-32" title="32">    <span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb49-33" title="33">    <span class="kw">struct</span> addrinfo hints, *servinfo, *p;</a>
<a class="sourceLine" id="cb49-34" title="34">    <span class="dt">int</span> rv;</a>
<a class="sourceLine" id="cb49-35" title="35">    <span class="dt">int</span> numbytes;</a>
<a class="sourceLine" id="cb49-36" title="36">    <span class="kw">struct</span> sockaddr_storage their_addr;</a>
<a class="sourceLine" id="cb49-37" title="37">    <span class="dt">char</span> buf[MAXBUFLEN];</a>
<a class="sourceLine" id="cb49-38" title="38">    socklen_t addr_len;</a>
<a class="sourceLine" id="cb49-39" title="39">    <span class="dt">char</span> s[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb49-40" title="40"></a>
<a class="sourceLine" id="cb49-41" title="41">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb49-42" title="42">    hints.ai_family = AF_INET6; <span class="co">// set to AF_INET to use IPv4</span></a>
<a class="sourceLine" id="cb49-43" title="43">    hints.ai_socktype = SOCK_DGRAM;</a>
<a class="sourceLine" id="cb49-44" title="44">    hints.ai_flags = AI_PASSIVE; <span class="co">// use my IP</span></a>
<a class="sourceLine" id="cb49-45" title="45"></a>
<a class="sourceLine" id="cb49-46" title="46">    <span class="cf">if</span> ((rv = getaddrinfo(NULL, MYPORT, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb49-47" title="47">        fprintf(stderr, <span class="st">&quot;getaddrinfo: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(rv));</a>
<a class="sourceLine" id="cb49-48" title="48">        <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb49-49" title="49">    }</a>
<a class="sourceLine" id="cb49-50" title="50"></a>
<a class="sourceLine" id="cb49-51" title="51">    <span class="co">// loop through all the results and bind to the first we can</span></a>
<a class="sourceLine" id="cb49-52" title="52">    <span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb49-53" title="53">        <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</a>
<a class="sourceLine" id="cb49-54" title="54">                p-&gt;ai_protocol)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb49-55" title="55">            perror(<span class="st">&quot;listener: socket&quot;</span>);</a>
<a class="sourceLine" id="cb49-56" title="56">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb49-57" title="57">        }</a>
<a class="sourceLine" id="cb49-58" title="58"></a>
<a class="sourceLine" id="cb49-59" title="59">        <span class="cf">if</span> (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb49-60" title="60">            close(sockfd);</a>
<a class="sourceLine" id="cb49-61" title="61">            perror(<span class="st">&quot;listener: bind&quot;</span>);</a>
<a class="sourceLine" id="cb49-62" title="62">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb49-63" title="63">        }</a>
<a class="sourceLine" id="cb49-64" title="64"></a>
<a class="sourceLine" id="cb49-65" title="65">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb49-66" title="66">    }</a>
<a class="sourceLine" id="cb49-67" title="67"></a>
<a class="sourceLine" id="cb49-68" title="68">    <span class="cf">if</span> (p == NULL) {</a>
<a class="sourceLine" id="cb49-69" title="69">        fprintf(stderr, <span class="st">&quot;listener: failed to bind socket</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb49-70" title="70">        <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb49-71" title="71">    }</a>
<a class="sourceLine" id="cb49-72" title="72"></a>
<a class="sourceLine" id="cb49-73" title="73">    freeaddrinfo(servinfo);</a>
<a class="sourceLine" id="cb49-74" title="74"></a>
<a class="sourceLine" id="cb49-75" title="75">    printf(<span class="st">&quot;listener: waiting to recvfrom...</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb49-76" title="76"></a>
<a class="sourceLine" id="cb49-77" title="77">    addr_len = <span class="kw">sizeof</span> their_addr;</a>
<a class="sourceLine" id="cb49-78" title="78">    <span class="cf">if</span> ((numbytes = recvfrom(sockfd, buf, MAXBUFLEN<span class="dv">-1</span> , <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb49-79" title="79">        (<span class="kw">struct</span> sockaddr *)&amp;their_addr, &amp;addr_len)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb49-80" title="80">        perror(<span class="st">&quot;recvfrom&quot;</span>);</a>
<a class="sourceLine" id="cb49-81" title="81">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb49-82" title="82">    }</a>
<a class="sourceLine" id="cb49-83" title="83"></a>
<a class="sourceLine" id="cb49-84" title="84">    printf(<span class="st">&quot;listener: got packet from %s</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb49-85" title="85">        inet_ntop(their_addr.ss_family,</a>
<a class="sourceLine" id="cb49-86" title="86">            get_in_addr((<span class="kw">struct</span> sockaddr *)&amp;their_addr),</a>
<a class="sourceLine" id="cb49-87" title="87">            s, <span class="kw">sizeof</span> s));</a>
<a class="sourceLine" id="cb49-88" title="88">    printf(<span class="st">&quot;listener: packet is %d bytes long</span><span class="sc">\n</span><span class="st">&quot;</span>, numbytes);</a>
<a class="sourceLine" id="cb49-89" title="89">    buf[numbytes] = &#39;\<span class="dv">0</span>&#39;;</a>
<a class="sourceLine" id="cb49-90" title="90">    printf(<span class="st">&quot;listener: packet contains </span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;\n</span><span class="st">&quot;</span>, buf);</a>
<a class="sourceLine" id="cb49-91" title="91"></a>
<a class="sourceLine" id="cb49-92" title="92">    close(sockfd);</a>
<a class="sourceLine" id="cb49-93" title="93"></a>
<a class="sourceLine" id="cb49-94" title="94">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb49-95" title="95">}</a></code></pre></div><p><code>getaddrinfo()</code>에서 우리가 마침내 <code>SOCK_DGRAM</code>을 사용한다는 것에 주목하라. 또한, <code>listen()</code>와 <code>accept()</code>이 필요하지 않다는 점도 기억하라. 이것이 연결 없는 데이터그램 소켓을 사용할 때의 장점 중 하나이다. Notice that in our call to <code>getaddrinfo()</code> we’re finally using <code>SOCK_DGRAM</code>. Also, note that there’s no need to <code>listen()</code> or <code>accept()</code>. This is one of the perks of using unconnected datagram sockets!</p><p></p><p></p><p>Next comes the <a href="https://beej.us/guide/bgnet/examples/talker.c">source for <code>talker.c</code></a><a href="more-references.html#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a>:</p><div class="sourceCode" id="cb50"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb50-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb50-2" title="2"><span class="co">** talker.c -- a datagram &quot;client&quot; demo</span></a>
<a class="sourceLine" id="cb50-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb50-4" title="4"></a>
<a class="sourceLine" id="cb50-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb50-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb50-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb50-8" title="8"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb50-9" title="9"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb50-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb50-11" title="11"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb50-12" title="12"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb50-13" title="13"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb50-14" title="14"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb50-15" title="15"></a>
<a class="sourceLine" id="cb50-16" title="16"><span class="pp">#define SERVERPORT &quot;4950&quot;    </span><span class="co">// the port users will be connecting to</span></a>
<a class="sourceLine" id="cb50-17" title="17"></a>
<a class="sourceLine" id="cb50-18" title="18"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb50-19" title="19">{</a>
<a class="sourceLine" id="cb50-20" title="20">    <span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb50-21" title="21">    <span class="kw">struct</span> addrinfo hints, *servinfo, *p;</a>
<a class="sourceLine" id="cb50-22" title="22">    <span class="dt">int</span> rv;</a>
<a class="sourceLine" id="cb50-23" title="23">    <span class="dt">int</span> numbytes;</a>
<a class="sourceLine" id="cb50-24" title="24"></a>
<a class="sourceLine" id="cb50-25" title="25">    <span class="cf">if</span> (argc != <span class="dv">3</span>) {</a>
<a class="sourceLine" id="cb50-26" title="26">        fprintf(stderr,<span class="st">&quot;usage: talker hostname message</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb50-27" title="27">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb50-28" title="28">    }</a>
<a class="sourceLine" id="cb50-29" title="29"></a>
<a class="sourceLine" id="cb50-30" title="30">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb50-31" title="31">    hints.ai_family = AF_INET6; <span class="co">// set to AF_INET to use IPv4</span></a>
<a class="sourceLine" id="cb50-32" title="32">    hints.ai_socktype = SOCK_DGRAM;</a>
<a class="sourceLine" id="cb50-33" title="33"></a>
<a class="sourceLine" id="cb50-34" title="34">    <span class="cf">if</span> ((rv = getaddrinfo(argv[<span class="dv">1</span>], SERVERPORT, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb50-35" title="35">        fprintf(stderr, <span class="st">&quot;getaddrinfo: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(rv));</a>
<a class="sourceLine" id="cb50-36" title="36">        <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb50-37" title="37">    }</a>
<a class="sourceLine" id="cb50-38" title="38"></a>
<a class="sourceLine" id="cb50-39" title="39">    <span class="co">// loop through all the results and make a socket</span></a>
<a class="sourceLine" id="cb50-40" title="40">    <span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb50-41" title="41">        <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</a>
<a class="sourceLine" id="cb50-42" title="42">                p-&gt;ai_protocol)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb50-43" title="43">            perror(<span class="st">&quot;talker: socket&quot;</span>);</a>
<a class="sourceLine" id="cb50-44" title="44">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb50-45" title="45">        }</a>
<a class="sourceLine" id="cb50-46" title="46"></a>
<a class="sourceLine" id="cb50-47" title="47">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb50-48" title="48">    }</a>
<a class="sourceLine" id="cb50-49" title="49"></a>
<a class="sourceLine" id="cb50-50" title="50">    <span class="cf">if</span> (p == NULL) {</a>
<a class="sourceLine" id="cb50-51" title="51">        fprintf(stderr, <span class="st">&quot;talker: failed to create socket</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb50-52" title="52">        <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb50-53" title="53">    }</a>
<a class="sourceLine" id="cb50-54" title="54"></a>
<a class="sourceLine" id="cb50-55" title="55">    <span class="cf">if</span> ((numbytes = sendto(sockfd, argv[<span class="dv">2</span>], strlen(argv[<span class="dv">2</span>]), <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb50-56" title="56">             p-&gt;ai_addr, p-&gt;ai_addrlen)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb50-57" title="57">        perror(<span class="st">&quot;talker: sendto&quot;</span>);</a>
<a class="sourceLine" id="cb50-58" title="58">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb50-59" title="59">    }</a>
<a class="sourceLine" id="cb50-60" title="60"></a>
<a class="sourceLine" id="cb50-61" title="61">    freeaddrinfo(servinfo);</a>
<a class="sourceLine" id="cb50-62" title="62"></a>
<a class="sourceLine" id="cb50-63" title="63">    printf(<span class="st">&quot;talker: sent %d bytes to %s</span><span class="sc">\n</span><span class="st">&quot;</span>, numbytes, argv[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb50-64" title="64">    close(sockfd);</a>
<a class="sourceLine" id="cb50-65" title="65"></a>
<a class="sourceLine" id="cb50-66" title="66">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb50-67" title="67">}</a></code></pre></div><p>이것이 전부다! 하나의 장치에서 <code>listener</code>를 실행하고 <code>talker</code>를 다른 장치에서 실행하라.(역자 주 : 하나의 장치에서도 순서만 맞게 실행하면 문제는 없다. 여러 터미널을 동시에 열 수 있는 다양한 방법이 있다.) 그것들이 통신하는 것을 지켜보라. 핵가족 전체를 위한 전연령 엔터테인먼트다.</p><p>이번에는 서버르 실행할 필요도 없다! <code>talker</code>를 혼자 실행시키면 패킷을 행복하게 발송하고, 아무도 반대쪽에서 <code>recvfrom()</code>을 호출하지 않는다면 그저 패킷은 사라질 뿐이다. 기억하라 : UDP 데이터그램 소켓으로 보낸 데이터는 도착을 보장하지 않는다.!</p><p></p><p>전에 몇 번 말한 사소한 것 한 가지를 빼면 전부다:  연결된 데이터그램 소켓이 그것이다. 그것에 대해서 여기에서 말해야하는데, 이 문서의 데이터그램에 대한 부분이 바로 여기이기 때문이다. 위의 <code>talker</code> 가 <code>listener</code>의 주소를 지정하고 <code>connect()</code>를 호출한다고 하자. 그 순간부터 <code>talker</code>는 <code>connect()</code>로 지정한 주소로만 데이터를 보내고 받을 수 있다. 이런 이유로 <code>sendto()</code>와 <code>recvfrom()</code>을 쓸 필요가 없다. 단순히 <code>send()</code> 와 <code>recv()</code>를 쓰면 된다.</p><p></p><hr><div style="text-align:center"><span><a href="시스템-콜이-아니면-죽음을.html">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="약간-더-고급스러운-기술.html">Next</a></span></div></body>
</html>
