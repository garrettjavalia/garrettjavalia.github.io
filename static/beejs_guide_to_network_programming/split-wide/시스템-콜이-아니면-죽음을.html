<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Beej의 네트워크 프로그래밍 안내서</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono&display=swap" rel="stylesheet"> 
  <link rel="stylesheet" as="style" crossorigin="None" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.6/dist/web/static/pretendard.css" />
  <!-- BG custom styling -->
  <style type="text/css">
  /* Fix for line numbers not visible */
  pre.numberSource code > span {
      left: -1em;
  }
  pre.numberSource {
      margin-left: initial;
  }
  
  /* Put some space after the section numbers */
  span.toc-section-number::after {
      content: "\a0\a0\a0";  /* non-breaking whitespace */
  }
  
  /* Hide underlines on code number links */
  pre > code.sourceCode > span > a:first-child::before {
      text-decoration: none;
  }
  
  /* Color the source blocks */
  div.sourceCode {
      background-color: #f0f0f0;
  }
  
  /* Fix iOS big text rendering issue */
  pre > code.sourceCode > span {
      display: initial;
  }
  
  
  /* Color the inline code */
  code:not(.sourceCode) {
      background: #f0f0f0;
      padding-left: 0.2em;
      padding-right: 0.2em;
      border-radius: 0.2em;
  }
  
  /* Keep code tags from wrapping in tables */
  tbody code {
      white-space: nowrap;
  }
  
  td {
      vertical-align: top;
  }
  
  body {
      font-size: 12pt;
      box-sizing: border-box;
      margin: 0;
      padding: 1em;
      max-width: min(43em, 100vw);
  }
  
  html {
      display: flex;
      justify-content: center;
      font-family: -apple-system, BlinkMacSystemFont, "Apple SD Gothic Neo", "Pretendard Variable", Pretendard, Roboto, "Noto Sans KR", "Segoe UI", "Malgun Gothic", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
  }
  
  figure {
      text-align: center;
  }
  </style>
  <!-- BG custom styling for the wide body variant -->
  <!-- Gets appended after bg-css.html -->
  
  <style type="text/css">
  body {
      max-width: 100vw;
  }
  </style>
</head>
<body>
<div style="text-align:center"><span><a href="ipv4에서-ipv6으로-점프하기.html">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="client-server-background.html">Next</a></span></div><hr>
<h1 id="시스템-콜이-아니면-죽음을"><span class="header-section-number">5</span> 시스템 콜이 아니면 죽음을</h1><p>이 절에서 우리는 유닉스 장치나 기타 소켓 API를 지원하는 다른 장치(BSD, 윈도우즈, 리눅스, 맥, 여러분이 가진 다른 장치)에서 네트워크 기능에 접근할 수 있게 해 주는 시스템 호출(System call)(과 다른 라이브러리 호출 (Library Call))에 대해서 다룰 것입니다. 이런 함수 중 하나를 호출하면 커널이 넘겨받고 여러분을 위해 모든 일을 자동으로 마법같이 처리합니다.</p><p>대부분의 사람들이 어려워하는 점은 이 함수들을 어떤 순서로 호출해야 하는가 입니다. 이미 찾아보셨겠지만 그런 쪽으로는 <code>man</code>페이지는 아무 쓸모도 없습니다. 그 끔찍한 상황을 해결하기 위해 시스템콜들을 <em>정확히</em>(대략) 여러분의 프로그램에서 호출해야 하는 순서 그대로 아래에 이어지는 절들에 제시했습니다.</p><p>그러니까 여기에 있는 몇몇 예제 코드와 우유, 과자(이것들은 직접 준비하셔야 합니다) 그리고 두둑한 배짱과 용기만 있다면 여러분은 인터넷의 세계에서 존 포스텔의 아들처럼 데이터를 나를 수 있게 될 것입니다.(역자 주 : John Postel은 인터넷의 초기에 큰 기여를 한 컴퓨터 과학자 중 한 명입니다.)</p><p><em>(아래의 예제 코드들은 대개 필수적인 에러코드를 간략함을 얻기 위해서 생략했음을 기억하십시오. 그리고 예제 코드들은 대개 <code>getaddrinfo()</code>의 호출이 성공하고 연결리스트로 적절한 결과물을 돌려준다고 가정합니다. 이런 상황은 독립 실행형 프로그램에서는 제대로 처리되어 있으니, 그것들을 지침으로 삼으십시오.)</em></p><h2 id="getaddrinfo발사-준비"><span class="header-section-number">5.1</span> <code>getaddrinfo()</code>—발사 준비!</h2><p>, 이것은 여러 옵션을 가진 진짜 일꾼입니다. 그러나 사용법은 사실 꽤 간단합니다. 이것은 여러분이 나중에 필요로 하는 <code>struct</code>들을 초기화합니다.</p><p>역사 한토막 : 예전에는 DNS 검색을 위해서 <code>gethostbyname()</code>을 호출해야 했습니다. 그리고 그 정보를 수작업으로 <code>struct sockaddr_in</code>에 담고 이후의 호출에서 사용해야 했습니다.</p><p>고맙게도 더 이상은 그럴 필요가 없습니다. (여러분이 IPv4와 IPv6환경 모두에서 동작하는 코드를 짜고싶다면 그래서도 안 됩니다!) 요새는 <code>getaddrinfo()</code>이라는 것이 있어서 DNS 와 서비스 이름 검색, <code>struct</code>내용 채워넣기 등을 포함해서 여러분이 필요로 하는 모든 일을 해 줍니다.</p><p>이제 살펴봅시다!</p><p>(역자 주 : 아래에서부터 입니다, 하세요 등의 표현 대신 이다, 하라 등의 간결한 어미를 섞어서 씁니다.)</p><div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="dt">int</span> getaddrinfo(<span class="dt">const</span> <span class="dt">char</span> *node,     <span class="co">// e.g. &quot;www.example.com&quot; 또ㅡㄴ IP</span></a>
<a class="sourceLine" id="cb20-6" title="6">                <span class="dt">const</span> <span class="dt">char</span> *service,  <span class="co">// e.g. &quot;http&quot; 또는 포트 숫자를 &quot;&quot;안에 감싸서 넣는다.</span></a>
<a class="sourceLine" id="cb20-7" title="7">                <span class="dt">const</span> <span class="kw">struct</span> addrinfo *hints,</a>
<a class="sourceLine" id="cb20-8" title="8">                <span class="kw">struct</span> addrinfo **res);</a></code></pre></div><p>이 함수에는 3개의 입력 매개변수를 넘겨줍니다. 그리고 결과 연결리스트의 포인터인 <code>res</code>를 돌려받습니다.</p><p><code>node</code>매개변수는 접속하려는 호스트 이름이나 IP주소입니다.</p><p>다음 매개변수는 <code>service</code>입니다. 이것은 “80”같은 포트 번호나 “http”, “ftp”, “telnet” 또는 “smtp”같은 특정한 서비스 이름이 될 수 있습니다. (<a href="https://www.iana.org/assignments/port-numbers">IANA 포트 목록</a><a href="more-references.html#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a> 혹은 여러분이 유닉스 장치를 쓴다면 <code>/etc/services</code>에서 볼 수 있습니다)</p><p>마지막으로 <code>hints</code>매개변수는 여러분이 관련된 정보로 이미 채워넣은 <code>struct addrinfo</code> 를 가리킵니다.</p><p>여기에 여러분이 호스트 IP주소의 포트 3490을 듣고자 할 때의 함수 호출 예제가 있습니다. 이것이 듣기 작업이나 네트워크 설정을 하지는 않음을 기억하십시오. 이것은 단지 나중에 사용할 구조체들을 설정할 뿐입니다.</p><div class="sourceCode" id="cb21"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="dt">int</span> status;</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="kw">struct</span> addrinfo hints;</a>
<a class="sourceLine" id="cb21-3" title="3"><span class="kw">struct</span> addrinfo *servinfo;  <span class="co">// 결과를 가리킬 것이다</span></a>
<a class="sourceLine" id="cb21-4" title="4"></a>
<a class="sourceLine" id="cb21-5" title="5">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints); <span class="co">// 구조체를 확실히 비워두라</span></a>
<a class="sourceLine" id="cb21-6" title="6">hints.ai_family = AF_UNSPEC;     <span class="co">// IPv4 이든 IPv6 이든 상관없다</span></a>
<a class="sourceLine" id="cb21-7" title="7">hints.ai_socktype = SOCK_STREAM; <span class="co">// TCP 스트림 소켓</span></a>
<a class="sourceLine" id="cb21-8" title="8">hints.ai_flags = AI_PASSIVE;     <span class="co">// 내 주소를 넣어달라</span></a>
<a class="sourceLine" id="cb21-9" title="9"></a>
<a class="sourceLine" id="cb21-10" title="10"><span class="cf">if</span> ((status = getaddrinfo(NULL, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb21-11" title="11">    fprintf(stderr, <span class="st">&quot;getaddrinfo error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(status));</a>
<a class="sourceLine" id="cb21-12" title="12">    exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb21-13" title="13">}</a>
<a class="sourceLine" id="cb21-14" title="14"></a>
<a class="sourceLine" id="cb21-15" title="15"><span class="co">// servinfo는 이제 1개 혹은 그 이상의 addrinfo 구조체에 대한 연결리스트를 가리킨다</span></a>
<a class="sourceLine" id="cb21-16" title="16"></a>
<a class="sourceLine" id="cb21-17" title="17"><span class="co">// ... servinfo가 더이상 필요없을 때까지 모든 작업을 한다...</span></a>
<a class="sourceLine" id="cb21-18" title="18"></a>
<a class="sourceLine" id="cb21-19" title="19">freeaddrinfo(servinfo); <span class="co">// 연결리스트를 해제</span></a></code></pre></div><p><code>ai_family</code>을 <code>AF_UNSPEC</code>으로 설정해서 IPv4든 IPv6이든 신경쓰지 않음을 나타낸 것에 주목하라. 만약 특정한 하나를 원한다면 <code>AF_INET</code>이나 <code>AF_INET6</code>을 쓸 수 있다.</p><p><code>AI_PASSIVE</code>도 볼 수 있다. 이것은 <code>getaddrinfo()</code>에게 소켓 구조체에 내 로컬 호스트의 주소를 할당해달라고 말해준다. 이것은 여러분이 하드코딩할 필요를 없애주기에 좋다. (아니면 위에서 <code>NULL</code>을 넣은 <code>getaddrinfo()</code>의 첫 번째 매개변수에 특정한 주소를 넣을 수 있다. )</p><p>이렇게 함수를 호출한다. 오류가 있다면(<code>getaddrinfo()</code>이 0이 아닌 값을 돌려준다면) 보다시피 그 오류를 <code>gai_strerror()</code>함수를 통해서 출력할 수 있다. 만약 모든 것이 제대로 동작한다면 <code>servinfo</code>는 각각이 우리가 나중에 쓸 수 있는 <code>struct sockaddr</code>나 비슷한 것을 가진 <code>struct addrinfo</code>의 연결리스트를 가리킬 것이다. 멋지다!</p><p>마지막으로 <code>getaddrinfo()</code>가 은혜롭게 우리에게 할당해 준 연결리스트를 다 썼다면 우리는 <code>freeaddrinfo()</code>을 호출해서 그것을 할당 해제할 수 있습니다. (반드시 해야합니다.)</p><p>여기에 여러분이 특정한 주소, 예를 들어 “www.example.net”의 3490포트에 잡속하고자 하는 클라이언트일 경우의 호출 예제가 있습니다. 다시 말씀드리지만 이것으로는 실제 연결이 이루어지지 않습니다. 그러나 이것은 우리가 나중에 사용할 구조체를 설정해줍니다.</p><div class="sourceCode" id="cb22"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="dt">int</span> status;</a>
<a class="sourceLine" id="cb22-2" title="2"><span class="kw">struct</span> addrinfo hints;</a>
<a class="sourceLine" id="cb22-3" title="3"><span class="kw">struct</span> addrinfo *servinfo;  <span class="co">// 결과물을 가리킬 것임</span></a>
<a class="sourceLine" id="cb22-4" title="4"></a>
<a class="sourceLine" id="cb22-5" title="5">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints); <span class="co">// 반드시 비워둘 것</span></a>
<a class="sourceLine" id="cb22-6" title="6">hints.ai_family = AF_UNSPEC;     <span class="co">// IPv4나 IPv6은 신경쓰지 않음</span></a>
<a class="sourceLine" id="cb22-7" title="7">hints.ai_socktype = SOCK_STREAM; <span class="co">// TCP 스트림 소켓</span></a>
<a class="sourceLine" id="cb22-8" title="8"></a>
<a class="sourceLine" id="cb22-9" title="9"><span class="co">// 연결 준비</span></a>
<a class="sourceLine" id="cb22-10" title="10">status = getaddrinfo(<span class="st">&quot;www.example.net&quot;</span>, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;servinfo);</a>
<a class="sourceLine" id="cb22-11" title="11"></a>
<a class="sourceLine" id="cb22-12" title="12"><span class="co">// servinfo는 이제 1개 혹은 그 이상의 addrinfo 구조체에 대한 연결리스트를 가리킨다</span></a>
<a class="sourceLine" id="cb22-13" title="13"></a>
<a class="sourceLine" id="cb22-14" title="14"><span class="co">// 등등.</span></a></code></pre></div><p><code>servinfo</code>은 모든 종류의 주소 정보를 가진 연결리스트라고 계속 이야기하고 있다. 이 정보를 보기 위한 짧은 시연 프로그램을 작성해보자. <a href="https://beej.us/guide/bgnet/examples/showip.c">이 짧은 프로그램</a><a href="more-references.html#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a> 은 여러분이 명령줄에 적는 호스트의 IP주소들을 출력한다.</p><div class="sourceCode" id="cb23"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="co">** showip.c -- 명령줄에서 주어진 호스트의 주소들을 출력한다.</span></a>
<a class="sourceLine" id="cb23-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb23-4" title="4"></a>
<a class="sourceLine" id="cb23-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb23-6" title="6"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb23-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb23-8" title="8"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb23-9" title="9"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb23-10" title="10"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb23-11" title="11"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb23-12" title="12"></a>
<a class="sourceLine" id="cb23-13" title="13"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb23-14" title="14">{</a>
<a class="sourceLine" id="cb23-15" title="15">    <span class="kw">struct</span> addrinfo hints, *res, *p;</a>
<a class="sourceLine" id="cb23-16" title="16">    <span class="dt">int</span> status;</a>
<a class="sourceLine" id="cb23-17" title="17">    <span class="dt">char</span> ipstr[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb23-18" title="18"></a>
<a class="sourceLine" id="cb23-19" title="19">    <span class="cf">if</span> (argc != <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb23-20" title="20">        fprintf(stderr,<span class="st">&quot;usage: showip hostname</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb23-21" title="21">        <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb23-22" title="22">    }</a>
<a class="sourceLine" id="cb23-23" title="23"></a>
<a class="sourceLine" id="cb23-24" title="24">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb23-25" title="25">    hints.ai_family = AF_UNSPEC; <span class="co">// 버전을 지정하려면 AF_INET또는 AF_INET6을 사용</span></a>
<a class="sourceLine" id="cb23-26" title="26">    hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb23-27" title="27"></a>
<a class="sourceLine" id="cb23-28" title="28">    <span class="cf">if</span> ((status = getaddrinfo(argv[<span class="dv">1</span>], NULL, &amp;hints, &amp;res)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb23-29" title="29">        fprintf(stderr, <span class="st">&quot;getaddrinfo: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(status));</a>
<a class="sourceLine" id="cb23-30" title="30">        <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb23-31" title="31">    }</a>
<a class="sourceLine" id="cb23-32" title="32"></a>
<a class="sourceLine" id="cb23-33" title="33">    printf(<span class="st">&quot;IP addresses for %s:</span><span class="sc">\n\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb23-34" title="34"></a>
<a class="sourceLine" id="cb23-35" title="35">    <span class="cf">for</span>(p = res;p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb23-36" title="36">        <span class="dt">void</span> *addr;</a>
<a class="sourceLine" id="cb23-37" title="37">        <span class="dt">char</span> *ipver;</a>
<a class="sourceLine" id="cb23-38" title="38"></a>
<a class="sourceLine" id="cb23-39" title="39">        <span class="co">// 주소 자체에 대한 포인터를 받는다. IPv4와 IPv6은 필드가 다르다.</span></a>
<a class="sourceLine" id="cb23-40" title="40">        <span class="cf">if</span> (p-&gt;ai_family == AF_INET) { <span class="co">// IPv4</span></a>
<a class="sourceLine" id="cb23-41" title="41">            <span class="kw">struct</span> sockaddr_in *ipv4 = (<span class="kw">struct</span> sockaddr_in *)p-&gt;ai_addr;</a>
<a class="sourceLine" id="cb23-42" title="42">            addr = &amp;(ipv4-&gt;sin_addr);</a>
<a class="sourceLine" id="cb23-43" title="43">            ipver = <span class="st">&quot;IPv4&quot;</span>;</a>
<a class="sourceLine" id="cb23-44" title="44">        } <span class="cf">else</span> { <span class="co">// IPv6</span></a>
<a class="sourceLine" id="cb23-45" title="45">            <span class="kw">struct</span> sockaddr_in6 *ipv6 = (<span class="kw">struct</span> sockaddr_in6 *)p-&gt;ai_addr;</a>
<a class="sourceLine" id="cb23-46" title="46">            addr = &amp;(ipv6-&gt;sin6_addr);</a>
<a class="sourceLine" id="cb23-47" title="47">            ipver = <span class="st">&quot;IPv6&quot;</span>;</a>
<a class="sourceLine" id="cb23-48" title="48">        }</a>
<a class="sourceLine" id="cb23-49" title="49"></a>
<a class="sourceLine" id="cb23-50" title="50">        <span class="co">// IP주소를 문자열로 변환하고 출력한다.</span></a>
<a class="sourceLine" id="cb23-51" title="51">        inet_ntop(p-&gt;ai_family, addr, ipstr, <span class="kw">sizeof</span> ipstr);</a>
<a class="sourceLine" id="cb23-52" title="52">        printf(<span class="st">&quot;  %s: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, ipver, ipstr);</a>
<a class="sourceLine" id="cb23-53" title="53">    }</a>
<a class="sourceLine" id="cb23-54" title="54"></a>
<a class="sourceLine" id="cb23-55" title="55">    freeaddrinfo(res); <span class="co">// 연결 목록을 해제한다.</span></a>
<a class="sourceLine" id="cb23-56" title="56"></a>
<a class="sourceLine" id="cb23-57" title="57">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb23-58" title="58">}</a></code></pre></div><p>보다시피 이 코드는 당신이 명령줄에 넘기는 것이 무엇이든 <code>getaddrinfo()</code>을 호출한다. 그리고 <code>res</code>에 연결목록의 포인터를 넘겨준다. 그래서 우리는 이 목록을 순회해서 출력하거나 다른 일을 할 수 있다.</p><p>(저 예제코드에는 IP 버전에 따라 다른 종류의 <code>struct sockaddr</code>을 처리해야 하는 흉한 부분이 있다. 그 점에 대해서 사과한다. 그러나 더 나은 방법이 있는지는 모르겠다.)</p><p>실행 예제! 모두가 스크린샷을 좋아합니다.</p><pre><code>$ showip www.example.net
IP addresses for www.example.net:

  IPv4: 192.0.2.88

$ showip ipv6.example.com
IP addresses for ipv6.example.com:

  IPv4: 192.0.2.101
  IPv6: 2001:db8:8c00:22::171</code></pre><p>이제 저것을 다룰 수 있으니, <code>getaddrinfo()</code>에서 얻은 결과를 다른 소켓 함수에 넘기고 결과적으로는 네트워크 연결을 성립할 수 있도록 해 보자! 계속 읽어보라!</p><h2 id="socket"><span class="header-section-number">5.2</span> <code>socket()</code>—파일 설명자를 받아오라!</h2><p>더 이상 미룰 수가 없을 듯 하다. 이제  <code>socket()</code> 시스템 콜에 대해서 이야기해야 한다. 개요는 이렇다.</p><div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb25-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb25-3" title="3"></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="dt">int</span> socket(<span class="dt">int</span> domain, <span class="dt">int</span> type, <span class="dt">int</span> protocol); </a></code></pre></div><p>그러나 이 인수들이 무엇인지 모를 것이다. 이것들은 어떤 종류의 소켓을 원하는지 정할 수 있게 해 준다.(IPv4 또는 IPv6, 스트림 혹은 데이터그램, TCP 혹은 UDP)</p><p>사용자들이 그 값을 직접 적어야 했고, 지금도 그렇게 할 수 있다. (<code>domain</code>은 <code>PF_INET</code>이나 <code>PF_INET6</code>이고, <code>type</code>은 <code>SOCK_STREAM</code>또는 <code>SOCK_DGRAM</code> 이며, <code>protocol</code>은 주어진 <code>type</code>에 적절한 값을 자동으로 선택하게 하려면 <code>0</code>을 넘겨주거나 “tcp”나 “udp” 중 원하는 프로토콜의 값을 얻기 위해서 <code>getprotobyname()</code> 을 쓸 수도 있다.)</p><p>(이 <code>PF_INET</code>은 <code>sin_family</code>필드에 넣어주는 <code>AF_INET</code>와 유사한 것이다. 이것을 이해하려면 짧은 이야기가 필요하다. 아주 먼 옛날에는 어쩌면 하나의 주소 체통(Address Family) (“<code>AF_INET</code>”안에 들어있는 “AF”)가 여러 종류의 프로토콜 계통(Protocol Family)(“<code>PF_INET</code>”의 “PF”))을 지원할 것이라고 생각하던 시절이 있었다. 그런 일은 일어나지 않았다. 그리고 모두 행복하게 오래오래 잘 살았다. 이런 이야기다. 그래서 할 수 있는 가장 정확한 일은 <code>struct sockaddr_in</code>에서 <code>AF_INET</code>을 쓰고 <code>socket()</code>에서 <code>PF_INET</code>을 사용하는 것이다.</p><p>아무튼 이제 충분하다. 여러분이 정말로 하고싶은 일은 <code>getaddrinfo()</code>을 호출한 결과로 돌아오는 값을 아래와 같이 <code>socket()</code>에 직접 넘겨주는 것이다.</p><div class="sourceCode" id="cb26"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1"><span class="dt">int</span> s;</a>
<a class="sourceLine" id="cb26-2" title="2"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb26-3" title="3"></a>
<a class="sourceLine" id="cb26-4" title="4"><span class="co">// 탐색 시작</span></a>
<a class="sourceLine" id="cb26-5" title="5"><span class="co">// [&quot;hints&quot;구조체는 이미 채운 것으로 친다]</span></a>
<a class="sourceLine" id="cb26-6" title="6">getaddrinfo(<span class="st">&quot;www.example.com&quot;</span>, <span class="st">&quot;http&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb26-7" title="7"></a>
<a class="sourceLine" id="cb26-8" title="8"><span class="co">// 다시 말하지면 원래는 (이 안내서의 예제들이 하듯이) 첫 번째 것이 좋다고</span></a>
<a class="sourceLine" id="cb26-9" title="9"><span class="co">// 가정하는 대신 getaddrinfo()에 대해서 오류 확인을 하고</span></a>
<a class="sourceLine" id="cb26-10" title="10"><span class="co">// &quot;res&quot;링크드 리스트를 순회해야 한다.</span></a>
<a class="sourceLine" id="cb26-11" title="11"><span class="co">// client/server절의 진짜 예제들을 참고하라.</span></a>
<a class="sourceLine" id="cb26-12" title="12"></a>
<a class="sourceLine" id="cb26-13" title="13">s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a></code></pre></div><p><code>socket()</code>은 단순하게 이후의 시스템 호출에서 쓸 수 있는 <em>소켓 설명자</em> 를 돌려준다. 오류가 있으면 -1을 돌려준다. 전역 변수인 <code>errno</code>가 오류의 값으로 설정된다. (자세한 정보는 <a href="man-pages.html#errnoman"><code>errno</code></a> 의 맨페이지를 참고하라.)</p><p>좋다. 그러면 이제 이 소켓을 어디에 쓰는가? 정답은 아직 못 쓴다는 것이다. 실제로 쓰기 위해서는 안내서를 더 읽고 이것이 동작하게 하기 위한 시스템 호출을 더 해야 한다.</p><h2 id="bind"><span class="header-section-number">5.3</span> <code>bind()</code>—나는 어떤 포트에 있는가?</h2><p> 소켓을 가지면 여러분의 기계의  포트에 연동하고 싶을 것이다. (이 작업은 보통 여러분이  <code>listen()</code> 으로 특정 포트에서 들어오는 연결을 듣고자(listen) 할 때 이루어진다. —다중 사용자 네트워크 게임들은 “192.168.5.10의 3490포트에 연결합니다”라고 말할 때 이런 작업을 한다.) 포트 번호는 커널이 특정 프로세스의 소켓 설명자를 들어오는 패킷과 연관짓기 위해서 사용한다. 만약 여러분이  <code>connect()</code>만 할 생각이라면 <code>bind()</code>는 불필요하다. 그러나 재미를 위해 읽어두자.</p><p>이것이 <code>bind()</code> 시스템 콜의 개요다.</p><div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb27-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb27-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb27-3" title="3"></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="dt">int</span> bind(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *my_addr, <span class="dt">int</span> addrlen);</a></code></pre></div><p><code>sockfd</code>은 <code>socket()</code>이 돌려준 소켓 파일 설명자이다. <code>my_addr</code>은 여러분의 주소, 말하자면 포트와  IP주소를 가진 <code>struct sockaddr</code> 에 대한 포인터이다. <code>addrlen</code>은 그 주소의 바이트 단위 길이이다.</p><p>으엑. 한 번에 많이 배웠다. 프로그램이 실행되는 호스트의 3490번 포트에 소켓을 바인드하는 예제를 보자.</p><div class="sourceCode" id="cb28"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb28-2" title="2"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb28-3" title="3"></a>
<a class="sourceLine" id="cb28-4" title="4"><span class="co">// 먼저 getaddrinfo()으로 구조체에 정보를 불러온다.</span></a>
<a class="sourceLine" id="cb28-5" title="5"></a>
<a class="sourceLine" id="cb28-6" title="6">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb28-7" title="7">hints.ai_family = AF_UNSPEC;  <span class="co">// IPv4나 IPv6 중 아무 것이나 쓴다</span></a>
<a class="sourceLine" id="cb28-8" title="8">hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb28-9" title="9">hints.ai_flags = AI_PASSIVE;     <span class="co">// IP는 나의 아이피로 채운다.</span></a>
<a class="sourceLine" id="cb28-10" title="10"></a>
<a class="sourceLine" id="cb28-11" title="11">getaddrinfo(NULL, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb28-12" title="12"></a>
<a class="sourceLine" id="cb28-13" title="13"><span class="co">// 소켓을 만든다.</span></a>
<a class="sourceLine" id="cb28-14" title="14"></a>
<a class="sourceLine" id="cb28-15" title="15">sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb28-16" title="16"></a>
<a class="sourceLine" id="cb28-17" title="17"><span class="co">// getaddrinfo()에 넘겼던 포트에 바인드한다.</span></a>
<a class="sourceLine" id="cb28-18" title="18"></a>
<a class="sourceLine" id="cb28-19" title="19">bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a></code></pre></div><p><code>AI_PASSIVE</code>플래그를 써서 프로그램에게 실행중인 호스트의 IP에 바인드하라고 알려줍니다. 특정한 로컬 IP주소에 바인드하고싶다면 <code>AI_PASSIVE</code>을 버리고 <code>getaddrinfo()</code>의 첫 번째 인수로 IP주소를 넣으라.</p><p><code>bind()</code>도 오류가 발생하면 <code>-1</code>을 돌려주고 <code>errno</code>을 오류의 값으로 설정한다.</p><p>많은 오래된 코드들이 <code>bind()</code>을 호출하기 전에 <code>struct sockaddr_in</code>을 직접 채워넣는다. 이것은 분명히 IPv4 전용이지만 같은 일을 IPv6에 대해서도 못 할 이유는 없다. 단지 <code>getaddrinfo()</code>을 쓰는 편이 일반적으로 더 쉽다. 어쨌든 예전 코드는 이런 방식이다.</p><div class="sourceCode" id="cb29"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1"><span class="co">// !!! 이것은 예전 방식이다 !!!</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb29-4" title="4"><span class="kw">struct</span> sockaddr_in my_addr;</a>
<a class="sourceLine" id="cb29-5" title="5"></a>
<a class="sourceLine" id="cb29-6" title="6">sockfd = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb29-7" title="7"></a>
<a class="sourceLine" id="cb29-8" title="8">my_addr.sin_family = AF_INET;</a>
<a class="sourceLine" id="cb29-9" title="9">my_addr.sin_port = htons(MYPORT);     <span class="co">// short, 네트워크 바이트 순서</span></a>
<a class="sourceLine" id="cb29-10" title="10">my_addr.sin_addr.s_addr = inet_addr(<span class="st">&quot;10.12.110.57&quot;</span>);</a>
<a class="sourceLine" id="cb29-11" title="11">memset(my_addr.sin_zero, &#39;\<span class="dv">0</span>&#39;, <span class="kw">sizeof</span> my_addr.sin_zero);</a>
<a class="sourceLine" id="cb29-12" title="12"></a>
<a class="sourceLine" id="cb29-13" title="13">bind(sockfd, (<span class="kw">struct</span> sockaddr *)&amp;my_addr, <span class="kw">sizeof</span> my_addr);</a></code></pre></div><p>위의 코드에서 당신의 로컬 IP 주소에 바인드하고 싶었다면(위의 <code>AI_PASSIVE</code>처럼) <code>s_addr</code>필드에 <code>INADDR_ANY</code>을 대입할 수 있다. IPv6버전의 <code>INADDR_ANY</code>은 당신의 <code>struct sockaddr_in6</code>의 <code>sin6_addr</code>필드에 대입해야 하는 전역변수인 <code>in6addr_any</code>이다. (변수 초기화식에 쓸 수 있는 <code>IN6ADDR_ANY_INIT</code>이라는 매크로도 있다.)</p><p><code>bind()</code>을 쓸 때 주의해야 할 것 : 포트 번호는 낮은 것을 쓰지 말 것.  1024번 아래의 모든 포트는 예약되어 있다(슈퍼유저가 아닌 이상)! 그 위의 포트 번호는 (다른 프로그램이 이미 쓰고 있지 않다면) 65535까지 아무 것이나 쓸 수 있다.</p><p>눈치챌 수 있듯이 때때로 서버를 다시 실행하려고 하면 <code>bind()</code>가 실패하고  “주소가 이미 사용중입니다..”라고 할 때가 있다. 그것은 연결되었던 소켓 중 일부가 여전히 커널에서 대기중이고 포트를 사용하고 있다는 것을 의미한다. 여러분은 그것이 정리될 때까지 1분 정도를 기다리거나 당신의 프로그램이 포트를 재사용할 수 있도록 하는 코드를 넣을 수도 있다.</p><p> </p><div class="sourceCode" id="cb30"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="dt">int</span> yes=<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb30-2" title="2"><span class="co">//char yes=&#39;1&#39;; // 솔라리스는 이것을 사용</span></a>
<a class="sourceLine" id="cb30-3" title="3"></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="co">// &quot;주소가 이미 사용중입니다&quot;라는 오류 메시지를 제거</span></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="cf">if</span> (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&amp;yes,<span class="kw">sizeof</span> yes) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb30-6" title="6">    perror(<span class="st">&quot;setsockopt&quot;</span>);</a>
<a class="sourceLine" id="cb30-7" title="7">    exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb30-8" title="8">} </a></code></pre></div><p> <code>bind()</code>에 대해서 한마디 더: 이 함수를 호출할 필요가 전혀 없는 경우도 있습니다.  <code>connect()</code>를 호출해서 원격 장치에 연결하려고 하고, 로컬 포트에 대해서는 신경쓰지 않는다면(<code>telnet</code>의 경우 처럼 원격지 포트만 신경쓰는 경우) <code>connect()</code>가 자동으로 소켓이 바인드되지 않았는지 확인하고 필요하다면 사용하지 않은 로컬 포트에 <code>bind()</code>해줄 것입니다.</p><h2 id="connect"><span class="header-section-number">5.4</span> <code>connect()</code>—이봐, 안녕!</h2><p> 몇 분만 여러분이 텔넷 응용프로그램이 되었다고 생각해봅시다. 여러분의 사용자들이 소켓 파일 설명자를 얻기 위해서 여러분에게 명령을 내립니다 (영화  <em>트론</em> 에서처럼요). 여러분은 그에 따라 <code>socket()</code>을 호출합니다. 다음으로 사용자가 여러분에게 “<code>10.12.110.57</code>”의 “<code>23</code>”번 포트(텔넷 표준 포트)에 연결하라고 합니다. 어떻게 해야할까요?</p><p>응용프로그램 여러분, <code>connect()</code>에 대한 절을 읽는 중이라니 운이 좋습니다! 이 절은 원격 호스트에 어떻게 연결하는지에 대해 알려줍니다. 거침없이 읽어봅시다! 낭비할 시간이 없습니다!</p><p><code>connect()</code>에 대한 호출은 아래와 같습니다:</p><div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb31-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb31-3" title="3"></a>
<a class="sourceLine" id="cb31-4" title="4"><span class="dt">int</span> connect(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *serv_addr, <span class="dt">int</span> addrlen); </a></code></pre></div><p><code>sockfd</code>는 <code>socket()</code>함수 호출이 돌려주는 우리의 친근한 이웃인 소켓 파일 설명자 입니다. <code>serv_addr</code>는 <code>struct sockaddr</code>이고 목적지 포트와 아이피 주소를 담고 있습니다. <code>addrlen</code>은 서버 주소 구조체의 바이트단위 길이를 담고 있습니다.</p><p>모든 정보는 멋진 <code>getaddrinfo()</code>호출의 결과에서 추출할 수 있습니다.</p><p>이해가 되기 시작합니까? 여기서는 대답을 들을 수 없으니 그럴 것이라 생각하겠습니다. “<code>www.example.com</code>”의 <code>3490</code>포트로 소켓 연결을 만드는 예제를 살펴봅시다:</p><div class="sourceCode" id="cb32"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb32-2" title="2"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb32-3" title="3"></a>
<a class="sourceLine" id="cb32-4" title="4"><span class="co">// getaddrinfo()으로 주소 구조체를 채웁니다:</span></a>
<a class="sourceLine" id="cb32-5" title="5"></a>
<a class="sourceLine" id="cb32-6" title="6">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb32-7" title="7">hints.ai_family = AF_UNSPEC;</a>
<a class="sourceLine" id="cb32-8" title="8">hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb32-9" title="9"></a>
<a class="sourceLine" id="cb32-10" title="10">getaddrinfo(<span class="st">&quot;www.example.com&quot;</span>, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb32-11" title="11"></a>
<a class="sourceLine" id="cb32-12" title="12"><span class="co">// 소켓을 만듭니다:</span></a>
<a class="sourceLine" id="cb32-13" title="13"></a>
<a class="sourceLine" id="cb32-14" title="14">sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb32-15" title="15"></a>
<a class="sourceLine" id="cb32-16" title="16"><span class="co">// 연결합니다!</span></a>
<a class="sourceLine" id="cb32-17" title="17"></a>
<a class="sourceLine" id="cb32-18" title="18">connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a></code></pre></div><p>다시 이야기하자면 구식 프로그램들은 <code>connect()</code>에 넘겨줄 <code>struct sockaddr_in</code> 을 직접 채워넣었습니다. 그렇게 하고싶다면 해도 됩니다. 위에 있는 <a href="시스템-콜이-아니면-죽음을.html#bind"><code>bind()</code> 절</a> 에서 비슷한 내용을 참고하십시오.</p><p><code>connect()</code>의 복귀값을 확인하는 것을 잊지 마십시오. 오류가 발생하면 <code>-1</code>을 돌려주고 <code>errno</code>변수를 설정할 것입니다.</p><p></p><p>우리가 <code>bind()</code>를 호출하지 않았음에 주목하십시오. 간단히 말하자면 우리의 로컬 포트 번호에 대해서는 신경쓰지 않습니다. 우리가 어디로 가는지만 신경씁니다 (원격지 포트). 커널이 우리 대신 로컬 포트를 고를 것입니다. 우리가 접속하는 사이트는 이 정보를 자동으로 우리에게서 얻어냅니다. 신경쓰실 필요가 없습니다.</p><h2 id="listen"><span class="header-section-number">5.5</span> <code>listen()</code>—누가 연락 좀 해주실래요?</h2><p> 이제 흐름이 변할 때입니다. 우리가 원격지 호스트에 접속하고 싶지 않은 경우라면 어떻게 하시겠습니까? 재미로 하는 말이지만, 들어오는 연결을 기다리고 그것을 어떤 방식으로 다루고자 한다면 어떻게 하시겠습니까? 그 과정은 두 단계입니다. 먼저 <code>listen()</code>를 호출하고,  <code>accept()</code>를 씁니다.(아래를 참고하십시오.)</p><p><code>listen()</code>함수 호출은 꽤 단순하지만 약간의 설명이 필요합니다:</p><div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb33-1" title="1"><span class="dt">int</span> listen(<span class="dt">int</span> sockfd, <span class="dt">int</span> backlog); </a></code></pre></div><p><code>sockfd</code>은 <code>socket()</code>시스템 함수 호출로 얻어온 평범한 소켓 파일 설명자입니다.  <code>backlog</code>는 들어오는 큐에 허용되는 연결의 숫자입니다. 이것이 무슨 뜻인지 궁금하십니까? 들어오는 연결들은 여러분이 <code>accept()</code>를 해주기 전까지(아래를 참고하십시오) 이 큐 안에서 기다릴 것이고 이것은 몇 개의 연결이 대기할 수 있는가를 정합니다. 대개의 시스템은 이 값을 조용히 20 정도로 제한합니다. 그러나 <code>5</code>나 <code>10</code>정도의 값으로 설정해도 괜찮을 것입니다.</p><p>또 평소와 다름없이 <code>listen()</code>도 오류가 발생할 경우 <code>-1</code>을 돌려주고 <code>errno</code>을 설정할 것입니다.</p><p>아마도 상상하실 수 있겠지만 서버가 특정 포트에서 실행되도록 하기 위해서는 <code>listen()</code>을 호출하기 전에 <code>bind()</code>을 호출해야 합니다. (여러분의 친구들에게 어떤 포트로 연결해야 할지 말해줄 수 있어야 합니다.) 이런 식입니다.</p><div class="sourceCode" id="cb34"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb34-1" title="1">getaddrinfo();</a>
<a class="sourceLine" id="cb34-2" title="2">socket();</a>
<a class="sourceLine" id="cb34-3" title="3">bind();</a>
<a class="sourceLine" id="cb34-4" title="4">listen();</a>
<a class="sourceLine" id="cb34-5" title="5"><span class="co">/* accept()는 아래에 온다 */</span> </a></code></pre></div><p>I’ll just leave that in the place of sample code, since it’s fairly self-explanatory. (The code in the <code>accept()</code> section, below, is more complete.) The really tricky part of this whole sha-bang is the call to <code>accept()</code>.</p><h2 id="accept3490포트에-접속해주셔서-감사합니다.."><span class="header-section-number">5.6</span> <code>accept()</code>—“3490포트에 접속해주셔서 감사합니다..”</h2><p> 각오하십시오! <code>accept()</code>함수는 조금 이상합니다. 이렇게 돌아갑니다: 아주 먼 곳에 있는 누군가가 여러분의 장치에 <code>connect()</code> 함수로 연결하려고 합니다. 여러분은 특정 포트에서 <code>listen()</code>을 실행하고 있습니다. 그들의 연결은 <code>accept()</code>로 받아들여질 때까지 대기열에 쌓일 것입니다. 여러분은 <code>accept()</code>을 해서 대기중인 연결을 받아들이겠다고 알려줍니다. <code>accept()</code>는 이 연결만을 위해서 쓸 <em>완전히 새로운 소켓 파일 설명자</em> 를 돌려줄 것입니다. 그렇습니다! 갑자기 <code>send()</code>와 <code>recv()</code>를 쓸 수 있는 <em>두 개</em> 의 소켓 파일을 가지게 된 것입니다.</p><p>호출은 아래와 같이 합니다:</p><div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb35-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb35-3" title="3"></a>
<a class="sourceLine" id="cb35-4" title="4"><span class="dt">int</span> accept(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *addr, socklen_t *addrlen); </a></code></pre></div><p><code>sockfd</code>은 <code>listen()</code>을 하고있는 소켓 설명자입니다. 어렵지 않습니다. <code>addr</code>은 대개 로컬 <code>struct sockaddr_storage</code>에 대한 포인터입니다. 여기에 들어오는 연결의 정보가 들어가게 됩니다(그리고 그것을 통해서 어떤 호스트가 어떤 포트에서 여러분을 호출하고 있는지 알 수 있습니다.) <code>addrlen</code>은 sockaddr_storage을 <code>accept()</code>에 넘기기 전에 <code>sizeof(struct sockaddr_storage)</code>으로 설정되어야 하는 로컬 정수 변수입니다. <code>accept()</code>는 <code>addr</code>에 <code>addrlen</code>의 크기 이상의 바이트를 적지 않을 것입니다. 예상하셨습니까? <code>accept()</code>도 오류가 발생하면 <code>-1</code>을 돌려주고 <code>errno</code>에 값을 설정합니다. 전혀 예상하지 못하셨으리라 생각합니다.</p><p>전과 마찬가지로 한 번에 많은 내용입니다. 여러분의 독서를 위한 예제 코드 조각입니다:</p><div class="sourceCode" id="cb36"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb36-1" title="1"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb36-5" title="5"></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="pp">#define MYPORT &quot;3490&quot;  </span><span class="co">// 사용자들이 접속할 포트</span></a>
<a class="sourceLine" id="cb36-7" title="7"><span class="pp">#define BACKLOG 10     </span><span class="co">// 대기열에 몇 개의 연결이 대기할 수 있는가</span></a>
<a class="sourceLine" id="cb36-8" title="8"></a>
<a class="sourceLine" id="cb36-9" title="9"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb36-10" title="10">{</a>
<a class="sourceLine" id="cb36-11" title="11">    <span class="kw">struct</span> sockaddr_storage their_addr;</a>
<a class="sourceLine" id="cb36-12" title="12">    socklen_t addr_size;</a>
<a class="sourceLine" id="cb36-13" title="13">    <span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb36-14" title="14">    <span class="dt">int</span> sockfd, new_fd;</a>
<a class="sourceLine" id="cb36-15" title="15"></a>
<a class="sourceLine" id="cb36-16" title="16">    <span class="co">// !! 이 호출들에 대한 오류 확인을 잊지 마십시오 !!</span></a>
<a class="sourceLine" id="cb36-17" title="17"></a>
<a class="sourceLine" id="cb36-18" title="18">    <span class="co">// getaddrinfo()으로 정보를 채워넣습니다:</span></a>
<a class="sourceLine" id="cb36-19" title="19"></a>
<a class="sourceLine" id="cb36-20" title="20">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb36-21" title="21">    hints.ai_family = AF_UNSPEC;  <span class="co">// IPv4또는 IPv6, 아무것이나 씁니다.</span></a>
<a class="sourceLine" id="cb36-22" title="22">    hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb36-23" title="23">    hints.ai_flags = AI_PASSIVE;     <span class="co">// 나를 위해 자동으로 내 IP를 채워넣을 것.</span></a>
<a class="sourceLine" id="cb36-24" title="24"></a>
<a class="sourceLine" id="cb36-25" title="25">    getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb36-26" title="26"></a>
<a class="sourceLine" id="cb36-27" title="27">    <span class="co">// 소켓을 만들고, 바인드하고, 듣기 시작:</span></a>
<a class="sourceLine" id="cb36-28" title="28"></a>
<a class="sourceLine" id="cb36-29" title="29">    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb36-30" title="30">    bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a>
<a class="sourceLine" id="cb36-31" title="31">    listen(sockfd, BACKLOG);</a>
<a class="sourceLine" id="cb36-32" title="32"></a>
<a class="sourceLine" id="cb36-33" title="33">    <span class="co">// 들어오는 연결을 받습니다:</span></a>
<a class="sourceLine" id="cb36-34" title="34"></a>
<a class="sourceLine" id="cb36-35" title="35">    addr_size = <span class="kw">sizeof</span> their_addr;</a>
<a class="sourceLine" id="cb36-36" title="36">    new_fd = accept(sockfd, (<span class="kw">struct</span> sockaddr *)&amp;their_addr, &amp;addr_size);</a>
<a class="sourceLine" id="cb36-37" title="37"></a>
<a class="sourceLine" id="cb36-38" title="38">    <span class="co">// new_fd 소켓 설명자에서 통신할 준비 완료!</span></a>
<a class="sourceLine" id="cb36-39" title="39">    .</a>
<a class="sourceLine" id="cb36-40" title="40">    .</a>
<a class="sourceLine" id="cb36-41" title="41">    .</a></code></pre></div><p>다시 말하지만 모든 <code>send()</code>와 <code>recv()</code> 호출에 대해서 <code>new_fd</code>를 사용할 것입니다. 만약 단 한 개의 연결만을 받아들이길 원한다면 추가적인 연결이 같은 포트를 통해 들어오는 것을 막기 위해서 <code>sockfd</code>을 <code>close()</code>처리할 수 있습니다.</p><h2 id="sendrecv"><span class="header-section-number">5.7</span> <code>send()</code>와 <code>recv()</code>—Talk to me, baby!</h2><p>(역자 주 : Talk to me, baby!는 Elmore James의 노래입니다. 그러나 원저자의 의도가 이것인지 확실하지는 않습니다.) 이 두 함수들은 스트림 소켓이나 연결된 데이터그램 소켓을 통해 통신하기 위해서 쓰입니다. 일반적인 연결되지 않은 데이터그램 소켓을 쓰고싶다면 <a href="시스템-콜이-아니면-죽음을.html#sendtorecv"><code>sendto()</code>과 <code>recvfrom()</code></a> 절을 보시면 됩니다.</p><p> <code>send()</code> 함수:</p><div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb37-1" title="1"><span class="dt">int</span> send(<span class="dt">int</span> sockfd, <span class="dt">const</span> <span class="dt">void</span> *msg, <span class="dt">int</span> len, <span class="dt">int</span> flags); </a></code></pre></div><p><code>sockfd</code> 은 데이터를 보내고 싶은 소켓 설명자(<code>socket()</code>으로 만들었든 <code>accept()</code>로 만들었든)입니다. <code>msg</code>는 당신이 보낼 데이터에 대한 포인터이며, <code>len</code>은 그 길이입니다.</p><p>예제 코드는 이렇게 될 수 있겠습니다:</p><div class="sourceCode" id="cb38"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb38-1" title="1"><span class="dt">char</span> *msg = <span class="st">&quot;Beej was here!&quot;</span>;</a>
<a class="sourceLine" id="cb38-2" title="2"><span class="dt">int</span> len, bytes_sent;</a>
<a class="sourceLine" id="cb38-3" title="3">.</a>
<a class="sourceLine" id="cb38-4" title="4">.</a>
<a class="sourceLine" id="cb38-5" title="5">.</a>
<a class="sourceLine" id="cb38-6" title="6">len = strlen(msg);</a>
<a class="sourceLine" id="cb38-7" title="7">bytes_sent = send(sockfd, msg, len, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb38-8" title="8">.</a>
<a class="sourceLine" id="cb38-9" title="9">.</a>
<a class="sourceLine" id="cb38-10" title="10">. </a></code></pre></div><p>한 방에 모든 것을 보냈습니다. 다시 강조하지만 오류가 발생하면 <code>-1</code>이 반환되고 <code>errno</code>가 오류 번호로 설정됩니다.</p><p> <code>recv()</code>함수는 많은 면에서 유사합니다:</p><div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb39-1" title="1"><span class="dt">int</span> recv(<span class="dt">int</span> sockfd, <span class="dt">void</span> *buf, <span class="dt">int</span> len, <span class="dt">int</span> flags);</a></code></pre></div><p><code>sockfd</code>은 읽어들일 소켓 설명자이며, <code>buf</code>는 정보를 읽어들일 버퍼이고, <code>len</code>은 버퍼의 최대 길이이고 <code>flags</code>는 여기서도 0으로 설정될 수 있습니다. (플래그 정보에 대해서는 <code>recv()</code>의 man page를 참고하십시오.)</p><p><code>recv()</code>는 실제로 버퍼에 읽어들인 바이트의 수를 돌려주거나 오류가 발생할 경우 (<code>errno</code> 를 적절한 값으로 설정하고) <code>-1</code>을 돌려줍니다.</p><p>잠깐! <code>recv()</code>는 <code>0</code>을 돌려줄 수 있습니다. 이것은 한 가지 의미입니다: 원격지 측에서 당신에 대한 연결을 닫은 것입니다! 복귀값 <code>0</code>은 <code>recv()</code>가 연결이 끊어졌음을 알려주는 방식입니다.</p><p>자, 정말 쉽지않습니까? 이제 여러분은 스트림 소켓에서 자료를 주고받을 수 있습니다. 와! 이제 여러분은 유닉스 네트워크 프로그래머입니다!</p><h2 id="sendtorecv"><span class="header-section-number">5.8</span> <code>sendto()</code>와 <code>recvfrom()</code>—Talk to me, DGRAM-방식</h2><p> “이제 다 깔끔하고 좋네요”라고 말씀하시는 소리가 들립니다. “그렇지만 연결이 없는 데이터그램 소켓은 어떻게 처리하지요?”라고도 하시는군요. 문제 없습니다, 토모다치여(역자 주 : 원문은 amigo). 딱 맞는 것이 있습니다.</p><p>데이터그램 소켓은 원격지 호스트에 연결되어 있지 않으므로, 패킷을 보낼 때에 필요한 정보는 조금 다릅니다. 그렇습니다. 목적지 주소가 필요합니다. 이런 식입니다:</p><div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb40-1" title="1"><span class="dt">int</span> sendto(<span class="dt">int</span> sockfd, <span class="dt">const</span> <span class="dt">void</span> *msg, <span class="dt">int</span> len, <span class="dt">unsigned</span> <span class="dt">int</span> flags,</a>
<a class="sourceLine" id="cb40-2" title="2">           <span class="dt">const</span> <span class="kw">struct</span> sockaddr *to, socklen_t tolen); </a></code></pre></div><p>보시다시피 <code>send()</code>와 같지만 두 개의 정보가 더 있습니다. <code>to</code>는 목적지의  IP주소와  포트를 담은 <code>struct sockaddr</code> 이며(아마도 여러분이 형변환해서 사용하실 <code>struct sockaddr_in</code>이나 <code>struct sockaddr_in6</code> 또는 <code>struct sockaddr_storage</code>일 것입니다.) <code>tolen</code>은 내부적으로는 <code>int</code>이며 간단하게 <code>sizeof *to</code>나 <code>sizeof(struct sockaddr_storage)</code>로 설정하면 됩니다.</p><p>목적지 주소 구조체를 얻으려면 <code>getaddrinfo()</code>이나 아래의 <code>recvfrom()</code>을 사용하시거나 수작업으로 값을 채워넣을 수도 있습니다.</p><p><code>send()</code>와 마찬가지로 <code>sendto()</code>도 실제로 보낸 바이트 수를 돌려줍니다. ( 그 말은 보내려고 한 바이트의 수보다 적은 수가 돌아올 수도 있다는 의미입니다.) 오류가 발생하면 <code>-1</code>을 돌려줍니다.</p><p>이와 유사한 관계가 <code>recv()</code>과  <code>recvfrom()</code>입니다. <code>recvfrom()</code>의 개요는 이렇습니다:</p><div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb41-1" title="1"><span class="dt">int</span> recvfrom(<span class="dt">int</span> sockfd, <span class="dt">void</span> *buf, <span class="dt">int</span> len, <span class="dt">unsigned</span> <span class="dt">int</span> flags,</a>
<a class="sourceLine" id="cb41-2" title="2">             <span class="kw">struct</span> sockaddr *from, <span class="dt">int</span> *fromlen); </a></code></pre></div><p>또 다시 이것은 몇 개의 추가적인 필드가 있는 <code>recv()</code>과 같습니다. <code>from</code>은 근원지 장치의 아이피 주소와 포트로 채워진 로컬  <code>struct sockaddr_storage</code>에 대한 포인터입니다. <code>fromlen</code>은 로컬 <code>int</code>에 대한 포인터이며 <code>sizeof *from</code>이나 <code>sizeof(struct sockaddr_storage)</code>으로 초기화되어야 합니다. 함수가 반환될 때 <code>fromlen</code>은 <code>from</code>에 실제로 저장된 주소의 길이로 설정되어 있을 것입니다.</p><p><code>recvfrom()</code>은 받은 바이트의 갯수를 반환하며 오류가 나면 (<code>errno</code>를 적절히 설정하고) <code>-1</code>을 돌려줍니다.</p><p>여기 질문이 하나 있을 것입니다: 왜 우리는 <code>struct sockaddr_storage</code>을 소켓의 타입으로 사용하는가? 왜 그냥 <code>struct sockaddr_in</code>을 쓸 수 없는가? 이유는 보시다시피 우리가 IPv4나 IPv6중 하나에 얽메이고 싶지 않기 때문입니다. 그래서 우리는 양쪽 모두에 충분히 크고 일반적인 <code>struct sockaddr_storage</code>을 사용합니다.</p><p>(그럼… 여기에서 다른 질문 하나: 왜 <code>struct sockaddr</code>을 모든 주소를 담을 수 있을 정도로 크게 만들지 않았는가? 우리는 일반 목적의 <code>struct sockaddr_storage</code> 을 다시 일반 목적의 <code>struct sockaddr</code>으로 형변환하고 있습니다! 이런 동작은 과하고 불필요해 보입니다. 여기에 대한 대답은 그냥 이 <code>struct sockaddr</code>은 만들어질 때부터 그렇게 크지 않았다는 것이고, 이제와서 그것을 바꾸는 것은 문제의 소지가 있다는 것입니다. 그래서 그들은 그냥 새로운 타입을 만들었습니다.) (역자 주 : <code>struct sockaddr</code>은 소켓 통신의 초기에 만들어진 구조체이므로 IPv6을 담기에 충분하지 않은 것은 당연한 일입니다.)</p><p>만약 여러분이 데이터그램 소켓을  <code>connect()</code>하게 되면 모든 통신에 <code>send()</code>와 <code>recv()</code>을 쓸 수 있음을 기억하십시오. 소켓 자체는 여전히 데이터그램 소켓일 것이고 패킷은 여전히 UDP를 사용할 것이지만 소켓 인터페이스가 자동으로 여러분을 위해서 목적지와 원천지 정보를 추가할 것입니다.</p><h2 id="close와-shutdown내-앞에서-꺼져"><span class="header-section-number">5.9</span> <code>close()</code>와 <code>shutdown()</code>—내 앞에서 꺼져!</h2><p>휴! 여러분은 하루 종일 <code>send()</code>와 <code>recv()</code>을 사용했고, 이제 충분합니다. 이제 여러분의 소켓 설명자를 닫을 준비가 되었습니다. 이건 쉽습니다. 그냥 평범한 유닉스 파일 설명자 닫기 함수인  <code>close()</code> 를 쓸 수 있습니다:</p><div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb42-1" title="1">close(sockfd); </a></code></pre></div><p>이것은 해당 소켓에 대한 후속 읽기와 쓰기를 방지할 것입니다. 원격지에서 이 소켓을 쓰거나 읽으려는 모든 시도는 오류를 반환할 것입니다.</p><p>소켓이 어떻게 닫히는지 좀 더 조절하고 싶은 경우에  <code>shutdown()</code> 함수를 사용할 수 있습니다. 이것은 특정 방향으로의 통신만 끊는 일을 할 수 있으며 양쪽 모두 막을 수도 있습니다(마치 <code>close()</code>가 하듯이). 개요는 이렇습니다:</p><div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb43-1" title="1"><span class="dt">int</span> shutdown(<span class="dt">int</span> sockfd, <span class="dt">int</span> how); </a></code></pre></div><p><code>sockfd</code>는 종료하고 싶은 소켓 파일 설명자이고, <code>how</code>는 다음 중 하나입니다:</p><table><thead><tr class="header"><th style="text-align: center;"><code>how</code></th><th>효과</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>0</code></td><td>후속 수신이 금지됩니다.</td></tr><tr class="even"><td style="text-align: center;"><code>1</code></td><td>후속 송신이 금지됩니다.</td></tr><tr class="odd"><td style="text-align: center;"><code>2</code></td><td>후속 송수신이 금지됩니다. (<code>close()</code>처럼)</td></tr></tbody></table><p><code>shutdown()</code>은 성공시에 <code>0</code>을 반환하고, 오류가 발생하면 (<code>errno</code>를 적절한 값으로 설정하고) <code>-1</code>을 반환합니다.</p><p>연결되지 않은 데이터그램 소켓에 기꺼이 <code>shutdown()</code>을 해주신다면, 그것은 단순히 해당 소켓에 <code>send()</code>와 <code>recv()</code>를 사용할 수 없도록 만들 것입니다(데이터그램 소켓에 <code>connect()</code>를 사용하면 이 두 함수를 사용할 수 있음을 기억하십시오).</p><p><code>shutdown()</code>이 실제로 파일 설명자를 닫지는 않음에 주목하십시오. 소켓 설명자를 해제하기 위해서는 <code>close()</code>를 호출해야 합니다.</p><p>별 것 없군요.</p><p>(예외적으로 여러분이  윈도우즈와  Winsock을 사용하실 경우 <code>close()</code>대신  <code>closesocket()</code>을 호출해야 합니다.)</p><h2 id="getpeername누구십니까"><span class="header-section-number">5.10</span> <code>getpeername()</code>—누구십니까?</h2><p> 이 함수는 너무 쉽습니다.</p><p>너무 쉬워서 이 함수에 별도의 장을 주지도 않았습니다. 아무튼 알려드리겠습니다.</p><p><code>getpeername()</code>함수는 연결된 스트림 소켓의 반대편 끝에 누가 있는지를 알려줄 것입니다. 개요입니다:</p><div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb44-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb44-2" title="2"></a>
<a class="sourceLine" id="cb44-3" title="3"><span class="dt">int</span> getpeername(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *addr, <span class="dt">int</span> *addrlen); </a></code></pre></div><p><code>sockfd</code>는 연결된 스트림 소켓의 설명자입니다. <code>addr</code>은 연결의 반대편 끝에 대한 정보를 담을 <code>struct sockaddr</code> (또는 <code>struct sockaddr_in</code>) 에 대한 포인터입니다. <code>addrlen</code>은 <code>int</code>에 대한 포인터이며 <code>sizeof *addr</code>이나 <code>sizeof(struct sockaddr)</code>으로 초기화되어야 합니다. (역자 주 : 이 함수도 IPv6과 동작하기 위해서 <code>struct sockaddr_storage</code> 을 사용할 수 있습니다.)</p><p>이 함수는 오류가 발생하면 <code>-1</code>을 돌려주고 <code>errno</code>를 알맞게 설정합니다.</p><p>여러분이 상대방의 주소를 가지면 그것을  <code>inet_ntop()</code>,  <code>getnameinfo()</code> 또는  <code>gethostbyaddr()</code>에 넣어서 화면에 출력하거나 추가적인 정보를 가져올 수 있습니다. 그들의 로그인 이름을 가져올 수는 없습니다. (좋습니다, 좋아요. 만약 저쪽 컴퓨터가 ident 데몬을 실행중이라면 가능합니다. 그러나 그것은 이 문서의 범위를 넘어섭니다. 더 자세한 정보를 원한다면 <a href="https://tools.ietf.org/html/rfc1413">RFC 1413</a><a href="more-references.html#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a>을 참고하십시오.)</p><h2 id="gethostname나는-누구인가"><span class="header-section-number">5.11</span> <code>gethostname()</code>—나는 누구인가?</h2><p> <code>getpeername()</code>보다 더 쉬운 것이 바로 <code>gethostname()</code> 함수입니다. 이것은 여러분의 프로그램이 실행되고 있는 컴퓨터의 이름을 돌려줍니다. 돌려받은 이름은 위에 있는  <code>getaddrinfo()</code> 을 써서 여러분의 로컬 장치의  IP주소를 알아내는 일에 쓰일 수 있습니다.</p><p>이보다 더 재미있는 일이 있을 수 있겠습니까? 사실 몇 가지 생각나긴 합니다만 소켓 프로그래밍에 대한 것이 아니군요. 아무튼 정리하자면 이렇습니다:</p><div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb45-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb45-2" title="2"></a>
<a class="sourceLine" id="cb45-3" title="3"><span class="dt">int</span> gethostname(<span class="dt">char</span> *hostname, <span class="dt">size_t</span> size); </a></code></pre></div><p>인수들은 단순합니다: <code>hostname</code>은 함수가 반환하는 호스트 이름을 담을 char의 배열에 대한 포인터입니다. <code>size</code>는 <code>hostname</code>배열의 길이입니다.</p><p>함수는 성공적인 완료 후에 <code>0</code>을 반환하고, 오류에 대해서는 흔히 그렇듯 <code>errno</code>를 설정하고 <code>-1</code>을 반환합니다.</p><hr><div style="text-align:center"><span><a href="ipv4에서-ipv6으로-점프하기.html">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="client-server-background.html">Next</a></span></div></body>
</html>
