<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Beej의 네트워크 프로그래밍 안내서</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono&display=swap" rel="stylesheet"> 
  <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.6/dist/web/static/pretendard.css" />
  <!-- BG custom styling -->
  <style type="text/css">
  /* Fix for line numbers not visible */
  pre.numberSource code > span {
      left: -1em;
  }
  pre.numberSource {
      margin-left: initial;
  }
  
  /* Put some space after the section numbers */
  span.toc-section-number::after {
      content: "\a0\a0\a0";  /* non-breaking whitespace */
  }
  
  /* Hide underlines on code number links */
  pre > code.sourceCode > span > a:first-child::before {
      text-decoration: none;
  }
  
  /* Color the source blocks */
  div.sourceCode {
      background-color: #f0f0f0;
  }
  
  /* Fix iOS big text rendering issue */
  pre > code.sourceCode > span {
      display: initial;
  }
  
  
  /* Color the inline code */
  code:not(.sourceCode) {
      background: #f0f0f0;
      padding-left: 0.2em;
      padding-right: 0.2em;
      border-radius: 0.2em;
  }
  
  /* Keep code tags from wrapping in tables */
  tbody code {
      white-space: nowrap;
  }
  
  td {
      vertical-align: top;
  }
  
  body {
      font-size: 12pt;
      box-sizing: border-box;
      margin: 0;
      padding: 1em;
      max-width: min(43em, 100vw);
  }
  
  html {
      display: flex;
      justify-content: center;
      font-family: -apple-system, BlinkMacSystemFont, "Apple SD Gothic Neo", "Pretendard Variable", Pretendard, Roboto, "Noto Sans KR", "Segoe UI", "Malgun Gothic", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
  }
  
  figure {
      text-align: center;
  }
  </style>
  <!-- BG custom styling for the wide body variant -->
  <!-- Gets appended after bg-css.html -->
  
  <style type="text/css">
  body {
      max-width: inherit;
  }
  </style>
</head>
<body>
<header>
<h1 class="title">Beej의 네트워크 프로그래밍 안내서</h1>
<p class="subtitle">인터넷 소켓 사용법</p>
<p class="author">Brian “Beej Jorgensen” Hall</p>
<p class="date">v3.1.11, Copyright © April 8, 2023</p>
</header>
<nav id="TOC">
<ul><li><a href="#도입부"><span class="toc-section-number">1</span> 도입부</a><ul><li><a href="#읽는이에게"><span class="toc-section-number">1.1</span> 읽는이에게</a></li><li><a href="#실행환경과-컴파일러"><span class="toc-section-number">1.2</span> 실행환경과 컴파일러</a></li><li><a href="#공식-홈페이지와-책-구매"><span class="toc-section-number">1.3</span> 공식 홈페이지와 책 구매</a></li><li><a href="#solaris"><span class="toc-section-number">1.4</span> Solaris/SunOS 프로그래머들을 위한 노트</a></li><li><a href="#windows"><span class="toc-section-number">1.5</span> Windows 프로그래머들을 위한 노트</a></li><li><a href="#이메일-정책"><span class="toc-section-number">1.6</span> 이메일 정책</a></li><li><a href="#미러링"><span class="toc-section-number">1.7</span> 미러링</a></li><li><a href="#note-for-translators-번역가들을-위한-노트"><span class="toc-section-number">1.8</span> Note for Translators 번역가들을 위한 노트</a></li><li><a href="#legal"><span class="toc-section-number">1.9</span> Copyright, Distribution, and Legal</a></li><li><a href="#헌사"><span class="toc-section-number">1.10</span> 헌사</a></li><li><a href="#출판-정보"><span class="toc-section-number">1.11</span> 출판 정보</a></li><li><a href="#옮긴이의-말"><span class="toc-section-number">1.12</span> 옮긴이의 말</a></li></ul></li><li><a href="#소켓이란-무엇인가"><span class="toc-section-number">2</span> 소켓이란 무엇인가?</a><ul><li><a href="#두-종류의-인터넷-소켓"><span class="toc-section-number">2.1</span> 두 종류의 인터넷 소켓</a></li><li><a href="#lowlevel"><span class="toc-section-number">2.2</span> 저수준 논센스와 네트워크 이론</a></li></ul></li><li><a href="#ip-주소-구조체들-데이터-처리munging"><span class="toc-section-number">3</span> IP 주소, <code>구조체</code>들, 데이터 처리(Munging)</a><ul><li><a href="#ip-주소-4판과-6판버전4와-버전6"><span class="toc-section-number">3.1</span> IP 주소, 4판과 6판(버전4와 버전6)</a><ul><li><a href="#subnets서브넷-또는-부분망"><span class="toc-section-number">3.1.1</span> Subnets(서브넷 또는 부분망)</a></li><li><a href="#포트-번호"><span class="toc-section-number">3.1.2</span> 포트 번호</a></li></ul></li><li><a href="#바이트-순서"><span class="toc-section-number">3.2</span> 바이트 순서</a></li><li><a href="#structs"><span class="toc-section-number">3.3</span> <code>struct</code>들</a></li><li><a href="#ip-주소-파트-2"><span class="toc-section-number">3.4</span> IP 주소, 파트 2</a><ul><li><a href="#사설또는-분리된-망"><span class="toc-section-number">3.4.1</span> 사설(또는 분리된) 망</a></li></ul></li></ul></li><li><a href="#ipv4에서-ipv6으로-점프하기"><span class="toc-section-number">4</span> IPv4에서 IPv6으로 점프하기</a></li><li><a href="#시스템-콜이-아니면-죽음을"><span class="toc-section-number">5</span> 시스템 콜이 아니면 죽음을</a><ul><li><a href="#getaddrinfo발사-준비"><span class="toc-section-number">5.1</span> <code>getaddrinfo()</code>—발사 준비!</a></li><li><a href="#socket"><span class="toc-section-number">5.2</span> <code>socket()</code>—파일 설명자를 받아오라!</a></li><li><a href="#bind"><span class="toc-section-number">5.3</span> <code>bind()</code>—나는 어떤 포트에 있는가?</a></li><li><a href="#connect"><span class="toc-section-number">5.4</span> <code>connect()</code>—이봐, 안녕!</a></li><li><a href="#listen"><span class="toc-section-number">5.5</span> <code>listen()</code>—누가 연락 좀 해주실래요?</a></li><li><a href="#accept3490포트에-접속해주셔서-감사합니다.."><span class="toc-section-number">5.6</span> <code>accept()</code>—“3490포트에 접속해주셔서 감사합니다..”</a></li><li><a href="#sendrecv"><span class="toc-section-number">5.7</span> <code>send()</code>와 <code>recv()</code>—Talk to me, baby!</a></li><li><a href="#sendtorecv"><span class="toc-section-number">5.8</span> <code>sendto()</code>와 <code>recvfrom()</code>—Talk to me, DGRAM-방식</a></li><li><a href="#close와-shutdown내-앞에서-꺼져"><span class="toc-section-number">5.9</span> <code>close()</code>와 <code>shutdown()</code>—내 앞에서 꺼져!</a></li><li><a href="#getpeername누구십니까"><span class="toc-section-number">5.10</span> <code>getpeername()</code>—누구십니까?</a></li><li><a href="#gethostname나는-누구인가"><span class="toc-section-number">5.11</span> <code>gethostname()</code>—나는 누구인가?</a></li></ul></li><li><a href="#클라인트-서버-배경지식"><span class="toc-section-number">6</span> 클라인트-서버 배경지식</a><ul><li><a href="#단순한-스트림-서버"><span class="toc-section-number">6.1</span> 단순한 스트림 서버</a></li><li><a href="#단순한-스트림-클라이언트"><span class="toc-section-number">6.2</span> 단순한 스트림 클라이언트</a></li><li><a href="#datagram"><span class="toc-section-number">6.3</span> 데이터그램 소켓</a></li></ul></li><li><a href="#slightly-advanced-techniques"><span class="toc-section-number">7</span> Slightly Advanced Techniques</a><ul><li><a href="#blocking"><span class="toc-section-number">7.1</span> Blocking</a></li><li><a href="#poll"><span class="toc-section-number">7.2</span> <code>poll()</code>—Synchronous I/O Multiplexing</a></li><li><a href="#select"><span class="toc-section-number">7.3</span> <code>select()</code>—Synchronous I/O Multiplexing, Old School</a></li><li><a href="#sendall"><span class="toc-section-number">7.4</span> Handling Partial <code>send()</code>s</a></li><li><a href="#serialization"><span class="toc-section-number">7.5</span> Serialization—How to Pack Data</a></li><li><a href="#sonofdataencap"><span class="toc-section-number">7.6</span> Son of Data Encapsulation</a></li><li><a href="#broadcast-packetshello-world"><span class="toc-section-number">7.7</span> Broadcast Packets—Hello, World!</a></li></ul></li><li><a href="#common-questions"><span class="toc-section-number">8</span> Common Questions</a></li><li><a href="#man-pages"><span class="toc-section-number">9</span> Man Pages</a><ul><li><a href="#acceptman"><span class="toc-section-number">9.1</span> <code>accept()</code></a><ul><li><a href="#synopsis">Synopsis</a></li><li><a href="#description">Description</a></li><li><a href="#return-value">Return Value</a></li><li><a href="#example">Example</a></li><li><a href="#see-also">See Also</a></li></ul></li><li><a href="#bindman"><span class="toc-section-number">9.2</span> <code>bind()</code></a><ul><li><a href="#synopsis-1">Synopsis</a></li><li><a href="#description-1">Description</a></li><li><a href="#return-value-1">Return Value</a></li><li><a href="#example-1">Example</a></li><li><a href="#see-also-1">See Also</a></li></ul></li><li><a href="#connectman"><span class="toc-section-number">9.3</span> <code>connect()</code></a><ul><li><a href="#synopsis-2">Synopsis</a></li><li><a href="#description-2">Description</a></li><li><a href="#return-value-2">Return Value</a></li><li><a href="#example-2">Example</a></li><li><a href="#see-also-2">See Also</a></li></ul></li><li><a href="#closeman"><span class="toc-section-number">9.4</span> <code>close()</code></a><ul><li><a href="#synopsis-3">Synopsis</a></li><li><a href="#description-3">Description</a></li><li><a href="#return-value-3">Return Value</a></li><li><a href="#example-3">Example</a></li><li><a href="#see-also-3">See Also</a></li></ul></li><li><a href="#getaddrinfoman"><span class="toc-section-number">9.5</span> <code>getaddrinfo()</code>, <code>freeaddrinfo()</code>, <code>gai_strerror()</code></a><ul><li><a href="#synopsis-4">Synopsis</a></li><li><a href="#description-4">Description</a></li><li><a href="#return-value-4">Return Value</a></li><li><a href="#example-4">Example</a></li><li><a href="#see-also-4">See Also</a></li></ul></li><li><a href="#gethostnameman"><span class="toc-section-number">9.6</span> <code>gethostname()</code></a><ul><li><a href="#synopsis-5">Synopsis</a></li><li><a href="#description-5">Description</a></li><li><a href="#return-value-5">Return Value</a></li><li><a href="#example-5">Example</a></li><li><a href="#see-also-5">See Also</a></li></ul></li><li><a href="#gethostbynameman"><span class="toc-section-number">9.7</span> <code>gethostbyname()</code>, <code>gethostbyaddr()</code></a><ul><li><a href="#synopsis-6">Synopsis</a></li><li><a href="#description-6">Description</a></li><li><a href="#return-value-6">Return Value</a></li><li><a href="#example-6">Example</a></li><li><a href="#see-also-6">See Also</a></li></ul></li><li><a href="#getnameinfoman"><span class="toc-section-number">9.8</span> <code>getnameinfo()</code></a><ul><li><a href="#synopsis-7">Synopsis</a></li><li><a href="#description-7">Description</a></li><li><a href="#return-value-7">Return Value</a></li><li><a href="#example-7">Example</a></li><li><a href="#see-also-7">See Also</a></li></ul></li><li><a href="#getpeernameman"><span class="toc-section-number">9.9</span> <code>getpeername()</code></a><ul><li><a href="#synopsis-8">Synopsis</a></li><li><a href="#description-8">Description</a></li><li><a href="#return-value-8">Return Value</a></li><li><a href="#example-8">Example</a></li><li><a href="#see-also-8">See Also</a></li></ul></li><li><a href="#errnoman"><span class="toc-section-number">9.10</span> <code>errno</code></a><ul><li><a href="#synopsis-9">Synopsis</a></li><li><a href="#description-9">Description</a></li><li><a href="#return-value-9">Return Value</a></li><li><a href="#example-9">Example</a></li><li><a href="#see-also-9">See Also</a></li></ul></li><li><a href="#fcntlman"><span class="toc-section-number">9.11</span> <code>fcntl()</code></a><ul><li><a href="#synopsis-10">Synopsis</a></li><li><a href="#description-10">Description</a></li><li><a href="#return-value-10">Return Value</a></li><li><a href="#example-10">Example</a></li><li><a href="#see-also-10">See Also</a></li></ul></li><li><a href="#htonsman"><span class="toc-section-number">9.12</span> <code>htons()</code>, <code>htonl()</code>, <code>ntohs()</code>, <code>ntohl()</code></a><ul><li><a href="#synopsis-11">Synopsis</a></li><li><a href="#description-11">Description</a></li><li><a href="#return-value-11">Return Value</a></li><li><a href="#example-11">Example</a></li></ul></li><li><a href="#inet_ntoaman"><span class="toc-section-number">9.13</span> <code>inet_ntoa()</code>, <code>inet_aton()</code>, <code>inet_addr</code></a><ul><li><a href="#synopsis-12">Synopsis</a></li><li><a href="#description-12">Description</a></li><li><a href="#return-value-12">Return Value</a></li><li><a href="#example-12">Example</a></li><li><a href="#see-also-11">See Also</a></li></ul></li><li><a href="#inet_ntopman"><span class="toc-section-number">9.14</span> <code>inet_ntop()</code>, <code>inet_pton()</code></a><ul><li><a href="#synopsis-13">Synopsis</a></li><li><a href="#description-13">Description</a></li><li><a href="#return-value-13">Return Value</a></li><li><a href="#example-13">Example</a></li><li><a href="#see-also-12">See Also</a></li></ul></li><li><a href="#listenman"><span class="toc-section-number">9.15</span> <code>listen()</code></a><ul><li><a href="#synopsis-14">Synopsis</a></li><li><a href="#description-14">Description</a></li><li><a href="#return-value-14">Return Value</a></li><li><a href="#example-14">Example</a></li><li><a href="#see-also-13">See Also</a></li></ul></li><li><a href="#perrorman"><span class="toc-section-number">9.16</span> <code>perror()</code>, <code>strerror()</code></a><ul><li><a href="#synopsis-15">Synopsis</a></li><li><a href="#description-15">Description</a></li><li><a href="#return-value-15">Return Value</a></li><li><a href="#example-15">Example</a></li><li><a href="#see-also-14">See Also</a></li></ul></li><li><a href="#pollman"><span class="toc-section-number">9.17</span> <code>poll()</code></a><ul><li><a href="#synopsis-16">Synopsis</a></li><li><a href="#description-16">Description</a></li><li><a href="#return-value-16">Return Value</a></li><li><a href="#example-16">Example</a></li><li><a href="#see-also-15">See Also</a></li></ul></li><li><a href="#recvman"><span class="toc-section-number">9.18</span> <code>recv()</code>, <code>recvfrom()</code></a><ul><li><a href="#synopsis-17">Synopsis</a></li><li><a href="#description-17">Description</a></li><li><a href="#return-value-17">Return Value</a></li><li><a href="#example-17">Example</a></li><li><a href="#see-also-16">See Also</a></li></ul></li><li><a href="#selectman"><span class="toc-section-number">9.19</span> <code>select()</code></a><ul><li><a href="#synopsis-18">Synopsis</a></li><li><a href="#description-18">Description</a></li><li><a href="#return-value-18">Return Value</a></li><li><a href="#example-18">Example</a></li><li><a href="#see-also-17">See Also</a></li></ul></li><li><a href="#setsockoptman"><span class="toc-section-number">9.20</span> <code>setsockopt()</code>, <code>getsockopt()</code></a><ul><li><a href="#synopsis-19">Synopsis</a></li><li><a href="#description-19">Description</a></li><li><a href="#return-value-19">Return Value</a></li><li><a href="#example-19">Example</a></li><li><a href="#see-also-18">See Also</a></li></ul></li><li><a href="#sendman"><span class="toc-section-number">9.21</span> <code>send()</code>, <code>sendto()</code></a><ul><li><a href="#synopsis-20">Synopsis</a></li><li><a href="#description-20">Description</a></li><li><a href="#return-value-20">Return Value</a></li><li><a href="#example-20">Example</a></li><li><a href="#see-also-19">See Also</a></li></ul></li><li><a href="#shutdownman"><span class="toc-section-number">9.22</span> <code>shutdown()</code></a><ul><li><a href="#synopsis-21">Synopsis</a></li><li><a href="#description-21">Description</a></li><li><a href="#return-value-21">Return Value</a></li><li><a href="#example-21">Example</a></li><li><a href="#see-also-20">See Also</a></li></ul></li><li><a href="#socketman"><span class="toc-section-number">9.23</span> <code>socket()</code></a><ul><li><a href="#synopsis-22">Synopsis</a></li><li><a href="#description-22">Description</a></li><li><a href="#return-value-22">Return Value</a></li><li><a href="#example-22">Example</a></li><li><a href="#see-also-21">See Also</a></li></ul></li><li><a href="#structsockaddrman"><span class="toc-section-number">9.24</span> <code>struct sockaddr</code> and pals</a><ul><li><a href="#synopsis-23">Synopsis</a></li><li><a href="#description-23">Description</a></li><li><a href="#example-23">Example</a></li><li><a href="#see-also-22">See Also</a></li></ul></li></ul></li><li><a href="#more-references"><span class="toc-section-number">10</span> More References</a><ul><li><a href="#books"><span class="toc-section-number">10.1</span> Books</a></li><li><a href="#web-references"><span class="toc-section-number">10.2</span> Web References</a></li><li><a href="#rfcs"><span class="toc-section-number">10.3</span> RFCs</a></li></ul></li></ul>
</nav>
<!--
Beej's Guide to Network Programming book source

# vim: ts=4:sw=4:nosi:et:tw=72
--><!--
    History:

    2.3.2:        socket man page
    2.3.3:        sockaddr_in man page
    2.3.4:        bind, listen man page
    2.3.5:        connect man page
    2.3.6:        listen, perror man page
    2.3.7:        errno man page
    2.3.8:        htonl etc man page
    2.3.9:        close man page, expanded man page leader
    2.3.10:        inet_ntoa, setsockopt man pages
    2.3.11:        getpeername man page
    2.3.12:        send/sendto man pages
    2.3.13:        shutdown man pages
    2.3.14:        gethostname man pages, fix inet_aton links
    2.3.15:        fcntl man page
    2.3.16:        recv/recvfrom man page
    2.3.17:        gethostbyname/gethostbyaddr man page
    2.3.18:        changed GET / to GET / HTTP/1.0
    2.3.19:        added select() man page
    2.3.20:        added poll() man page
    2.3.21:        section on NAT and reserved networks
    2.3.22:        typo fixes in sects "man" and "privnet"
    2.3.23:        added broadcast packets section
    2.3.24:        manpage prototype changed to code, subtitle moved out of title
    2.4.0:        big overhaul, serialization stuff
    2.4.1:        minor text changes in intro
    2.4.2:        changed all sizeofs to use variable names instead of types
    2.4.3:        fix myaddr->my_addr in listener.c, sockaddr_inman example
    2.4.4:        fix myaddr->my_addr in server.c
    2.4.5:        fix 14->18 in son of data encap
    3.0.0:        IPv6 overhaul
    3.0.1:        sa-to-sa6 typo fix
    3.0.2:        typo fixes
    3.0.3:        typo fixes
    3.0.4:        cut-n-paste errors, selectserver hints fix
    3.0.5:        typo fixes
    3.0.6:        typo fixes
    3.0.7:        typo fixes, added front matter
    3.0.8:        getpeername() code fixes
    3.0.9:        getpeername() code fixes, this time fer sure
    3.0.10:        bind() man page code fix, comment changes
    3.0.11:        socket syscall section code fix, comment changes
    3.0.12:        typos in "IP Addresses, structs, and Data Munging"
    3.0.13:        amp removals, note about errno and multithreading
    3.0.14:        type changes to listener.c, pack2.c
    3.0.15:        fix inet_pton example
    3.0.16:        fix simple server output, optlen in getsockopt man page
    3.0.17:        fix small typo
    3.0.18:        reverse perror and close calls in getaddrinfo
    3.0.19:        add notes about O_NONBLOCK with select() under Linux
    3.0.20:        fix missing .fd in poll() example
    3.0.21:        change sizeof(int) to sizeof yes
    3.0.22:     C99 updates, bug fixes, markdown
    3.0.23:     Book reference and URL updates
    3.1.0:      Section on poll()
    3.1.1:      Add WSL note, telnot
    3.1.2:      pollserver.c bugfix
    3.1.3:      Fix freeaddrinfo memleak
    3.1.4:      Fix accept example header files
    3.1.5:      Fix dgram AF_UNSPEC
--><!-- prevent hyphenation of the following words: --><!--
Don't know how to make this work with underscores. I love
you, Knuth, but... daaahm.

\hyphenation{gai_strerr}
--><!--
\hyphenation{inet_ntoa}
\hyphenation{inet_aton}
\hyphenation{inet_addr}
\hyphenation{inet_ntop}
\hyphenation{inet_pton}
--><!--
\hyphenation{sockaddr_in}
\hyphenation{in_addr}
\hyphenation{sockaddr_in6}
\hyphenation{in6_addr}
--><h1 id="도입부"><span class="header-section-number">1</span> 도입부</h1><p>이봐요! 소켓 프로그래밍 때문에 힘든가요? <code>man</code>페이지로 공부하기가 좀 지나치게 어려운가요? 멋진 인터넷 프로그래밍을 하고싶지만 <code>connect()</code>를 호출하기 전에 <code>bind()</code>를 호출해야 한다는 것을 알아내기 위해서 한 무더기의 <code>struct</code>를 헤집고다닐 시간이 없나요?</p><p>음, 그런데 제가 그 귀찮은 일을 이미 다 해놨습니다. 그리고 그 정보를 여러분에게 공유하고 싶어서 죽을 지경입니다. 제대로 찾아오셨습니다. 이 문서는 보통 수준의 C 프로그래머가 귀찮은 네트워킹을 처리할 수 있게 도와줄 것입니다.</p><p>그리고 확인하실 것: 제가 드디어 미래의 기술을 따라잡았고(정말 겨우 시간을 맟췄죠) IPv6에 대한 안내를 갱신했습니다. 재밌게 보십시오!</p><h2 id="읽는이에게"><span class="header-section-number">1.1</span> 읽는이에게</h2><p>이 문서는 완전한 참고문서가 아닌 튜토리얼로서 작성되었습니다. 아마도 이제 막 소켓 프로그래밍을 시작해서 발받침이 필요한 사람이 읽기에 적합할 것입니다. 이것은 분명히 어떤 의미로든 <em>완벽하고 완전한</em> 소켓프로그래밍 가이드는 아닙니다.</p><p>그럼에도 희망적으로, 이 문서를 읽고나면 man page가 이해되기 시작할 것입니다.</p><h2 id="실행환경과-컴파일러"><span class="header-section-number">1.2</span> 실행환경과 컴파일러</h2><p>이 문서에 포함된 코드는 Gnu의  <code>gcc</code> 컴파일러를 사용하는 리눅스 PC에서 컴파일 되었습니다. 그러나 그 코드들은 <code>gcc</code>를 사용하는 어떤 실행환경에서도 빌드가 되어야 합니다. 그 말인즉 당신이 윈도우를 위해서 프로그램을 만들고 있다면 해당사항이 없다는 의미입니다. 그런 경우라면 <a href="#windows">윈도우즈 프로그래밍을 위한 절</a>을 참고하십시오.</p><h2 id="공식-홈페이지와-책-구매"><span class="header-section-number">1.3</span> 공식 홈페이지와 책 구매</h2><p>이 문서의 공식 위치는 아래와 같습니다:</p><ul><li><a href="https://beej.us/guide/bgnet/"><code>https://beej.us/guide/bgnet/</code></a></li></ul><p>이 곳에서 예제 코드와 이 안내서의 여러 언어로 된 번역본도 찾을 수 있습니다.</p><p>사람들이 책이라고 부르는 잘 제본된 인쇄된 복사본을 사고싶다면 여기에 방문하십시오:</p><ul><li><a href="https://beej.us/guide/url/bgbuy"><code>https://beej.us/guide/url/bgbuy</code></a></li></ul><p>구매해주신다면 저의 먹물밥으로 먹고 사는 라이프 스타일을 유지하는 일에 도움이 되므로 감사하겠습니다.</p><h2 id="solaris"><span class="header-section-number">1.4</span> Solaris/SunOS 프로그래머들을 위한 노트</h2><p> Solaris 또는  SunOS를 위해서 컴파일할 때, 정확한 라이브러리에 링크하기 위해서 약간의 추가적인 명령줄 스위치를 지정해야 합니다. 그러기 위해서 컴파일 명령의 끝에 “<code>-lnsl -lsocket -lresolv</code>”를 아래와 같이 덧붙이십시오.</p><pre><code>$ cc -o server server.c -lnsl -lsocket -lresolv</code></pre><p>여전히 에러가 있다면, 그 명령 뒤에 <code>-lxnet</code>를 덧붙여보십시오. 그것이 정확히 무엇을 하는지는 모르지만, 몇몇 사람들은 그렇게 해야 했다고 합니다.</p><p>당신이 문제를 발견할 수도 있는 또 다른 곳은 <code>setsockopt()</code>을 호출하는 곳입니다. 제 리눅스 장치와 함수 원형이 다릅니다. 그러므로 아래의 코드 대신:</p><div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">int</span> yes=<span class="dv">1</span>;</a></code></pre></div><p>이렇게 입력하십시오:</p><div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">char</span> yes=<span class="ch">&#39;1&#39;</span>;</a></code></pre></div><p>제가 Sun 장치를 가지지 않았으므로, 위에 적은 내용들을 시험해보지는 않았습니다. 저 내용들은 단지 사람들이 저에게 이메일로 알려준 것입니다.</p><h2 id="windows"><span class="header-section-number">1.5</span> Windows 프로그래머들을 위한 노트</h2><p>안내서의 이 부분을 적는 시점에 저는 더이상 제가 싫어한다는 이유로  Windows를 욕하는 일은 하지 말자고 다짐했습니다. 공평해야 하니까 미리 말해두자면 윈도우는 널리 사용되고 있고 분명히 완전히 멀쩡한 운영체제입니다.</p><p>추억은 미화된다고 하던데, 이 경우엔 사실인 듯 합니다.(아니면 제가 나이를 먹어서 그런가봅니다.) 제가 말할 수 있는 것은 마이크로소프트의 운영체제를 제 개인적 작업에 10년 이상 쓰지 않은 결과, 저는 더 행복하다는 것입니다. 얼마나 편하냐면 저는 의자에 기대서 편하게 “그럼요, 윈도우 써도 좋죠!”라고 말할 수 있습니다. 사실 그렇게 말하자니 어금니를 꽉 깨물게 되는군요.</p><p>그래서 저는 여전히 윈도우 대신  <a href="https://www.linux.com/">Linux</a><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>,  <a href="https://bsd.org/">BSD</a><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>, 아니면 다른 종류의 유닉스를 써 보라고 권하고 싶습니다.</p><p>하지만 사람들은 좋아하던 것을 계속 좋아하는 법이고, 윈도우를 쓰는 친구들은 이 문서의 정보가 그들에게도 보통 적용된다는 것을 알면 기뻐할 것입니다. 때때로 약간의 차이는 있겠지요.</p><p>당신이 진지하게 고려해봐야 할 다른 것은   <a href="https://learn.microsoft.com/en-us/windows/wsl/">Windows Subsystem for Linux</a><a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> 입니다. 이것은 간단히 말하자면 Windows 10에 리눅스 VM 비슷한 것을 깔게 해 줍니다. 그것도 당신이 충분히 준비할 수 있게 해 줄 것이고, 예제 프로그램을 있는 그대로 빌드할 수 있게 해 줄 것입니다.</p><p>당신이 할 수 있는 다른 멋진 일은 <a href="https://cygwin.com/">Cygwin</a><a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>을 설치하는 것입니다. 이것은 Windows를 위한 유닉스 도구 모음입니다. 그렇게 하면 예제 프로그램을 수정 없이 컴파일 할 수 있다고 들었습니다만 직접 해 보지는 않았습니다.</p><p>그러나 여러분 중 몇몇은 순수한 Windows방식으로 이걸 하고싶을지도 모르겠습니다. 그렇다면 아주 배짱이 두둑한 일이 되겠군요. 그렇게 하고싶다면 당장 집 밖으로 가서 유닉스를 돌릴 기계를 사십시오! 장난입니다. 요새는 윈도우에 (좀 더) 친화적으로 행동하려고 노력하고 있습니다.</p><p></p><p>이게 당신이 해야 할 일입니다. 첫 번째로 제가 이 문서에서 언급하는 거의 모든 시스템 헤더 파일을 무시하십시오. 그 대신 아래의 헤더파일을 포함하십시오.</p><div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="pp">#include </span><span class="im">&lt;winsock2.h&gt;</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="pp">#include </span><span class="im">&lt;ws2tcpip.h&gt;</span></a></code></pre></div><p><code>winsock</code>는 “새로운”(1994년 기준으로) 윈도우즈 소켓 라이브러리입니다.</p><p>불행하게도 당신이 <code>windows.h</code>를 인클루드하면 그것이 자동으로 버전1인 오래된 <code>winsock.h</code> 를 끌어오고 <code>winsock2.h</code>와 충돌을 일으킬 것입니다. 정말 재밌지요.</p><p>그러므로 만약 <code>windows.h</code>를 인클루드해야 한다면 그것이 오래된 헤더를 <em>포함하지 않도록</em> 아래의 매크로를 정의해야 합니다.</p><div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="pp">#define WIN32_LEAN_AND_MEAN  </span><span class="co">// 이렇게 적으십시오.</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="pp">#include </span><span class="im">&lt;windows.h&gt;</span><span class="pp">         </span><span class="co">// 이제 이걸 인클루드해도 됩니다.</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="pp">#include </span><span class="im">&lt;winsock2.h&gt;</span><span class="pp">        </span><span class="co">// 이것도요.</span></a></code></pre></div><p>잠깐! 소켓 라이브러리를 쓰기 전에  <code>WSAStartup()</code>을 호출해야 합니다. 이 함수에게 사용하길 원하는 Winsock 버전(예를 들어 2.2)을 넘겨주고 결과값을 확인해서 쓰고자 하는 버전이 사용 가능한지 확인해야 합니다.</p><p>그 작업을 하는 코드는 아래와 비슷할 것입니다.</p><div class="sourceCode" id="cb6"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="pp">#include </span><span class="im">&lt;winsock2.h&gt;</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3">{</a>
<a class="sourceLine" id="cb6-4" title="4">    WSADATA wsaData;</a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="cf">if</span> (WSAStartup(MAKEWORD(<span class="dv">2</span>, <span class="dv">2</span>), &amp;wsaData) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb6-7" title="7">        fprintf(stderr, <span class="st">&quot;WSAStartup failed.</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-8" title="8">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb6-9" title="9">    }</a>
<a class="sourceLine" id="cb6-10" title="10"></a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="cf">if</span> (LOBYTE(wsaData.wVersion) != <span class="dv">2</span> ||</a>
<a class="sourceLine" id="cb6-12" title="12">        HIBYTE(wsaData.wVersion) != <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb6-13" title="13">    {</a>
<a class="sourceLine" id="cb6-14" title="14">        fprintf(stderr,<span class="st">&quot;Versiion 2.2 of Winsock is not available.</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-15" title="15">        WSACleanup();</a>
<a class="sourceLine" id="cb6-16" title="16">        exit(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb6-17" title="17">    }</a></code></pre></div><p>저기 보이는  <code>WSACleanup()</code> 호출부를 주목하십시오. Winsock라이브러리를 다 쓴 후에 저것을 호출해야 합니다.</p><p>또한 컴파일러에게 <code>ws2_32.lib</code>라는 Winsock2 라이브러리를 링크하라고 말해줘야 합니다. VC++에서는 <code>프로젝트</code> 메뉴에서 <code>설정</code>으로 가서 <code>링크</code>탭을 클릭하고 “오브젝트/라이브러리 모듈” 이라는 제목이 붙은 상자를 찾으십시오. 그리고 거기에 “ws2_32.lib”나 당신이 원하는 다른 라이브러리를 추가하십시오. (옮긴이 주) 최신 Visual Studio에서는 [이 링크|https://learn.microsoft.com/en-us/cpp/build/reference/dot-lib-files-as-linker-input?view=msvc-170]를 참고해보십시오.</p><p>직접 해 본 것은 아닙니다.</p><p>그렇게 하고나면, 이 튜토리얼의 나머지 예제들은 거의 그대로 쓸 수 있을 것입니다. 몇 가지 예외가 있는데 소켓을 닫기 위해서 <code>close()</code>를 쓸 수 없습니다. 대신  <code>closesocket()</code>을 써야합니다. 또한 <code>select()</code>는 파일 설명자가 아닌 소켓 설명자에만 쓸 수 있습니다. (<code>stdin</code>의 <code>0</code> 같은 파일 설명자)</p><p>당신이 쓸 수 있는 소켓 클래스도 있습니다. <a href="https://learn.microsoft.com/en-us/cpp/mfc/reference/csocket-class?view=msvc-170"><code>CSocket</code></a>입니다. 자세한 정보는 컴파일러의 도움말 페이지를 참고하십시오.</p><p>Winsock에 대한 정보를 더 얻고싶다면 <a href="https://learn.microsoft.com/en-us/windows/win32/winsock/windows-sockets-start-page-2">마이크로소프트의 공식 홈페이지</a>를 참고하십시오.</p><p>마지막으로 윈도우에는  <code>fork()</code>가 없다고 들었습니다. 불행히도 제 예제코드 중 일부는 <code>fork()</code>를 사용합니다. 아마 그것을 동작하게 하려면 POSIX라이브러리에 링크하거나 다른 작업이 필요할 것입니다. 아니면  <code>CreateProcess()</code> 를 대신 쓸 수도 있습니다. <code>fork()</code>는 인수를 받지 않지만 <code>CreateProcess()</code>는 인수를 4800만개 정도 받습니다. 그게 부담스럽다면  <code>CreateThread()</code> 이 조금 더 쓰기 쉬울겁니다. 불행히도 멀티스레딩에 대한 논의는 이 문서의 범위를 벗어납니다. 저는 이 정도 까지밖에 말씀드릴 수가 없습니다.</p><p>정말 마지막으로, Steven Mitchell이 <a href="https://www.tallyhawk.net/WinsockExamples/">몇몇 예제들을 Winsock으로 변환했습니다.</a><a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> 확인해보십시오.</p><h2 id="이메일-정책"><span class="header-section-number">1.6</span> 이메일 정책</h2><p>저는 대체로  이메일로 오는 문의사항에 답을 드리고자 하니 이메일 보내기를 주저하지 마십시오. 그러나 응답을 보장하지는 못합니다. 저는 바쁜 삶을 살고 있고 제가 당신이 가진 궁금증에 대답할 수 없는 때가 많이 있습니다. 그런 경우라면 저는 그 메시지를 그냥 삭제합니다. 개인적인 감정이 아닙니다. 그저 당신이 필요로 하는 자세한 답을 할 시간이 없을 것이라 생각하기 때문입니다.</p><p>규칙을 제시하자면 질문이 복잡할수록 제가 응답할 가능성이 적어질 것입니다. 메일을 보내기 전에 질문의 범위를 좁히고 적절한 정보(실행환경, 컴파일러, 당신이 접하는 에러메시지, 문제 해결에 도움이 될 만한 다른 정보)를 첨부해주신다면 제 응답을 받을 확률이 올라갈 것입니다. 더 자세한 지침은 ESR의 문서인 <a href="http://www.catb.org/~esr/faqs/smart-questions.html">How To Ask Questions The Smart Way</a><a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>을 참고하십시오.</p><p>당신이 제 회신을 받지 못한다면, 문제를 더 파고들어보고, 답을 찾기 위해 노력해보십시오. 그래도 확실한 답을 얻지 못했다면 그동안 알아낸 정보를 가지고 저에게 다시 메일을 보내십시오. 어쩌면 제가 답을 드릴 수 있을지도 모릅니다.</p><p>저에게 메일을 보낼 때 이렇게 해라 저렇게 해라 말이 많았습니다만 이 안내서에 지난 몇 년 동안 보내주신 모든 칭찬에 <em>정말로</em> 감사한다는 사실을 말씀드리고 싶습니다. 그것은 정말로 정신적인 힘이 됩니다. 이 안내서가 좋은 일에 쓰였다는 말을 듣는 일은 저를 기쁘게 합니다. <code>:-)</code> 감사합니다!</p><h2 id="미러링"><span class="header-section-number">1.7</span> 미러링</h2><p>이 웹사이트를 공개로든 사적으로든 미러링하는 것은 정말로 환영합니다. 이 웹사이트를 공개적으로 미러링하고 제가 메인 페이지에 링크를 걸게 하고 싶다면 <a href="beej@beej.us"><code>beej@beej.us</code></a> 로 메일을 보내주십시오.</p><h2 id="note-for-translators-번역가들을-위한-노트"><span class="header-section-number">1.8</span> Note for Translators 번역가들을 위한 노트</h2><p> 이 안내서를 다른 언어로 번역하고 싶다면 <a href="beej@beej.us"><code>beej@beej.us</code></a>에게 메일을 보내주십시오. 당신의 번역본의 링크를 제 메인 페이지에 걸어두겠습니다. 당신의 이름과 연락처 정보를 번역본에 추가하셔도 좋습니다.</p><p>이 원본 마크다운 문서는 UTF-8로 인코드 되었습니다.</p><p>아래의 Copyright, Distribution, and Legal 절을 참고하십시오.</p><p>제가 번역본을 호스트하길 바란다면, 말씀해주십시오. 당신이 호스트하길 원한다면 그것도 링크하겠습니다. 어느 쪽이든 좋습니다.</p><h2 id="legal"><span class="header-section-number">1.9</span> Copyright, Distribution, and Legal</h2><p>(Translator’s Note : This section has not been translated to keep it’s legal information) (역자 주 : 이 절은 법적 정보를 보존하기 위해 번역하지 않았습니다.)</p><p>Beej’s Guide to Network Programming is Copyright © 2019 Brian “Beej Jorgensen” Hall.</p><p>With specific exceptions for source code and translations, below, this work is licensed under the Creative Commons Attribution- Noncommercial- No Derivative Works 3.0 License. To view a copy of this license, visit</p><p><a href="https://creativecommons.org/licenses/by-nc-nd/3.0/"><code>https://creativecommons.org/licenses/by-nc-nd/3.0/</code></a></p><p>or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.</p><p>One specific exception to the “No Derivative Works” portion of the license is as follows: this guide may be freely translated into any language, provided the translation is accurate, and the guide is reprinted in its entirety. The same license restrictions apply to the translation as to the original guide. The translation may also include the name and contact information for the translator.</p><p>The C source code presented in this document is hereby granted to the public domain, and is completely free of any license restriction.</p><p>Educators are freely encouraged to recommend or supply copies of this guide to their students.</p><p>Unless otherwise mutually agreed by the parties in writing, the author offers the work as-is and makes no representations or warranties of any kind concerning the work, express, implied, statutory or otherwise, including, without limitation, warranties of title, merchantability, fitness for a particular purpose, noninfringement, or the absence of latent or other defects, accuracy, or the presence of absence of errors, whether or not discoverable.</p><p>Except to the extent required by applicable law, in no event will the author be liable to you on any legal theory for any special, incidental, consequential, punitive or exemplary damages arising out of the use of the work, even if the author has been advised of the possibility of such damages.</p><p>Contact <a href="mailto:beej@beej.us"><code>beej@beej.us</code></a> for more information.</p><h2 id="헌사"><span class="header-section-number">1.10</span> 헌사</h2><p>이 안내서를 쓸 수 있도록 저를 과거에 도와주신, 그리고 미래에 도와주실 모든 분들에게 감사합니다. 이 안내서를 만들기 위해 사용한 자유 소프트웨어와 패키지(GNU, Linux, Slackware, vim, Python, Inkscape, pandoc, 기타 등등…)를 만든 모든 분들에게 감사드립니다. 또한 이 안내서의 발전을 위한 제안을 해주시고 응원의 말씀을 보내주신 수천명의 사람들에게 감사드립니다.</p><p>이 안내서를 컴퓨터 세계에서 나의 가장 위대한 영웅이자 영감을 주는 이들에게 바칩니다. Donald Knuth, Bruce Schneier, W. Richard Stevens, Steve The Woz Wozniak, 독자 여러분, 그리고 모든 자유 및 공개 소프트웨어 커뮤니티</p><h2 id="출판-정보"><span class="header-section-number">1.11</span> 출판 정보</h2><p>이 책은 GNU 도구를 적재한 Arch Linux장치에서 Vim 편집기를 사용해서 Markdown 으로 작성되었습니다. 표지 “미술”과 다이어그램은 Inkscape로 작성되었습니다. Markdown은 Python과 Pandoc, XeLaTex를 통해 HTML과 Latex/PDF로 변환되었습니다. 문서에는 Liberation 폰트를 사용했습니다. 툴체인은 전적으로 자유/공개 소프트웨어를 사용해서 구성했습니다.</p><h2 id="옮긴이의-말"><span class="header-section-number">1.12</span> 옮긴이의 말</h2><p>이 문서의 첫 한국어 번역 버전은 박성호(tempter@fourthline.com)님이 1998/08/20(yyyy/MM/d)에 인터넷의 어딘가에 게시하신 것으로 보입니다. 현재는 KLDP에 있습니다.</p><p>이 문서의 두 번째 한국어 번역 버전은 김수봉(연락처 없음)님이 2003/12/15(yyyy/MM/d)에 KLDP에 게시하셨습니다. 첫 번역 문서를 html에서 wiki형태로 변환했다고 적혀 있습니다.</p><p>지금 읽고 계시는 세 번째 버전은 정민석(javalia.javalia@gmail.com)이 작업했으며, 2023년 5월 28일부터 작업했습니다.</p><p>이 문서의 번역본은 1998년에 최초로 한국어 버전이 작성된 이래로 한국인이 Socket 프로그래밍에 대해서 참고할 수 있는 문서 중 리눅스 man page를 제외하면 가장 1차적인 문서였습니다. 실제로 많은 소켓 프로그래밍 관련 글과 출판된 책의 예제 코드도 이 문서의 것을 차용하고 있습니다. 원문은 세월이 흐르면서 조금씩 개정되어 내용이 상세해지고 IPv6에 대해서도 다루고 있으나 번역본은 20년 전의 모습으로 멈추어 있었습니다. 소켓 프로그래밍을 공부하던 시절 가장 큰 도움을 받은 문서의 번역본이 개정되지 않음을 안타깝게 생각해서 이렇게 새로운 번역본을 만들게 되었습니다. 이 글이 새로운 네트워크 라이브러리를 개발하는 프로그래머에게 도움이 되기를 바랍니다.</p><p>이 문서는 원문의 3.1.5 버전을 기반으로 번역되었습니다. 원문에 등장하는 고유명사는 해당 명사에 통용되는 한국어 번역이 없는 한 원어 그대로 실었습니다. 영어 일반명사는 음역을 기본으로 하였으나, 일부는 의역하기도 하였고 혼동을 줄이기 위해서 병기한 부분도 있습니다. 작업 과정에서 이전 번역자들의 원문을 유지하지는 못했습니다. 원문/번역본/새 번역본 사이의 대조/교정 작업은 개인적인 시간을 짜내서 진행하는 이 일에는 너무 큰 작업이었습니다. 이러한 사정으로 인해 이전 번역자들의 작업이 직접적으로 유지되지는 못하지만, 다른 프로그래머들을 위해 수 십년 전 글을 남기신 번역자 분들의 노력을 이어받고 그 작업을 존중하는 마음으로 다음 몇 년간 사람들이 읽을 수 있는 번역을 제공하기 위해 노력했습니다.</p><p>읽어주셔서 감사합니다.</p><h1 id="소켓이란-무엇인가"><span class="header-section-number">2</span> 소켓이란 무엇인가?</h1><p>여러분은 “소켓”이란 단어를 자주 들을 것입니다. 그리고 어쩌면 그것이 정확히 무슨 뜻인지 궁금하시겠지요. 그것은 표준 유닉스  파일 설명자를 통해서 다른 프로그램과 이야기하는 방법을 의미합니다.</p><p>무슨 말이냐고요?</p><p>좋습니다. 아마 어떤 유닉스 해커들이 “어으, 유닉스에선 <em>모든 것이</em> 파일이야!” 라고 말하는 것을 들어보셨을 것입니다. 그들이 말하는 바는 유닉스 프로그램이 어떤 종류의 입출력을 하든, 파일 설명자에 읽거나 쓰는 방식으로 동작한다는 의미입니다. 파일 설명자는 단순히 열려있는 파일과 연관된 정수입니다. 그러나 (이 부분이 중요합니다.) 그 파일은 네트워크 연결이나 선입선출, 파이프, 터미널, 디스크에 있는 진짜 파일이나 다른 어떤 것이든 될 수 있습니다. 유닉스의 <em>모든 것</em> 은 파일입니다! 그러니 인터넷 너머의 다른 프로그램과 통신하고 싶다면 파일 설명자를 통해서 하는 것이 당연합니다.</p><p>“그래서 이 네트워크 통신을 위한 파일 설명자를 어디에서 구하죠, 똑똑이양반?” 이라고 아마 지금 생각하실 듯 합니다. 답을 드리자면  <code>socket()</code> 시스템 루틴을 호출하면 된다는 겁니다. 그것은  소켓 설명자를 반환하고, 여러분은 특화된  <code>send()</code>와  <code>recv()</code> (<a href="#sendman"><code>man send</code></a>, <a href="#recvman"><code>man recv</code></a>) 소켓 함수를 써서 그 소켓을 통해 통신합니다.</p><p>“그런데 잠시만요!” 아마 다른 의문이 생길 것입니다. “그게 그냥 파일 설명자라면, 어째서 그냥 평범한  <code>read()</code>와  <code>write()</code> 함수를 사용해서 소켓 통신을 하면 안되는 것입니까?” 짧은 답은 “그래도 됩니다!”입니다. 긴 답은 “그래도 되지만,  <code>send()</code>과  <code>recv()</code>이 데이터 전송을 더 많이 조정할 수 있게 해 줍니다”가 되겠습니다.</p><p>다음이 궁금하신가요? 세상에는 온갖 종류의 소켓이 있습니다. DARPA 인터넷 주소(인터넷 소켓), 로컬 노드의 경로(유닉스 소켓), CCITT X.25 주소(무시해도 상관없는 X.25주소), 그리고 여러분이 실행중인 유닉스의 종류에 따라 다른 많은 종류의 소켓들. 이 문서는 첫 번째 것에 대해서만 다룹니다. 바로 인터넷 소켓입니다.</p><h2 id="두-종류의-인터넷-소켓"><span class="header-section-number">2.1</span> 두 종류의 인터넷 소켓</h2><p>인터넷 소켓이 두 종류라니 무슨 소리냐고요? 사실 거짓말입니다. 더 많은 종류가 있습니다. 그러나 여러분을 겁먹게 하기 싫었습니다. 여기서는 두 종류에 대해서만 이야기하겠습니다. 여러분에게  “Raw Socket”이라는 것이 있으며 그것이 아주 강력하고 한 번쯤 살펴보시길 권한다고 말하는 지금 이 문장을 제외하고 말입니다.</p><p>“이제 됐고 그 두 종류가 도대체 뭡니까?” 하나는  “Stream Socket(스트림 소켓)”이고 다른 하나는  “Datagram Socket(데이터그램 소켓)” 입니다. 앞으로 이 둘을 각각  “<code>SOCK_STREAM</code>” 과 “<code>SOCK_DGRAM</code>”으로 칭하겠습니다. 데이터그램 소켓은 때때로 비연결형/비연결성 소켓이라고 불립니다. (그러나 그것도 정말로 필요하다면  <code>connect()</code> 함수를 사용할 수 있습니다. 아래의 <a href="#connect"><code>connect()</code></a>를 참고하하십시오.)</p><p>스트림 소켓은 신뢰성있는 양방향 연결 통신 스트림입니다. 이 소켓에 두 개의 아이템을 “1, 2”의 순서로 출력하면, 반대쪽 끝에 “1, 2”의 순서로 도착합니다. 또한 스트림소켓은 에러가 발생하지 않습니다. 이것은 정말로 확실한 내용이어서, 저는 다른 사람들이 이것에 대해서 반박한다면 귀를 막고 노래나 부르겠습니다.</p><p>“무엇이 스트림 소켓을 사용하나요?” <code>telnet</code>이나 <code>ssh</code> 응용프로그램에 대해서 들어보셨습니까? 그것들이 스트림 소켓을 사용합니다. 여러분이 입력하시는 모든 문자가 입력하신 순서 그대로 도착해야 합니다. 또한, 웹브라우저가 쓰는 Hypertext Transfer Protocol  (HTTP)도 스트림 소켓을 사용합니다. 정말로, 어떤 웹사이트의 80번 포트에 텔넷으로 연결한 후 “<code>GET / HTTP/1.0</code>”을 입력하고 엔터를 두 번 치면 HTML을 돌려줄 것입니다.</p><blockquote><p>여러분이 <code>telnet</code>을 설치하지 않았고 설치하고 싶지 않거나, 설치된 <code>telnet</code>이 클라이언트에 연결하는 것에 대해 까다롭게 군다면 이 안내서는 <code>telnet</code>과 유사한 프로그램인 <a href="https://beej.us/guide/bgnet/examples/telnot.c"><code>telnot</code></a><a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>과 같이 제공됩니다. 이 안내서가 필요로 하는 일은 다 할 수 있을 것입니다. 텔넷이 사실은 <a href="https://tools.ietf.org/html/rfc854">spec’d networking protocol</a><a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>이며, <code>telnot</code> 은 이 프로토콜을 전혀 구현하지 않는다는 사실을 기억하십시오.</p></blockquote><p>“스트림 소켓이 어떻게 이렇게 수준높은 데이터 전송 품질을 달성하나요?” 스트림 소켓은 “Transmission Control Protocol”혹은  “TCP” (TCP에 대한 지나치게 자세한 정보는 <a href="https://tools.ietf.org/html/rfc793">RFC 793</a><a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>를 참고하십시오) 라고 불리는 프로토콜을 사용합니다. TCP는 여러분의 데이터가 순서대로 도착하고 오류가 없음을 보장합니다. “TCP”를 “TCP/IP”의 반절로 이미 들어보셨을 것입니다. “IP”는 “Internet Protocol(인터넷 프로토콜)”의 약어입니다. (<a href="https://tools.ietf.org/html/rfc791">RFC 791</a><a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>을 살펴보십시오) IP는 주로 인터넷 라우팅을 맡으며 데이터 무결성에는 보통 책임이 없습니다.</p><p></p><p>“굉장하네요. 데이터그램 소켓은 뭔가요? 왜 비연결성이죠? 뭐가 다른가요? 왜 신뢰성이 없나요?” 대답은 아래와 같습니다. 데이터그램을 전송하면 도착할 수도, 도착하지 않을 수도 있습니다. 도착은 하되 순서대로 도착하지 않을 수도 있습니다. 도착한다면, 패킷 안에 있는 데이터에는 에러가 없습니다.</p><p>데이터그램 소켓도 라우팅을 위해서 IP를 사용할 것입니다. 그러나 TCP를 사용하지는 않습니다. 데이터그램 소켓은 “User Datagram Protocol” 또는  “UDP”를 사용합니다. (<a href="https://tools.ietf.org/html/rfc768">RFC 768</a><a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>를 참고하십시오)</p><p>“왜 비연결성인가요?” 간단히 말하자면 스트림 소켓과 달리 열린 연결을 유지할 필요가 없기 때문입니다. 패킷을 만들고, 목적지 정보를 담은 IP헤더를 붙이고 보냅니다. 연결이 필요하지 않습니다. 데이터그램 소켓은 일반적으로 TCP 스택을 사용할 수 없거나 패킷 몇 개가 유실되어도 세상이 끝장나지는 않는 상황에서 쓰입니다. 몇몇 예제 프로그램은 다음과 같습니다. <code>tftp</code> (trivial file transfer protocol, FTP의 동생), <code>dhcpcd</code> (DHCP 클라이언트), 다중 사용자 게임, 오디오 스트리밍, 화상 회의, 등등</p><p></p><p>“잠시만요! <code>tftp</code>나 <code>dhcpcd</code>는 하나의 호스트에서 다른 호스트로 이진 응용프로그램을 전송하기 위해 쓰이잖아요! 응용프로그램이 도착지에서 제대로 동작하길 바라면 데이터가 유실되면 안 되는 것 아닌가요? 데이터를 제대로 보내기 위해서 마법이라도 쓰나요?”</p><p>머글 여러분, <code>tftp</code>와 유사한 프로그램들은 UDP위에서 자신만의 프로토콜을 구현합니다. 예를 들어 tftp프로토콜은 그들이 보내는 모든 패킷에 대해서 수신자가 “잘 받았습니다”라고 말하는 패킷(“ACK” 패킷)을 돌려줄 것을 요구합니다. 원본 패킷의 송신자가 일정 시간, 가령 5초 안에 응답을 받지 못한다면 송신자는 ACK응답을 받을 때까지 패킷을 재전송합니다. 이 확인 절차는 아주 중요해서 신뢰할 수 있는 <code>SOCK_DGRAM</code> 응용프로그램을 만들 때 아주 중요합니다.</p><p>게임이나 오디오, 비디오같은 신뢰할 수 없는 응용프로그램의 경우 유실된 패킷을 그냥 무시하거나 혹은 똑똑하게 무마하려고 합니다. (퀘이크 사용자들은 이런 유실로 인한 영향을 전문 용어로 <em>짜증나는 렉</em> 이라고 부릅니다. 여기에서 쓰인 “짜증나는” 은 아주 극단적인 욕설을 대체한 표현입니다.)</p><p>신뢰할 수 없는 기반 프로토콜을 왜 사용하는지 궁금하십니까? 두 가지입니다. 속도와 속도. 발사 후 망각(fire-and-forget) 방식이 무엇이 안전하게 도착했는지 추적하고 데이터가 올바른 순서로 왔는지 등을 확인하는 것보다 빠릅니다. 대화 메시지를 보낸다면 TCP는 훌륭한 선택입니다. 세계 안에서 초당 40번의 위치 정보 갱신을 전송한다면 한두 개의 정보가 유실되어도 상관없습니다. 그렇다면 UDP가 좋은 선택입니다.</p><h2 id="lowlevel"><span class="header-section-number">2.2</span> 저수준 논센스와 네트워크 이론</h2><p>프로토콜의 계층구조에 대해서 이야기했으니 네트워크가 실제로 어떻게 동작하는지 이야기할 차례입니다.  <code>SOCK_DGRAM</code>패킷이 어떻게 만들어지는지 약간의 예제를 보여드리겠습니다. 실용적으로는 이 절을 생략해도 좋습니다. 그러나 좋은 배경지식입니다.</p><figure><embed src="dataencap.svg" title="[캡슐화 프로토콜 다이어그램]" /><figcaption>데이터 캡슐화(Data Encapsulation).</figcaption></figure><p> <em>데이터 캡슐화</em> 에 대해 배울 차례입니다. 이것은 아주 중요합니다. 너무 중요해서 치코 캘리포니아 주립대에서 네트워크 수업을 듣는다면 이것에 대해 배우게 될 수도 있습니다. 간단히 말하자면 이렇습니다. 패킷이 태어나면 패킷은 첫 번째 프로토콜(예를 들어  TFTP 프로토코)에 의해  헤더로 감싸집니다(“캡슐화”) (때때로  푸터로도 감싸집니다). 그리고 전체가 다시 다음 프로토콜에 의해 감싸집니다(말하자면  UDP같은 것). 그리고 다시  IP로 감싸지고, 또 다시 하드웨어(물리) 계층(예를 들어  이더넷(Ethernet)에 의해 최종적인 프로토콜로 감싸집니다.</p><p>다른 컴퓨터가 패킷을 받으면 하드웨어는 이더넷 헤더를 벗겨내고, 커널이 IP와 UDP헤더를 벗겨냅니다. 그리고 TFTP프로그램이 TFTP헤더를 벗겨내고, 마침내 데이터를 가지게 됩니다.</p><p>드디어 악명높은   <em>계층화 네트워크 모델(Layered Network Model)</em> 에 대해서 이야기할 수 있습니다. 이 네트워크 모델은 네트워크 기능의 계(system) 를 묘사하며 다른 모델에 비해서 많은 장점을 가지고 있습니다. 예를 들어 여러분은 물리적으로 데이터가 어떻게 전송되는지(직렬통신(Serial), Thin Ethernet(얇은 동축케이블을 쓰는 이더넷의 변형), AUI(Attachment Unit Interface), 등등)(역자 주 : 여기에 언급되는 물리적 통신 단자들은 대개 현재는 특수한 산업현장이 아니면 쓰이지 않습니다. 여러분이 이런 것에 대해서 모르신다고 해도 전혀 지장이 없다는 의미입니다.)에 대해서 전혀 신경쓰지 않고 소켓 프로그램을 완전히 똑같은 모습으로 짤 수 있습니다. 그 이유는 저수준에 있는 프로그램들이 그것을 자동으로 처리해주기 때문입니다. 실제 네트워크 하드웨어와 망 구성방식(topology)는 소켓 프로그래머에게 투명(역자 주 : 알 필요가 없거나 알 수 없음)합니다.</p><p>길게 말하지 않고 이제 전체 모델의 계층을 제시하겠습니다. 네트워크 과목 시험을 위해서 이것을 기억하십시오.</p><ul><li>응용(Application)</li><li>표현(Presentation)</li><li>세션(Session)</li><li>전송(Transport)</li><li>네트워크(Network)</li><li>데이터 링크(Data Link)</li><li>물리(Physical)</li></ul><p>물리 계층은 하드웨어입니다(직렬통신, 이더넷 등). 응용 계층은 여러분이 상상할 수 있는 한 최대한 물리 계층에서 먼 것입니다. 사용자가 실제로 네트워크와 상호작용 하는 부분을 의미합니다.</p><p>사실 이 모델은 너무나 일반적이어서 정말로 원한다면 자동차 정비 안내서에도 쓸 수 있을 것입니다. 유닉스와 좀 더 일치하는 계층화 모델은 이렇습니다.</p><ul><li>응용 계층(Application Layer) (<em>텔넷, ftp 등.</em>)</li><li>호스트 간 전송 계층(Host-to-Host Transport Layer) (<em>TCP, UDP</em>)</li><li>인터넷 계층(Internet Layer) (<em>IP와 라우팅</em>)</li><li>네트워크 접근 계층(Network Access Layer) (<em>이더넷, 와이파이(wi-fi), 기타 등등</em>)</li></ul><p>이 시점까지 오면 여러분은 아마도 이 계층들이 원본 데이터의 캡슐화에 어떻게 대응하는지 아실 수 있을 듯 합니다.</p><p>간단한 패킷을 만들기 위해서 얼마나 많은 일이 일어나는지 아시겠습니까? 그리고 이것을 패킷 헤더에 적기 위해서 “<code>cat</code>”명령으로 하나하나 직접 적어야 합니다! 농담입니다. 스트림 소켓을 위해서 할 일은 그저  <code>send()</code> 로 데이터를 보내는 것 뿐입니다. 데이터그램 소켓을 위해서 할 일은 여러분이 원하는 방식으로 패킷을 캡슐화하고  <code>sendto()</code> 로 내보내는 일 뿐입니다. 커널이 여러분을 위해서 전송 계층과 인터넷 계층을 만들어주고 하드웨어가 네트워크 접근 계층을 만들어줄 것입니다. 현대 기술은 정말 멋지지요!</p><p>네트워크 이론에 대한 우리의 짧은 공부는 이렇게 끝납니다. 아, 라우팅에 대해서 말씀드리는 것을 잊었습니다. 그러나 라우팅에 대해서는 아무것도 다루지 않을 생각입니다. 라우터(router)가 IP헤더에 이르기까지 패킷을 까고, 라우팅 테이블 (routing table)을 조회하고, <em>어쩌고 저쩌고</em> 등에 대한 내용은 하나도 이야기하지 않을 것입니다. 정말로 진짜로 알고싶다면 <a href="https://tools.ietf.org/html/rfc791">IP RFC</a><a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>을 참고하세요. 평생 모르고 살아도 문제는 없습니다.</p><h1 id="ip-주소-구조체들-데이터-처리munging"><span class="header-section-number">3</span> IP 주소, <code>구조체</code>들, 데이터 처리(Munging)</h1><p>변화를 위해 코드에 대해 이야기하는 부분이 되었습니다.</p><p>그러나 코드가 아닌 이야기를 조금 더 하겠습니다. 먼저  IP 주소와 포트에 대한 이야기를 조금 해서 이해하고 넘어가겠습니다. 그 다음 소켓 API가 어떻게 IP주소와 다른 정보를 저장하고 조작하는지 다루겠습니다.</p><h2 id="ip-주소-4판과-6판버전4와-버전6"><span class="header-section-number">3.1</span> IP 주소, 4판과 6판(버전4와 버전6)</h2><p>벤 케노비(역자 주 : 스타워즈의 케릭터)를 아직 오비-완 케노비라고 부르던 좋은 옛 시절에는 인터넷 프로토콜 제4판 또는  IPv4라고 부르던 좋은 네트워크 라우팅 체계가 있었습니다. 그것은 4개의 바이트(또는 네 개의 “옥텟” (역자 주 : 8비트로 이루어진 1바이트를 명시적으로 지칭하는 표현))로 이루어지고 보통 <code>192.0.2.111</code> 같은 “점과 숫자” 형태로 기록되던 주소를 가졌습니다.</p><p>여러분은 아마도 그것을 보셨을 것입니다.</p><p>사실 이 글을 적는 시점에는 인터넷의 거의 모든 사이트가 IPv4를 사용합니다.</p><p>오비-완을 비롯해 모두가 행복했습니다. 모든 것이 훌륭했습니다. Vint Cerf 같은 부정적인 사람이 IPv4주소가 고갈되기 직전이라고 모두에게 경고하기 전까지 말입니다.</p><p>(다가오는 IPv4의 종말과 어둠을 모두에게 경고한 것 외에도  <a href="https://en.wikipedia.org/wiki/Vint_Cerf">Vint Cerf</a><a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a>는 인터넷의 아버지로 아주 잘 알려져 있습니다. 그래서 저는 그의 판단에 반기를 들 수가 없습니다.)</p><p>주소가 고갈된다니 이게 가능한 일인가? 32비트 IPv4 주소는 수십억개인데 정말로 가능한지 의문일겁니다. 정말로 세상에 수십억 개의 컴퓨터가 있을까요?</p><p>있습니다.</p><p>여기에 더해서, 컴퓨터가 정말 적던 초기에는 모두가 수십억은 불가능할 정도로 큰 수라고 생각했습니다. 그래서 일부 큰 조직에 관대하게도 수백만 개의 아이피 주소를 할당해 주었습니다. (그런 식으로 많은 IP 주소를 할당받은 조직의 이름을 몇 개 대자면 Xerox, MIT, Ford, HP, IBM, GE, AT&amp;T, 그리고 애플(Apple)이라고 하는 작은 회사도 있었습니다.)</p><p>사실 몇몇 임시방편이 없었다면 아이피는 예전에 다 떨어졌을 것입니다.</p><p>그러나 우리는 모든 사람, 모든 컴퓨터, 모든 계산기, 모든 전화기, 모든 주차 정산기, 모든 강아지와 멍멍이(왜 아니겠습니까?)에게 IP주소가 있는 시대를 살고 있습니다.</p><p>그리고 그렇게 해서  IPv6이 태어났습니다. 그리고 Vint Cerf는 아마도 불사의 존재이겠지만(그의 물리적 형체가 사라져야 한다면 그는 이미 Internet2의 깊은 곳에서 일종의 초인공지능 <a href="https://en.wikipedia.org/wiki/ELIZA">ELIZA</a><a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a> 프로그램 같은 모습으로 존재하고 있을 것입니다.), 다시 한 번 다음 버전의 인터넷 프로토콜에서 주소가 부족해서 그가 “내가 말했지”라는 식으로 이야기하는 것을 듣고 싶어할 사람은 없습니다.</p><p>이게 무슨 의미냐고요?</p><p>우리에게 <em>아주</em> 많은 주소가 필요하다는 뜻입니다. 두 배도 아니고, 십억배도 아니고, 천조배도 아니고, _7양9천자(역자 주 : 양은 10의 28승을 의미하는 수단위)_배가 필요합니다.</p><p>“Beej, 그게 사실인가요? 저에게는 큰 수를 신뢰하지 않을 많은 이유가 있습니다.”라고 말씀하시겠지요. 그러니까 32비트와 128비트 사이에는 그다지 큰 차이가 없어보일지도 모르겠습니다. 96비트가 더 있을 뿐이니까요. 하지만 우린 지금 거듭제곱에 대해서 이야기해야합니다. 32비트가 대략 40억개의 숫자들을 의미합니다. 128비트는 대략 11업 (역자 주 : 1업은 10의 76승을 의미)입니다. (정확히는 2의 128승입니다) 그것은 이 우주의 모든 별에 대해서 IPv4인터넷이 백만 개씩 있는 것과 비슷합니다.</p><p>IPv4의 점과 숫자 표기는 잊어버리십시오. 이제 우리에겐 콜론으로 구별하는 2바이트 조각으로 구성되는 16진수 표기법이 있습니다. 예시는 아래와 같습니다.</p><pre><code>2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551</code></pre><p>그게 다가 아닙니다! 대부분의 경우에 여러분은 0이 아주 많이 들어있는 주소를 가지게 될 것입니다. 그리고 그 0들을 두 개의 콜론 사이에 압축해서 넣을 수 있습니다. 또한 각각의 바이트 쌍의 앞에 오는 0은 생략할 수 있습니다. 예를 들어 아래의 각 주소쌍은 동일한 의미입니다.</p><pre><code>2001:0db8:c9d2:0012:0000:0000:0000:0051
2001:db8:c9d2:12::51

2001:0db8:ab00:0000:0000:0000:0000:0000
2001:db8:ab00::

0000:0000:0000:0000:0000:0000:0000:0001
::1</code></pre><p><code>::1</code>주소는 <em>재귀 주소</em>(루프백 주소) 입니다. 그것은 언제나 “내가 실행중인 이 기계”를 의미합니다. IPv4에서 루프백 주소는 <code>127.0.0.1</code>입니다.</p><p>마지막으로 IPv6주소에는 여러분이 보실지도 모르는 IPv4호환 모드가 있습니다. 예시를 원하신다면 이렇습니다. <code>192.0.2.33</code>을 IPv6주소로 표기한다면 아래와 같습니다. “<code>::ffff:192.0.2.33</code>”.</p><p>이건 아주 재미있는 일입니다.</p><p>사실 너무 재미있다고 할 수 있는데, IPv6의 제작자들이 수자(역자 주 : 10의 24승) 개의 주소를 기사도적으로 잘라내어 예약된 주소로 지정했기 때문입니다. 그러나 우리에게는 그러고도 너무 많은 주소가 남아있어서 남은 주소를 세기도 귀찮을 정도입니다. 아직도 은하계의 모든 남녀노소, 강아지, 주차정산기에 배정할 주소가 남아있습니다. 은하계의 모든 행성에 주차정산기가 있다는 것은 확실합니다. 저를 믿으십시오.</p><h3 id="subnets서브넷-또는-부분망"><span class="header-section-number">3.1.1</span> Subnets(서브넷 또는 부분망)</h3><p>관리적인 측면에서 때때로 “아이피 주소의 이 비트까지의 첫 부분은 <em>네트워크 부분</em> 이고 나머지는 <em>호스트 부분</em>” 이라고 칭하는 것이 편할 때가 있습니다.</p><p>예를 들어 IPv4주소에서 <code>192.0.2.12</code>를 가지고 있다면 우리는 첫 3바이트가 네트워크 주소이고 마지막 바이트가 호스트 주소라고 말할 수 있습니다. 조금 다르게 말하면 <code>192.0.2.0</code> 네트워크에 있는 호스트 <code>12</code>에 대해서 말한다고 할 수 있습니다.(네트워크 부분에서 우리가 호스트 바이트를 0으로 바꾼 것에 주목하십시오.)</p><p>더 오래된 정보를 알려드리겠습니다! 고대에는 이 서브넷에 “클래스”가 있었습니다. 각각 주소의 첫 번째, 두 번째, 세 번째 바이트까지가 네트워크 부분임을 의미했습니다. 여러분이 네트워크 부분에 1바이트를 받고 호스트 부분에 3바이트를 받을 정도로 운이 좋다면 여러분의 네트워크에 24비트 규모(대략 천육백만)의 호스트를 가질 수 있었습니다. 이것이 “클래스 A”네트워크입니다. 반대쪽 끝을 “클래스 C”라고 했습니다. 여기에서는 3바이트가 네트워크 부분이고 1바이트가 호스트입니다.(256개의 호스트이고, 예약된 주소때문에 몇 개를 더 빼야 합니다.)</p><p>그래서 보시다시피, A클래스는 몇 개 없고, C클래스는 엄청나게 많았으며, B클래스는 중간정도였습니다.</p><p>IP 주소의 네트워크 부분은 <em>넷마스크</em> 라는 것으로 표시되는데, IP주소에서 네트워크 번호를 얻어내기 위해서 넷마스크와 비트단위 AND연산을 하게 되어있습니다. 넷마스크는 대체로 <code>255.255.255.0</code>처럼 보입니다. (예를 들어 넷마스크가 저렇고 여러분의 IP가 <code>192.0.2.12</code>라면 네트워크는 <code>192.0.2.12</code> AND <code>255.255.255.0</code>이고 결과는 <code>192.0.2.0</code>입니다.)</p><p>불행히도 이것은 인터넷의 결과적인 필요에 비해 섬세하지 못했던 것으로 드러났습니다. C 클래스 네트워크는 꽤 빠르게 고갈되고 있었고 A클래스는 이미 다 소진되었으니 물어볼 것도 없습니다. 이 상황을 타개하기 위해서 8이나 16, 24개의 비트 뿐 아니라 임의의 비트를 넷마스크로 쓸 수 있는 능력이 필요했습니다. (예를 들어 <code>255.255.255.252</code> 같은 넷마스크로 30비트의 네트워크 부분과 2비트의 호스트(4개의 호스트)를 허락할 필요가 있었습니다.) (넷마스크는 <em>언제나</em> 여러 개의 비트 1 뒤에 뒤따라오는 여러 개의 비트 0임을 기억하십시오.)</p><p>그러나 <code>255.192.0.0</code>같은 긴 문자열을 넷마스크로 쓰는 것은 불편했습니다. 첫 번째로 사람들이 보기에 그것이 몇 비트인지 알기가 힘들었고 두 번째로 너무 길었습니다. 그래서 새로운 방식이 등장했고 훨씬 좋았습니다. IP 주소 뒤에 빗금(역자 주 : 슬래시 또는 /)을 적고 네트워크 비트의 수를 십진수로 적는 것입니다. 예시는 이렇습니다: <code>192.0.2.12/30</code></p><p>IPv6을 위해서는 이렇게 할 것입니다: <code>2001:db8::/32</code> 또는 <code>2001:db8:5413:4028::9db9/64</code></p><h3 id="포트-번호"><span class="header-section-number">3.1.2</span> 포트 번호</h3><p>친절하게도 아직 기억해주신다면, <a href="#lowlevel">계층화 네트워크 모델</a>에서 호스트 대 호스트 전송 계층(TCP and UDP)과 분리된 인터넷 계층 (IP)이 있음을 아실 것입니다. 다음 문단으로 가기 전에 한 번 더 살펴보셔도 좋습니다.</p><p>(IP 계층이 사용하는) IP주소 말고도 TCP (stream sockets)와 UDP (datagram sockets)는 우연히도 한 가지 주소를 더 사용하는 것을 알 수 있습니다. 그것은 바로 <em>포트 번호</em> 입니다. 이것은 16비트 숫자이며 연결을 위한 로컬 주소같은 것입니다.</p><p>IP 주소를 호텔의 도로명 주소라고 생각하고, 포트 번호를 방 번호라고 생각하십시오. 이것은 꽤 적절한 비유입니다. 어쩌면 나중에 자동차 산업과 관련된 다른 비유를 떠올릴 수 있을지도 모르겠습니다.</p><p>여러분이 이메일 수신과 웹서비스를 처리하는 컴퓨터를 가지고 있다고 해봅시다. 하나의 IP주소로 어떻게 그 두 일을 구분할 수 있겠습니까?</p><p>인터넷의 서로 다른 서비스들은 서로 다른 “잘 알려진” 포트번호를 가지고 있습니다. 전체 목록은 <a href="https://www.iana.org/assignments/port-numbers">거대한 IANA 포트 목록</a><a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a> 또는, 여러분이 유닉스 장치를 사용하신다면 <code>/etc/services</code>파일에서 볼 수 있습니다. HTTP(웹)는 80번 포트를 사용하고, telnet은 23번을, SMTP는 25를 쓰고 게임인 <a href="https://en.wikipedia.org/wiki/Doom_(1993_video_game)">DOOM</a><a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>은 666번(역자 주 : 둠은 지옥에서 온 악마와 싸우는 내용의 게임이며, 666은 기독교에서 악마의 숫자로 알려져 있습니다) 포트를 사용했습니다. 1024번 아래의 포트는 흔히 특별한 것으로 취급되어, 사용하기 위해서는 보통 운영체제 특권이 필요합니다.</p><p>이게 전부입니다!</p><h2 id="바이트-순서"><span class="header-section-number">3.2</span> 바이트 순서</h2><p> 왕국의 명령으로, 앞으로는 “엉터리”와 “큰 것 먼저”인 두 개의 바이트 순서가 있을 것이다!</p><p>농담입니다. 그러나 한 쪽이 다른 쪽보다 더 좋습니다. <code>:-)</code></p><p>사실 이것에 대해 딱 잘라 말할 방법은 없습니다. 그러니 허풍을 좀 떨겠습니다: 여러분의 컴퓨터는 뒤에서 바이트들을 여러분이 생각하는 것과 반대되는 순서로 저장하고 있었을 수도 있습니다. 아무도 이것을 여러분에게 알려주고 싶어하지 않았을 것입니다.</p><p>중요한 것은 인터넷 세계의 모든 사람들이 <code>b34f</code>같은 16진수 2바이트 수를 표현하고자 할 때 <code>b3</code>이 앞에 오고 <code>4f</code>이 뒤에 오는 연속된 바이트로 저장하는 것에 대체로 동의했다는 사실입니다. 이것은 말이 되기도 하고, <a href="https://en.wikipedia.org/wiki/Wilford_Brimley">Wilford Brimley</a><a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a> 라면 이것에 대해서 “마땅히 해야 할 일”이라고 할 것입니다. 큰 쪽이 앞에 저장되는 이 방식을 <em>Big-Endian(빅엔디언)</em> 이라고 합니다.</p><p>안타깝게도 전 세계 이곳저곳에 흩어진 <em>일부</em> 컴퓨터들, 그러니까 인텔 혹은 인텔 호환 프로세서 컴퓨터들은 바이트를 반대 순서로 저장합니다. 그래서 <code>b34f</code>는 <code>f4</code>뒤에 <code>b3</code>이 있는 순차적 바이트들로 저장됩니다. 이런 저장법을 <em>Little-Endian(리틀 엔디언)</em> 이라고 합니다.</p><p>아직 용어 해설이 조금 남았습니다! 더 멀쩡한 빅엔디언은 _Network Byte Order (네트워크 바이트 순서)라고도 합니다. 네트워크에서 우리가 그렇게 바이트를 전송하기 때문입니다.</p><p>여러분의 컴퓨터는 숫자를 <em>Host Byte Order(호스트 바이트 순서)</em> 로 저장합니다. 인텔 80x86이라면 그것은 리틀엔디언입니다. 모토롤라 68k라면 호스트 바이트 순서는 빅엔디언입니다. PowerPC라면 호스트 바이트 순서는.. 상황에 따라 다릅니다! (역자 주 : 현재 널리 쓰이는 x86-64 프로세서들은 리틀 엔디언이며, 이것은 흔히 쓰이는 ARM프로세서와 최근 애플이 사용을 시작한 M1, M2 등의 ARM변종에서도 동일하다. 리틀/빅엔디언 여부에 관계 없이 한 바이트 내에서는 무조건 MSB가 앞에 온다는 것도 기억해야 한다. 결론적으로 대부분의 컴퓨터들의 호스트 바이트 오더가 네트워크 바이트 오더와 다르다.)</p><p>패킷을 만들거나 자료 구조를 채워넣는 많은 경우에 여러분은 여러분의 2바이트 또는 4바이트 숫자들이 네트워크 바이트 순서로 확실히 기록되도록 해야합니다. 하지만 원시 호스트 바이트 순서를 모른다면 어떻게 이런 작업을 할 수 있을까요?</p><p>좋은 소식입니다! 그냥 호스트 바이트 순서가 늘 틀렸다고 가정하고, 그것을 네트워크 바이트 순서로 재정렬하는 함수에 넣으십시오. 그 함수가 필요하다면 마법의 변환과정을 처리하고, 여러분의 코드는 서로 다른 바이트 정렬 방식을 가진 기계 사이에서 호환성을 가질 것입니다.</p><p>좋습니다! 여러분이 변환할 수 있는 숫자에는 두 가지 종류가 있습니다: <code>short</code>(2바이트) 과 <code>long</code>(4바이트)입니다. 위에서 말한 처리함수들은 <code>부호 없는</code> 종류에도 쓰일 수 있습니다. 호스트 바이트 순서로 기록된 <code>short</code>을 네트워크 바이트 순서로 변환하고 싶다면, “host”의 “h”로 시작하고 “to”를 이어서 적고 “network”의 “n”을 적고 “short”의 “s”를 적으십시오. 다 붙이면 <code>htons()</code>이 됩니다. (읽는 법 : Host to Network Short)</p><p>정말 쉽지요…</p><p>“n”과 “h”, “s”, “l”의 모든 조합을 원하는대로 쓸 수 있습니다. 정말로 바보같은 것만 제외하고 말입니다. 예를 들어 <code>stolh()</code> 그러니까 “Short to Long Host”는 없습니다. 대신 이런 것들이 있습니다:</p><table><thead><tr class="header"><th>함수</th><th>설명</th></tr></thead><tbody><tr class="odd"><td><code>htons()</code></td><td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>s</code>hort</td></tr><tr class="even"><td><code>htonl()</code></td><td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>l</code>ong</td></tr><tr class="odd"><td><code>ntohs()</code></td><td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>s</code>hort</td></tr><tr class="even"><td><code>ntohl()</code></td><td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>l</code>ong</td></tr></tbody></table><p>간단히 말하자면 숫자가 랜선을 타고 나가기 전에 네트워크 바이트 순서로 변환해야 하며 랜선에서 들어올 때에 호스트 바이트 순서로 변환해야 합니다.</p><p>64비트 종류에 대해서는 저는 잘 모릅니다. 그리고 만약 부동소수점에 대한 것을 원하신다면 한참 아래에 있는 <a href="#serialization">직렬화</a> 절을 참조하십시오.</p><p>달리 말하지 않는 이상 이 문서의 숫자들은 호스트 바이트 순서라고 생각하십시오.</p><h2 id="structs"><span class="header-section-number">3.3</span> <code>struct</code>들</h2><p>마침내 여기까지 왔습니다. 프로그래밍에 대해서 말할 차례입니다. 이 절에서는 소켓 인터페이스가 사용하는 다양한 데이터 형식에 대해서 논할 것이며 그 중 몇몇은 정말로 어렵습니다.</p><p>쉬은 것 부터 시작하겠습니다:  소켓 설명자입니다. 소켓 설명자는 아래의 형식입니다.</p><div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">int</span></a></code></pre></div><p>그냥 평범한 <code>int</code>입니다.</p><p>여기서부터 이상해집니다. 저와 함께 꾹 참고 따라오십시오.</p><p>나의 첫 번째 구조체™—<code>struct addrinfo</code>.  이 구조체는 꽤나 최근의 발명품입니다. 이것은 이후의 사용을 위한 소켓 주소 구조체를 준비하기 위해 사용됩니다. 또한 호스트 이름 찾기나 서비스 이름 찾기 에도 사용됩니다. 나중에 실제 사용 예시를 보시면 이해가 되겠지만 지금은 연결을 만들 때 맨 처음 호출하는 것들 중 하나라고 알아두십시오.</p><div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">struct</span> addrinfo {</a>
<a class="sourceLine" id="cb10-2" title="2">    <span class="dt">int</span>              ai_flags;     <span class="co">// AI_PASSIVE, AI_CANONNAME, etc.</span></a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="dt">int</span>              ai_family;    <span class="co">// AF_INET, AF_INET6, AF_UNSPEC</span></a>
<a class="sourceLine" id="cb10-4" title="4">    <span class="dt">int</span>              ai_socktype;  <span class="co">// SOCK_STREAM, SOCK_DGRAM</span></a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="dt">int</span>              ai_protocol;  <span class="co">// use 0 for &quot;any&quot;</span></a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="dt">size_t</span>           ai_addrlen;   <span class="co">// size of ai_addr in bytes</span></a>
<a class="sourceLine" id="cb10-7" title="7">    <span class="kw">struct</span> sockaddr *ai_addr;      <span class="co">// struct sockaddr_in or _in6</span></a>
<a class="sourceLine" id="cb10-8" title="8">    <span class="dt">char</span>            *ai_canonname; <span class="co">// full canonical hostname</span></a>
<a class="sourceLine" id="cb10-9" title="9"></a>
<a class="sourceLine" id="cb10-10" title="10">    <span class="kw">struct</span> addrinfo *ai_next;      <span class="co">// linked list, next node</span></a>
<a class="sourceLine" id="cb10-11" title="11">};</a></code></pre></div><p>이 구조체에 내용을 조금 채워넣은 후에  <code>getaddrinfo()</code> 을 호출할 것입니다. 이 함수는 여러분에게 필요한 모든 것들로 채워진, 이 구조체의 링크드 리스트를 반환할 것입니다.</p><p><code>ai_family</code>필드에서 IPv4나 IPv6을 강제할 수 있고 무엇이든 상관없다면 <code>AF_UNSPEC</code> 으로 둘 수 있습니다. 이것은 여러분의 코드가 IP버전에 무관해지도록 해 주기에 좋습니다.</p><p>이것이 링크드 리스트임을 기억하십시오: <code>ai_next</code>는 다음 요소를 가리킵니다. 여러분이 고를 수 있는 여러 개의 결과가 돌아올 수 있다는 의미입니다. 저라면 쓸 수 있는 첫 번째 것을 쓰겠습니다. 그러나 여러분은 다른 비즈니스 요구사항이 있을지도 모릅니다. 저는 이것에 대해서 잘 모릅니다!</p><p><code>struct addrinfo</code>안의 <code>ai_addr</code>이  <code>struct sockaddr</code> 에 대한 포인터임을 보실 수 잇습니다. 여기서부터 IP 주소 구조체의 내부를 살펴볼 때에 지저분해지기 시작하는 곳입니다.</p><p>여러분은 대체로 이 구조체들에 쓰기 작업을 할 일이 없을 것입니다. 대체로 여러분의 <code>struct addrinfo</code>을 채우기 위해서 <code>getaddrinfo()</code>을 호출하는 것이 여러분이 해야 할 일의 전부입니다. 그러나 그 안에서 값을 꺼내오기 위해서는 그 안을 <em>들여다봐야만</em> 하므로 이제부터 설명하겠습니다.</p><p>(<code>struct addrinfo</code>가 발명되기 전의 코드에서는 모든 정보를 손으로 채워넣어야 했습니다. 저 거친 야생에는 정확히 그런 일을 하는 IPv4코드를 많이 보실 수 있습니다. 이 안내서의 오래된 버전을 포함한 여러 곳에서 말입니다.)</p><p>몇몇 <code>struct</code>는 IPv4용이고, 어떤 것은 IPv6용이며 어떤 것은 양쪽 모두에 필요합니다. 뭐가 무엇인지도 적어두겠습니다.</p><p>어쨌든 <code>struct sockaddr</code>은 여러 종류의 소켓을 위한 소켓 주소 정보를 저장합니다.</p><div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">struct</span> sockaddr {</a>
<a class="sourceLine" id="cb11-2" title="2">    <span class="dt">unsigned</span> <span class="dt">short</span>    sa_family;    <span class="co">// 주소 계열, AF_xxx</span></a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="dt">char</span>              sa_data[<span class="dv">14</span>];  <span class="co">// 14 바이트의 프로토콜 주소</span></a>
<a class="sourceLine" id="cb11-4" title="4">}; </a></code></pre></div><p><code>sa_family</code>는 몇 가지 것들 중 하나가 될 수 있는데, 우리가 이 문서에서 하는 모들 일에 대해서는  <code>AF_INET</code> (IPv4) 이나  <code>AF_INET6</code> (IPv6)가 될 것입니다. <code>sa_data</code>는 소켓을 위한 목적지 주소와 포트 번호가 담겨 있습니다. 이것에 주소를 직접 적어넣는 일은 지루하고 불편합니다.</p><p><code>struct sockaddr</code>을 상대하기 위해서 프로그래머들은 IPv4를 위한 병렬적인 구조체인  <code>struct sockaddr_in</code> (“Internet”의 “in”)을 만들었습니다.</p><p>그리고 <em>이것이 중요한 부분입니다</em>: <code>struct sockaddr_in</code>에 대한 포인터는 <code>struct sockaddr</code>에 대한 포인터르 형변환 될 수 있고 그 반대도 가능합니다. 그래서 <code>connect()</code>가 <code>struct sockaddr*</code>을 원하더라도 <code>struct sockaddr_in</code>을 사용할 수 있고 마지막에 형변환만 하면 되는 것입니다!</p><div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1"><span class="co">// (IPv4 only--see struct sockaddr_in6 for IPv6)</span></a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="kw">struct</span> sockaddr_in {</a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="dt">short</span> <span class="dt">int</span>          sin_family;  <span class="co">// 주소 계열, AF_INET</span></a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="dt">unsigned</span> <span class="dt">short</span> <span class="dt">int</span> sin_port;    <span class="co">// 포트 번호</span></a>
<a class="sourceLine" id="cb12-6" title="6">    <span class="kw">struct</span> in_addr     sin_addr;    <span class="co">// 인터넷 주소</span></a>
<a class="sourceLine" id="cb12-7" title="7">    <span class="dt">unsigned</span> <span class="dt">char</span>      sin_zero[<span class="dv">8</span>]; <span class="co">// sockaddr 구조체와 같은 크기로 만든다</span></a>
<a class="sourceLine" id="cb12-8" title="8">};</a></code></pre></div><p>이 구조체는 소켓 주소의 요소들을 참조하는 일을 쉽게 해 줍니다. <code>sin_zero</code> (<code>struct sockaddr</code>과 길이를 맞추기 위해서 덧대진 것)은 <code>memset()</code>을 이용해서 0으로 설정되어야 함을 기억하십시오. 또한 <code>sin_family</code>은 <code>struct sockaddr</code>의 <code>sa_family</code>에 대응되며 “<code>AF_INET</code>”으로 설정되어야 함을 기억하십시오. 마지막으로 <code>sin_port</code>은 반드시  <em>네트워크 바이트 순서</em> 로 기록해야 함을 기억하십시오.( <code>htons()</code>을 써야한다는 의미입니다.)</p><p>더 깊게 파고들어가봅시다. <code>struct in_addr</code>에는 <code>sin_addr</code>필드가 있습니다. 저것이 무엇일까요? 지나치게 과장할 필요는 없지만 저것은 지금껏 있었던 가장 무서운 공용체 (역자 주 : 하나의 메모리 구역을 서로 다른 데이터타입처럼 읽고 쓸 수 있게 해 주는 C언어의 기능) 중 하나입니다.</p><div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="co">// (IPv4 전용--IPv6를 위해서는 in6_addr 구조체를 참조하라)</span></a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co">// 인터넷 주소 (역사적인 이유로 존재하는 구조체)</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="kw">struct</span> in_addr {</a>
<a class="sourceLine" id="cb13-5" title="5">    <span class="dt">uint32_t</span> s_addr; <span class="co">// 32비트 정수이다 (4 바이트)</span></a>
<a class="sourceLine" id="cb13-6" title="6">};</a></code></pre></div><p>와! 사실 이것은 공용체 <em>였습니다</em>. 그러나 이제 그 시절은 지났습니다. 잘된 일입니다. 그러니까 만약 여러분이 <code>struct sockaddr_in</code> 형으로 <code>ina</code>를 선언했다면 <code>ina.sin_addr.s_addr</code>이 (네트워크 바이트 순서로 적힌) 4바이트의 IP주소를 가리킬 것입니다. 여러분의 시스템이 <code>struct in_addr</code>에 대해서 여전히 형편없는 공용체를 사용해도 여러분은 제가 위에서 한 것과 동일한 방식으로 4바이트 IP주소를 참조할 수 있습니다.(이것은 <code>#define</code> 덕분입니다.)</p><p> IPv6에 대해서도 유사한 <code>struct</code>가 있습니다:</p><div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="co">// (IPv6 전용--IPv4를 위해서는 sockaddr_in 구조체와 in_addr 구조체를 참조하라)</span></a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="kw">struct</span> sockaddr_in6 {</a>
<a class="sourceLine" id="cb14-4" title="4">    u_int16_t       sin6_family;   <span class="co">// 주소 계열, AF_INET6</span></a>
<a class="sourceLine" id="cb14-5" title="5">    u_int16_t       sin6_port;     <span class="co">// 포트 번호, 네트워크 바이트 순서</span></a>
<a class="sourceLine" id="cb14-6" title="6">    u_int32_t       sin6_flowinfo; <span class="co">// IPv6 흐름 정보</span></a>
<a class="sourceLine" id="cb14-7" title="7">    <span class="kw">struct</span> in6_addr sin6_addr;     <span class="co">// IPv6 주소</span></a>
<a class="sourceLine" id="cb14-8" title="8">    u_int32_t       sin6_scope_id; <span class="co">// 스코프 아이디</span></a>
<a class="sourceLine" id="cb14-9" title="9">};</a>
<a class="sourceLine" id="cb14-10" title="10"></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="kw">struct</span> in6_addr {</a>
<a class="sourceLine" id="cb14-12" title="12">    <span class="dt">unsigned</span> <span class="dt">char</span>   s6_addr[<span class="dv">16</span>];   <span class="co">// IPv6 주소</span></a>
<a class="sourceLine" id="cb14-13" title="13">};</a></code></pre></div><p>IPv4용 구조체가 그렇듯이 IPv6 구조체도 IPv6주소와 포트번호를 가진 것에 주목하십시오.</p><p>지금은 IPv6의 흐름 정보나 Scope ID 필드에 관한 내용은 다루지 않을 것입니다. 이것은 초보자용 안내서이기 때문입니다. <code>:-)</code></p><p>마지막으로 중요한 것은, 여기에 IPv4와 IPv6의 모든 구조체를 담기에 충분히 크게 설계된 <code>struct sockaddr_storage</code>라는 또 하나의 단순한 구조체가 있다는 사실입니다. 때때로 어떤 함수 호출에 대해서 여러분은 그 함수가 여러분의 <code>struct sockaddr</code>를 IPv4주소로 채울지 아니면 IPv6주소로 채울지 알 수 없는 경우가 있습니다. 그러므로 이 병렬 구조체를 넘기면 됩니다. 이것은 좀 더 크다는 점을 제외하면 <code>struct sockaddr</code>과 아주 비슷하며, 여러분은 이것을 여러분이 원하는 형식으로 형변환 할 수 있습니다.</p><div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">struct</span> sockaddr_storage {</a>
<a class="sourceLine" id="cb15-2" title="2">    sa_family_t  ss_family;     <span class="co">// 주소 계열</span></a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4">    <span class="co">// 이것들은 모두 패딩이고 구현에 특정적인 내용입니다. 무시하십시오.</span></a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="dt">char</span>      __ss_pad1[_SS_PAD1SIZE];</a>
<a class="sourceLine" id="cb15-6" title="6">    <span class="dt">int64_t</span>   __ss_align;</a>
<a class="sourceLine" id="cb15-7" title="7">    <span class="dt">char</span>      __ss_pad2[_SS_PAD2SIZE];</a>
<a class="sourceLine" id="cb15-8" title="8">};</a></code></pre></div><p>중요한 것은 여러분이 <code>ss_family</code> 필드에서 주소 계통을 볼 수 있다는 사실입니다. 그것이 <code>AF_INET</code>또는 <code>AF_INET6</code>인지 확인하십시오(IPv4또는 IPv6인지 확인하기 위해서). 그 뒤 필요하다면 <code>struct sockaddr_in</code> 또는 <code>struct sockaddr_in6</code>으로 형변환할 수 있을 것입니다.</p><h2 id="ip-주소-파트-2"><span class="header-section-number">3.4</span> IP 주소, 파트 2</h2><p>여러분에게는 다행스럽게도,  IP 주소를 다룰 수 있게 해주는 많은 함수가 있습니다. 손으로 직접 종류를 알아내고 <code>long</code>에 <code>&lt;&lt;</code>연산자로 값을 채워넣을 필요가 없습니다.(역자 주 : <code>&lt;&lt;</code>은 비트 옮기기 연산자이며 큰 메모리 영역에 작은 값을 집어넣고자 할 때 흔히 사용한다.)</p><p>우선 여러분이 <code>struct sockaddr_in ina</code>를 가지고 있다고 합시다. 그리고 저장하고 싶은 두개의 주소, “<code>10.12.110.57</code>”와 “<code>2001:db8:63b3:1::3490</code>” 가 있다고 합시다. 여러분이 사용해야 하는 함수는  <code>inet_pton()</code> 입니다. 이것은 숫자와 점 표기법으로 적힌 IP주소를 여러분이 <code>AF_INET</code>또는 <code>AF_INET6</code> 를 지정하는 것에 따라서 <code>struct in_addr</code>또는 <code>struct in6_addr</code>으로 변환합니다. (“<code>pton</code>”는 “presentation to network”(역자 주 : 표현에서 네트워크로)의 약어이며 쉽게 기억하고 싶다면 “printable to network”라고 해도 됩니다.) 변환은 아래와 같이 이루어집니다:</p><div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">struct</span> sockaddr_in sa; <span class="co">// IPv4</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="kw">struct</span> sockaddr_in6 sa6; <span class="co">// IPv6</span></a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4">inet_pton(AF_INET, <span class="st">&quot;10.12.110.57&quot;</span>, &amp;(sa.sin_addr)); <span class="co">// IPv4</span></a>
<a class="sourceLine" id="cb16-5" title="5">inet_pton(AF_INET6, <span class="st">&quot;2001:db8:63b3:1::3490&quot;</span>, &amp;(sa6.sin6_addr)); <span class="co">// IPv6</span></a></code></pre></div><p>(짧은 노트 : 이 일을 하는 예전 방식은  <code>inet_addr()</code>이나  <code>inet_aton()</code>함수를 사용했습니다. 이것들은 이제 구형이고 IPv6과는 동작하지 않습니다.)</p><p>위의 코드 예제는 그다지 견고하지 않은데 오류 확인이 없기 때문입니다. <code>inet_pton()</code> 은 오류가 발생하면 <code>-1</code>을 돌려주고 주소가 엉망이면 0을 돌려줍니다. 그러니 결과물을 사용하기 전에 복귀값이 0보다 큰지 확인하십시오.</p><p>좋습니다. 이제 여러분은 IP주소 문자열을 그것의 이진 표현으로 바꿀 수 있습니다. 반대로는 어떻게 하는지 궁금하신가요? <code>struct in_addr</code>구조체를 가지고 있고 그것의 숫자와 점 표기법을 출력하길 원하신다면 어떻게 해야할까요? (또는 <code>struct in6_addr</code>을, 그러니까… 16진수와 콜론 표기법으로 출력한다면 어떻게 해야할까요?) 이 경우 여러분은  <code>inet_ntop()</code> 을 사용해야 합니다. (“ntop”는 “network to presentation”을 의미하며 쉽게 기억하려면 “network to printable”이라고 부르셔도 됩니다.) 예제는 아래와 같습니다:</p><div class="sourceCode" id="cb17"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1"><span class="co">// IPv4:</span></a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="dt">char</span> ip4[INET_ADDRSTRLEN];  <span class="co">// IPv4 문자열을 담아둘 공간</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="kw">struct</span> sockaddr_in sa;      <span class="co">// 이곳에 무엇인가 담겨있다고 가정하자</span></a>
<a class="sourceLine" id="cb17-5" title="5"></a>
<a class="sourceLine" id="cb17-6" title="6">inet_ntop(AF_INET, &amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN);</a>
<a class="sourceLine" id="cb17-7" title="7"></a>
<a class="sourceLine" id="cb17-8" title="8">printf(<span class="st">&quot;The IPv4 address is: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, ip4);</a>
<a class="sourceLine" id="cb17-9" title="9"></a>
<a class="sourceLine" id="cb17-10" title="10"></a>
<a class="sourceLine" id="cb17-11" title="11"><span class="co">// IPv6:</span></a>
<a class="sourceLine" id="cb17-12" title="12"></a>
<a class="sourceLine" id="cb17-13" title="13"><span class="dt">char</span> ip6[INET6_ADDRSTRLEN]; <span class="co">// IPv6 문자열을 담아둘 공간</span></a>
<a class="sourceLine" id="cb17-14" title="14"><span class="kw">struct</span> sockaddr_in6 sa6;    <span class="co">// 이곳에 무엇인가 담겨있다고 가정하자</span></a>
<a class="sourceLine" id="cb17-15" title="15"></a>
<a class="sourceLine" id="cb17-16" title="16">inet_ntop(AF_INET6, &amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN);</a>
<a class="sourceLine" id="cb17-17" title="17"></a>
<a class="sourceLine" id="cb17-18" title="18">printf(<span class="st">&quot;The address is: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, ip6);</a></code></pre></div><p>이 함수를 호출하려면 주소 종류(IPv4 또는 IPv6)와 주소, 결과를 담을 문자열에 대한 포인터, 그 문자열의 최대 길이를 넘겨줘야 합니다. (두 개의 매크로인 <code>INET_ADDRSTRLEN</code>과 <code>INET6_ADDRSTRLEN</code>이 편리하게도 가장 긴 IPv4또는 IPv6문자열을 담아둘 문자열의 크기를 가지고 있습니다.)</p><p>(이 일을 하는 오래된 방식에 대한 다른 이야기: 이 변환 작업을 하는 역사적인 함수는  <code>inet_ntoa()</code>입니다. 마찬가지로 구식이고 IPv6에는 작동하지 않습니다.)</p><p>마지막으로 이 함수들은 숫자 형태의 IP 주소에만 사용할 수 있습니다. 이 함수들은 “<code>www.example.com</code>”같은 호스트이름에 대한 네임서버 DNS 탐색을 하지 않습니다. 그 작업을 위해서는 다음에 보실 <code>getaddrinfo()</code>을 써야합니다.</p><h3 id="사설또는-분리된-망"><span class="header-section-number">3.4.1</span> 사설(또는 분리된) 망</h3><p> 많은 곳들이 보호를 목적으로 네트워크를 외부로부터 숨기는  방화벽을 가지고 있습니다. 그리고 흔히 이 방화벽들은 <em>Network Address Translation</em> 또는  NAT이라는 절차를 통해서 “내부” IP 주소를 (세상의 다른 사람들이 아는)“외부” IP주소로 변환합니다.</p><p>벌써 긴장되나요? “저 사람은 이 이상한 것들로 무슨 이야기를 하려는거지?”</p><p>진정하고 무알콜(아니면 알콜이 있는)음료수를 준비하세요. NAT은 여러분을 위해서 투명하게 처리되므로(역자 주 : 알 필요가 없게, 보이지 않게) 초보자는 NAT에 대해서 신경쓸 필요도 없습니다. 그러나 저는 여러분이 보는 네트워크 숫자로 인해 헷갈릴 일이 없도록 방화벽 뒤의 네트워크에 대해서 이야기하고 싶었습니다.</p><p>예를 들어 제 집에는 방화벽이 있습니다. 저에게는 디지털 가입자 회선(DSL) 회사가 저에게 배정해 준 두 개의 정적 IPv4주소가 있습니다. 그런데 제 네트워크에 있는 컴퓨터는 일곱 대 입니다. 이것이 어떻게 가능하냐고요? 두 개의 컴퓨터가 같은 아이피를 쓸 수는 없습니다. 그렇게 되면 데이터가 어디로 가야할지 알 수 없게 됩니다.</p><p>답은 이렇습니다: 컴퓨터들은 아이피 주소를 공유하지 않습니다. 그것들은 2천4백만개의 아이피 주소가 할당된 사설 네트워크에 속해 있습니다. 그것들 전체가 저만을 위한 것입니다. 최소한 저에게는 그렇습니다. 원리는 이렇습니다:</p><p>제가 원격 컴퓨터에 로그인하면, 그것은 제가 192.0.2.33에서 로그인했다고 말해줍니다. 그 주소는 제 인터넷 서비스 제공자가 저에게 준 공용 아이피 주소입니다. 그러나 제가 로컬 컴퓨터에게 저의 주소를 물어보면 그것은 10.0.0.5라고 대답합니다. 누가 IP주소를 번역해주는 것일까요? 그렇습니다. 바로 방화벽입니다. 그것이 NAT을 수행하는 것입니다.</p><p><code>10.x.x.x</code>는 완전히 외부와 차단된 네트워크 또는 방화벽 뒤의 네트워크만이 사용하도록 예약된 몇 개의 네트워크 대역 중 하나입니다. 어떤 사설 네트워크 숫자가 사용 가능한지는 <a href="https://tools.ietf.org/html/rfc1918">RFC 1918</a><a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a>에 제시되어 있습니다. 그러나 여러분이 보실 일반적인 것들은  <code>10.x.x.x</code> 또는  <code>192.168.x.x</code>입니다. <code>x</code>에는 보통 0에서 255사이의 수가 들어갑니다. 좀 덜 일반적인 것으로 <code>172.y.x.x</code>가 있습니다. <code>y</code>에는 16부터 31사이의 수가 옵니다.</p><p>NAT동작을 수행하는 방화벽 뒤에 있는 망(네트워크)이 이런 사설 네트워크 중 하나 여야만 하는 것은 <em>아닙니다</em>. 그러나 보통 그런 종류입니다.</p><p>(재미있는 사실! 제 외부 아이피 주소가 실제로 <code>192.0.2.33</code>인 것은 아닙니다. <code>192.0.2.x</code> 네트워크는 문서에 “진짜” 아이피 주소가 쓰였다고 믿게 하기 위해서 예약된 대역입니다. 바로 이 안내서에 쓰인 것 처럼 말입니다! 우왕!)</p><p> IPv6도 어떤 의미로는 사설망을 가지고 있습니다. 그것들은 <code>fdXX:</code>으로 시작합니다. (미래에는 <code>fcXX:</code>으로 시작할 수도 있습니다.) <a href="https://tools.ietf.org/html/rfc4193">RFC 4193</a><a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a> 문서에 따르자면 그렇습니다. 그러나 NAT과 IPv6은 일반적으로 같이 쓰이지 않습니다. (IPv6 to IPv4 게이트웨이(gateway)같은 것을 만들지 않는 다면 말입니다. 그리고 그것은 이 문서의 범위를 넘어섭니다.) 아무튼 이론적으로는 여러분에게는 너무나 많은 주소가 있어서 더이상 NAT을 쓸 필요가 없을 것입니다. 그럼에도 여러분이 외부와 통하지 않는 주소를 할당하고 싶다면, 위에 적은 대역을 쓸 수 있다는 의미입니다.</p><h1 id="ipv4에서-ipv6으로-점프하기"><span class="header-section-number">4</span> IPv4에서 IPv6으로 점프하기</h1><p></p><p>“아무튼 저는 IPv6에서 동작하려면 제 코드의 어디를 바꿔야 하는지 알고싶단 말입니다! 당장 알려주세요!”</p><p>종아요! 좋습니다!</p><p>여기 적을 내용의 대부분은 제가 위에서 다룬 내용들이지만 이것은 참을성 없는 분들을 위한 짧은 버전입니다. (물론 이것보다 더 많은 내용이 있겠지만, 이 안내서에 있는 내용은 이정도입니다.)</p><ol type="1"><li><p>우선 <code>struct sockaddr</code> 정보를 얻어내기 위해서 수작업 대신  <a href="#structs"><code>getaddrinfo()</code></a> 함수를 사용하십시오. 이렇게 하면 여러분은 IP버전에 신경쓰지 않을 수 있고, 뒤따르는 많은 후속 작업을 할 필요가 없게 해 줍니다.</p></li><li><p>IP 버전에 관계된 것을 하드코딩하는 곳을 찾아낼 때마다 헬퍼 함수로 감싸두는 처리를 해 두십시오.</p></li><li><p><code>AF_INET</code>를 <code>AF_INET6</code>로 바꾸십시오.</p></li><li><p><code>PF_INET</code>를 <code>PF_INET6</code>로 바꾸십시오.</p></li><li><p><code>INADDR_ANY</code> 대입을 <code>in6addr_any</code>대입으로 바꾸십시오. 이런 차이가 있습니다:</p><div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">struct</span> sockaddr_in sa;</a>
<a class="sourceLine" id="cb18-2" title="2"><span class="kw">struct</span> sockaddr_in6 sa6;</a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4">sa.sin_addr.s_addr = INADDR_ANY;  <span class="co">// use my IPv4 address</span></a>
<a class="sourceLine" id="cb18-5" title="5">sa6.sin6_addr = in6addr_any; <span class="co">// use my IPv6 address</span></a></code></pre></div><p>또한 <code>struct in6_addr</code>을 선언할 때 <code>IN6ADDR_ANY_INIT</code>을 초기값으로 사용할 수 있습니다. 아래와 같이 합니다.</p><div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">struct</span> in6_addr ia6 = IN6ADDR_ANY_INIT;</a></code></pre></div></li><li><p><code>struct sockaddr_in</code> 대신에 <code>struct sockaddr_in6</code>을 사용하시고, 필요한 필드에 “6”을 적절히 덧붙이십시오. (위의 <a href="#structs"><code>struct</code>s</a>을 참고하십시오) <code>sin6_zero</code>필드는 없습니다.</p></li><li><p><code>struct in_addr</code> 대신에 <code>struct in6_addr</code>를 사용하시고, 필요한 필드에 “6”을 적절히 덧붙이십시오. (위의 <a href="#structs"><code>struct</code>s</a>을 참고하십시오)</p></li><li><p><code>inet_aton()</code>이나 <code>inet_addr()</code> 대신에 <code>inet_pton()</code>을 사용하십시오.</p></li><li><p><code>inet_ntoa()</code> 대신에 <code>inet_ntop()</code>을 사용하십시오.</p></li><li><p><code>gethostbyname()</code>대신에 더 뛰어난 <code>getaddrinfo()</code>를 사용하십시오.</p></li><li><p><code>gethostbyaddr()</code> 대신에 더 뛰어난  <code>getnameinfo()</code>를 사용하십시오. (<code>gethostbyaddr()</code>가 IPv6을 위해서도 여전히 작동하기는 합니다).</p></li><li><p><code>INADDR_BROADCAST</code>는 더 이상 작동하지 않습니다. 대신 IPv6 멀티캐스트를 사용하십시오.</p></li></ol><p><em>끝</em>!</p><h1 id="시스템-콜이-아니면-죽음을"><span class="header-section-number">5</span> 시스템 콜이 아니면 죽음을</h1><p>이 절에서 우리는 유닉스 장치나 기타 소켓 API를 지원하는 다른 장치(BSD, 윈도우즈, 리눅스, 맥, 여러분이 가진 다른 장치)에서 네트워크 기능에 접근할 수 있게 해 주는 시스템 호출(System call)(과 다른 라이브러리 호출 (Library Call))에 대해서 다룰 것입니다. 이런 함수 중 하나를 호출하면 커널이 넘겨받고 여러분을 위해 모든 일을 자동으로 마법같이 처리합니다.</p><p>대부분의 사람들이 어려워하는 점은 이 함수들을 어떤 순서로 호출해야 하는가 입니다. 이미 찾아보셨겠지만 그런 쪽으로는 <code>man</code>페이지는 아무 쓸모도 없습니다. 그 끔찍한 상황을 해결하기 위해 시스템콜들을 <em>정확히</em>(대략) 여러분의 프로그램에서 호출해야 하는 순서 그대로 아래에 이어지는 절들에 제시했습니다.</p><p>그러니까 여기에 있는 몇몇 예제 코드와 우유, 과자(이것들은 직접 준비하셔야 합니다) 그리고 두둑한 배짱과 용기만 있다면 여러분은 인터넷의 세계에서 존 포스텔의 아들처럼 데이터를 나를 수 있게 될 것입니다.(역자 주 : John Postel은 인터넷의 초기에 큰 기여를 한 컴퓨터 과학자 중 한 명입니다.)</p><p><em>(아래의 예제 코드들은 대개 필수적인 에러코드를 간략함을 얻기 위해서 생략했음을 기억하십시오. 그리고 예제 코드들은 대개 <code>getaddrinfo()</code>의 호출이 성공하고 연결리스트로 적절한 결과물을 돌려준다고 가정합니다. 이런 상황은 독립 실행형 프로그램에서는 제대로 처리되어 있으니, 그것들을 지침으로 삼으십시오.)</em></p><h2 id="getaddrinfo발사-준비"><span class="header-section-number">5.1</span> <code>getaddrinfo()</code>—발사 준비!</h2><p>, 이것은 여러 옵션을 가진 진짜 일꾼입니다. 그러나 사용법은 사실 꽤 간단합니다. 이것은 여러분이 나중에 필요로 하는 <code>struct</code>들을 초기화합니다.</p><p>역사 한토막 : 예전에는 DNS 검색을 위해서 <code>gethostbyname()</code>을 호출해야 했습니다. 그리고 그 정보를 수작업으로 <code>struct sockaddr_in</code>에 담고 이후의 호출에서 사용해야 했습니다.</p><p>고맙게도 더 이상은 그럴 필요가 없습니다. (여러분이 IPv4와 IPv6환경 모두에서 동작하는 코드를 짜고싶다면 그래서도 안 됩니다!) 요새는 <code>getaddrinfo()</code>이라는 것이 있어서 DNS 와 서비스 이름 검색, <code>struct</code>내용 채워넣기 등을 포함해서 여러분이 필요로 하는 모든 일을 해 줍니다.</p><p>이제 살펴봅시다!</p><p>(역자 주 : 아래에서부터 입니다, 하세요 등의 표현 대신 이다, 하라 등의 간결한 어미를 섞어서 씁니다.)</p><div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="dt">int</span> getaddrinfo(<span class="dt">const</span> <span class="dt">char</span> *node,     <span class="co">// e.g. &quot;www.example.com&quot; 또ㅡㄴ IP</span></a>
<a class="sourceLine" id="cb20-6" title="6">                <span class="dt">const</span> <span class="dt">char</span> *service,  <span class="co">// e.g. &quot;http&quot; 또는 포트 숫자를 &quot;&quot;안에 감싸서 넣는다.</span></a>
<a class="sourceLine" id="cb20-7" title="7">                <span class="dt">const</span> <span class="kw">struct</span> addrinfo *hints,</a>
<a class="sourceLine" id="cb20-8" title="8">                <span class="kw">struct</span> addrinfo **res);</a></code></pre></div><p>이 함수에는 3개의 입력 매개변수를 넘겨줍니다. 그리고 결과 연결리스트의 포인터인 <code>res</code>를 돌려받습니다.</p><p><code>node</code>매개변수는 접속하려는 호스트 이름이나 IP주소입니다.</p><p>다음 매개변수는 <code>service</code>입니다. 이것은 “80”같은 포트 번호나 “http”, “ftp”, “telnet” 또는 “smtp”같은 특정한 서비스 이름이 될 수 있습니다. (<a href="https://www.iana.org/assignments/port-numbers">IANA 포트 목록</a><a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a> 혹은 여러분이 유닉스 장치를 쓴다면 <code>/etc/services</code>에서 볼 수 있습니다)</p><p>마지막으로 <code>hints</code>매개변수는 여러분이 관련된 정보로 이미 채워넣은 <code>struct addrinfo</code> 를 가리킵니다.</p><p>여기에 여러분이 호스트 IP주소의 포트 3490을 듣고자 할 때의 함수 호출 예제가 있습니다. 이것이 듣기 작업이나 네트워크 설정을 하지는 않음을 기억하십시오. 이것은 단지 나중에 사용할 구조체들을 설정할 뿐입니다.</p><div class="sourceCode" id="cb21"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="dt">int</span> status;</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="kw">struct</span> addrinfo hints;</a>
<a class="sourceLine" id="cb21-3" title="3"><span class="kw">struct</span> addrinfo *servinfo;  <span class="co">// 결과를 가리킬 것이다</span></a>
<a class="sourceLine" id="cb21-4" title="4"></a>
<a class="sourceLine" id="cb21-5" title="5">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints); <span class="co">// 구조체를 확실히 비워두라</span></a>
<a class="sourceLine" id="cb21-6" title="6">hints.ai_family = AF_UNSPEC;     <span class="co">// IPv4 이든 IPv6 이든 상관없다</span></a>
<a class="sourceLine" id="cb21-7" title="7">hints.ai_socktype = SOCK_STREAM; <span class="co">// TCP 스트림 소켓</span></a>
<a class="sourceLine" id="cb21-8" title="8">hints.ai_flags = AI_PASSIVE;     <span class="co">// 내 주소를 넣어달라</span></a>
<a class="sourceLine" id="cb21-9" title="9"></a>
<a class="sourceLine" id="cb21-10" title="10"><span class="cf">if</span> ((status = getaddrinfo(NULL, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb21-11" title="11">    fprintf(stderr, <span class="st">&quot;getaddrinfo error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(status));</a>
<a class="sourceLine" id="cb21-12" title="12">    exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb21-13" title="13">}</a>
<a class="sourceLine" id="cb21-14" title="14"></a>
<a class="sourceLine" id="cb21-15" title="15"><span class="co">// servinfo는 이제 1개 혹은 그 이상의 addrinfo 구조체에 대한 연결리스트를 가리킨다</span></a>
<a class="sourceLine" id="cb21-16" title="16"></a>
<a class="sourceLine" id="cb21-17" title="17"><span class="co">// ... servinfo가 더이상 필요없을 때까지 모든 작업을 한다...</span></a>
<a class="sourceLine" id="cb21-18" title="18"></a>
<a class="sourceLine" id="cb21-19" title="19">freeaddrinfo(servinfo); <span class="co">// 연결리스트를 해제</span></a></code></pre></div><p><code>ai_family</code>을 <code>AF_UNSPEC</code>으로 설정해서 IPv4든 IPv6이든 신경쓰지 않음을 나타낸 것에 주목하라. 만약 특정한 하나를 원한다면 <code>AF_INET</code>이나 <code>AF_INET6</code>을 쓸 수 있다.</p><p><code>AI_PASSIVE</code>도 볼 수 있다. 이것은 <code>getaddrinfo()</code>에게 소켓 구조체에 내 로컬 호스트의 주소를 할당해달라고 말해준다. 이것은 여러분이 하드코딩할 필요를 없애주기에 좋다. (아니면 위에서 <code>NULL</code>을 넣은 <code>getaddrinfo()</code>의 첫 번째 매개변수에 특정한 주소를 넣을 수 있다. )</p><p>이렇게 함수를 호출한다. 오류가 있다면(<code>getaddrinfo()</code>이 0이 아닌 값을 돌려준다면) 보다시피 그 오류를 <code>gai_strerror()</code>함수를 통해서 출력할 수 있다. 만약 모든 것이 제대로 동작한다면 <code>servinfo</code>는 각각이 우리가 나중에 쓸 수 있는 <code>struct sockaddr</code>나 비슷한 것을 가진 <code>struct addrinfo</code>의 연결리스트를 가리킬 것이다. 멋지다!</p><p>마지막으로 <code>getaddrinfo()</code>가 은혜롭게 우리에게 할당해 준 연결리스트를 다 썼다면 우리는 <code>freeaddrinfo()</code>을 호출해서 그것을 할당 해제할 수 있습니다. (반드시 해야합니다.)</p><p>여기에 여러분이 특정한 주소, 예를 들어 “www.example.net”의 3490포트에 잡속하고자 하는 클라이언트일 경우의 호출 예제가 있습니다. 다시 말씀드리지만 이것으로는 실제 연결이 이루어지지 않습니다. 그러나 이것은 우리가 나중에 사용할 구조체를 설정해줍니다.</p><div class="sourceCode" id="cb22"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="dt">int</span> status;</a>
<a class="sourceLine" id="cb22-2" title="2"><span class="kw">struct</span> addrinfo hints;</a>
<a class="sourceLine" id="cb22-3" title="3"><span class="kw">struct</span> addrinfo *servinfo;  <span class="co">// 결과물을 가리킬 것임</span></a>
<a class="sourceLine" id="cb22-4" title="4"></a>
<a class="sourceLine" id="cb22-5" title="5">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints); <span class="co">// 반드시 비워둘 것</span></a>
<a class="sourceLine" id="cb22-6" title="6">hints.ai_family = AF_UNSPEC;     <span class="co">// IPv4나 IPv6은 신경쓰지 않음</span></a>
<a class="sourceLine" id="cb22-7" title="7">hints.ai_socktype = SOCK_STREAM; <span class="co">// TCP 스트림 소켓</span></a>
<a class="sourceLine" id="cb22-8" title="8"></a>
<a class="sourceLine" id="cb22-9" title="9"><span class="co">// 연결 준비</span></a>
<a class="sourceLine" id="cb22-10" title="10">status = getaddrinfo(<span class="st">&quot;www.example.net&quot;</span>, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;servinfo);</a>
<a class="sourceLine" id="cb22-11" title="11"></a>
<a class="sourceLine" id="cb22-12" title="12"><span class="co">// servinfo는 이제 1개 혹은 그 이상의 addrinfo 구조체에 대한 연결리스트를 가리킨다</span></a>
<a class="sourceLine" id="cb22-13" title="13"></a>
<a class="sourceLine" id="cb22-14" title="14"><span class="co">// 등등.</span></a></code></pre></div><p><code>servinfo</code>은 모든 종류의 주소 정보를 가진 연결리스트라고 계속 이야기하고 있다. 이 정보를 보기 위한 짧은 시연 프로그램을 작성해보자. <a href="https://beej.us/guide/bgnet/examples/showip.c">이 짧은 프로그램</a><a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a> 은 여러분이 명령줄에 적는 호스트의 IP주소들을 출력한다.</p><div class="sourceCode" id="cb23"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="co">** showip.c -- 명령줄에서 주어진 호스트의 주소들을 출력한다.</span></a>
<a class="sourceLine" id="cb23-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb23-4" title="4"></a>
<a class="sourceLine" id="cb23-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb23-6" title="6"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb23-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb23-8" title="8"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb23-9" title="9"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb23-10" title="10"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb23-11" title="11"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb23-12" title="12"></a>
<a class="sourceLine" id="cb23-13" title="13"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb23-14" title="14">{</a>
<a class="sourceLine" id="cb23-15" title="15">    <span class="kw">struct</span> addrinfo hints, *res, *p;</a>
<a class="sourceLine" id="cb23-16" title="16">    <span class="dt">int</span> status;</a>
<a class="sourceLine" id="cb23-17" title="17">    <span class="dt">char</span> ipstr[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb23-18" title="18"></a>
<a class="sourceLine" id="cb23-19" title="19">    <span class="cf">if</span> (argc != <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb23-20" title="20">        fprintf(stderr,<span class="st">&quot;usage: showip hostname</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb23-21" title="21">        <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb23-22" title="22">    }</a>
<a class="sourceLine" id="cb23-23" title="23"></a>
<a class="sourceLine" id="cb23-24" title="24">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb23-25" title="25">    hints.ai_family = AF_UNSPEC; <span class="co">// 버전을 지정하려면 AF_INET또는 AF_INET6을 사용</span></a>
<a class="sourceLine" id="cb23-26" title="26">    hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb23-27" title="27"></a>
<a class="sourceLine" id="cb23-28" title="28">    <span class="cf">if</span> ((status = getaddrinfo(argv[<span class="dv">1</span>], NULL, &amp;hints, &amp;res)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb23-29" title="29">        fprintf(stderr, <span class="st">&quot;getaddrinfo: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(status));</a>
<a class="sourceLine" id="cb23-30" title="30">        <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb23-31" title="31">    }</a>
<a class="sourceLine" id="cb23-32" title="32"></a>
<a class="sourceLine" id="cb23-33" title="33">    printf(<span class="st">&quot;IP addresses for %s:</span><span class="sc">\n\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb23-34" title="34"></a>
<a class="sourceLine" id="cb23-35" title="35">    <span class="cf">for</span>(p = res;p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb23-36" title="36">        <span class="dt">void</span> *addr;</a>
<a class="sourceLine" id="cb23-37" title="37">        <span class="dt">char</span> *ipver;</a>
<a class="sourceLine" id="cb23-38" title="38"></a>
<a class="sourceLine" id="cb23-39" title="39">        <span class="co">// 주소 자체에 대한 포인터를 받는다. IPv4와 IPv6은 필드가 다르다.</span></a>
<a class="sourceLine" id="cb23-40" title="40">        <span class="cf">if</span> (p-&gt;ai_family == AF_INET) { <span class="co">// IPv4</span></a>
<a class="sourceLine" id="cb23-41" title="41">            <span class="kw">struct</span> sockaddr_in *ipv4 = (<span class="kw">struct</span> sockaddr_in *)p-&gt;ai_addr;</a>
<a class="sourceLine" id="cb23-42" title="42">            addr = &amp;(ipv4-&gt;sin_addr);</a>
<a class="sourceLine" id="cb23-43" title="43">            ipver = <span class="st">&quot;IPv4&quot;</span>;</a>
<a class="sourceLine" id="cb23-44" title="44">        } <span class="cf">else</span> { <span class="co">// IPv6</span></a>
<a class="sourceLine" id="cb23-45" title="45">            <span class="kw">struct</span> sockaddr_in6 *ipv6 = (<span class="kw">struct</span> sockaddr_in6 *)p-&gt;ai_addr;</a>
<a class="sourceLine" id="cb23-46" title="46">            addr = &amp;(ipv6-&gt;sin6_addr);</a>
<a class="sourceLine" id="cb23-47" title="47">            ipver = <span class="st">&quot;IPv6&quot;</span>;</a>
<a class="sourceLine" id="cb23-48" title="48">        }</a>
<a class="sourceLine" id="cb23-49" title="49"></a>
<a class="sourceLine" id="cb23-50" title="50">        <span class="co">// IP주소를 문자열로 변환하고 출력한다.</span></a>
<a class="sourceLine" id="cb23-51" title="51">        inet_ntop(p-&gt;ai_family, addr, ipstr, <span class="kw">sizeof</span> ipstr);</a>
<a class="sourceLine" id="cb23-52" title="52">        printf(<span class="st">&quot;  %s: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, ipver, ipstr);</a>
<a class="sourceLine" id="cb23-53" title="53">    }</a>
<a class="sourceLine" id="cb23-54" title="54"></a>
<a class="sourceLine" id="cb23-55" title="55">    freeaddrinfo(res); <span class="co">// 연결 목록을 해제한다.</span></a>
<a class="sourceLine" id="cb23-56" title="56"></a>
<a class="sourceLine" id="cb23-57" title="57">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb23-58" title="58">}</a></code></pre></div><p>보다시피 이 코드는 당신이 명령줄에 넘기는 것이 무엇이든 <code>getaddrinfo()</code>을 호출한다. 그리고 <code>res</code>에 연결목록의 포인터를 넘겨준다. 그래서 우리는 이 목록을 순회해서 출력하거나 다른 일을 할 수 있다.</p><p>(저 예제코드에는 IP 버전에 따라 다른 종류의 <code>struct sockaddr</code>을 처리해야 하는 흉한 부분이 있다. 그 점에 대해서 사과한다. 그러나 더 나은 방법이 있는지는 모르겠다.)</p><p>실행 예제! 모두가 스크린샷을 좋아합니다.</p><pre><code>$ showip www.example.net
IP addresses for www.example.net:

  IPv4: 192.0.2.88

$ showip ipv6.example.com
IP addresses for ipv6.example.com:

  IPv4: 192.0.2.101
  IPv6: 2001:db8:8c00:22::171</code></pre><p>이제 저것을 다룰 수 있으니, <code>getaddrinfo()</code>에서 얻은 결과를 다른 소켓 함수에 넘기고 결과적으로는 네트워크 연결을 성립할 수 있도록 해 보자! 계속 읽어보라!</p><h2 id="socket"><span class="header-section-number">5.2</span> <code>socket()</code>—파일 설명자를 받아오라!</h2><p>더 이상 미룰 수가 없을 듯 하다. 이제  <code>socket()</code> 시스템 콜에 대해서 이야기해야 한다. 개요는 이렇다.</p><div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb25-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb25-3" title="3"></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="dt">int</span> socket(<span class="dt">int</span> domain, <span class="dt">int</span> type, <span class="dt">int</span> protocol); </a></code></pre></div><p>그러나 이 인수들이 무엇인지 모를 것이다. 이것들은 어떤 종류의 소켓을 원하는지 정할 수 있게 해 준다.(IPv4 또는 IPv6, 스트림 혹은 데이터그램, TCP 혹은 UDP)</p><p>사용자들이 그 값을 직접 적어야 했고, 지금도 그렇게 할 수 있다. (<code>domain</code>은 <code>PF_INET</code>이나 <code>PF_INET6</code>이고, <code>type</code>은 <code>SOCK_STREAM</code>또는 <code>SOCK_DGRAM</code> 이며, <code>protocol</code>은 주어진 <code>type</code>에 적절한 값을 자동으로 선택하게 하려면 <code>0</code>을 넘겨주거나 “tcp”나 “udp” 중 원하는 프로토콜의 값을 얻기 위해서 <code>getprotobyname()</code> 을 쓸 수도 있다.)</p><p>(이 <code>PF_INET</code>은 <code>sin_family</code>필드에 넣어주는 <code>AF_INET</code>와 유사한 것이다. 이것을 이해하려면 짧은 이야기가 필요하다. 아주 먼 옛날에는 어쩌면 하나의 주소 체통(Address Family) (“<code>AF_INET</code>”안에 들어있는 “AF”)가 여러 종류의 프로토콜 계통(Protocol Family)(“<code>PF_INET</code>”의 “PF”))을 지원할 것이라고 생각하던 시절이 있었다. 그런 일은 일어나지 않았다. 그리고 모두 행복하게 오래오래 잘 살았다. 이런 이야기다. 그래서 할 수 있는 가장 정확한 일은 <code>struct sockaddr_in</code>에서 <code>AF_INET</code>을 쓰고 <code>socket()</code>에서 <code>PF_INET</code>을 사용하는 것이다.</p><p>아무튼 이제 충분하다. 여러분이 정말로 하고싶은 일은 <code>getaddrinfo()</code>을 호출한 결과로 돌아오는 값을 아래와 같이 <code>socket()</code>에 직접 넘겨주는 것이다.</p><div class="sourceCode" id="cb26"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1"><span class="dt">int</span> s;</a>
<a class="sourceLine" id="cb26-2" title="2"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb26-3" title="3"></a>
<a class="sourceLine" id="cb26-4" title="4"><span class="co">// 탐색 시작</span></a>
<a class="sourceLine" id="cb26-5" title="5"><span class="co">// [&quot;hints&quot;구조체는 이미 채운 것으로 친다]</span></a>
<a class="sourceLine" id="cb26-6" title="6">getaddrinfo(<span class="st">&quot;www.example.com&quot;</span>, <span class="st">&quot;http&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb26-7" title="7"></a>
<a class="sourceLine" id="cb26-8" title="8"><span class="co">// 다시 말하지면 원래는 (이 안내서의 예제들이 하듯이) 첫 번째 것이 좋다고</span></a>
<a class="sourceLine" id="cb26-9" title="9"><span class="co">// 가정하는 대신 getaddrinfo()에 대해서 오류 확인을 하고</span></a>
<a class="sourceLine" id="cb26-10" title="10"><span class="co">// &quot;res&quot;링크드 리스트를 순회해야 한다.</span></a>
<a class="sourceLine" id="cb26-11" title="11"><span class="co">// client/server절의 진짜 예제들을 참고하라.</span></a>
<a class="sourceLine" id="cb26-12" title="12"></a>
<a class="sourceLine" id="cb26-13" title="13">s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a></code></pre></div><p><code>socket()</code>은 단순하게 이후의 시스템 호출에서 쓸 수 있는 <em>소켓 설명자</em> 를 돌려준다. 오류가 있으면 -1을 돌려준다. 전역 변수인 <code>errno</code>가 오류의 값으로 설정된다. (자세한 정보는 <a href="#errnoman"><code>errno</code></a> 의 맨페이지를 참고하라.)</p><p>좋다. 그러면 이제 이 소켓을 어디에 쓰는가? 정답은 아직 못 쓴다는 것이다. 실제로 쓰기 위해서는 안내서를 더 읽고 이것이 동작하게 하기 위한 시스템 호출을 더 해야 한다.</p><h2 id="bind"><span class="header-section-number">5.3</span> <code>bind()</code>—나는 어떤 포트에 있는가?</h2><p> 소켓을 가지면 여러분의 기계의  포트에 연동하고 싶을 것이다. (이 작업은 보통 여러분이  <code>listen()</code> 으로 특정 포트에서 들어오는 연결을 듣고자(listen) 할 때 이루어진다. —다중 사용자 네트워크 게임들은 “192.168.5.10의 3490포트에 연결합니다”라고 말할 때 이런 작업을 한다.) 포트 번호는 커널이 특정 프로세스의 소켓 설명자를 들어오는 패킷과 연관짓기 위해서 사용한다. 만약 여러분이  <code>connect()</code>만 할 생각이라면 <code>bind()</code>는 불필요하다. 그러나 재미를 위해 읽어두자.</p><p>이것이 <code>bind()</code> 시스템 콜의 개요다.</p><div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb27-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb27-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb27-3" title="3"></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="dt">int</span> bind(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *my_addr, <span class="dt">int</span> addrlen);</a></code></pre></div><p><code>sockfd</code>은 <code>socket()</code>이 돌려준 소켓 파일 설명자이다. <code>my_addr</code>은 여러분의 주소, 말하자면 포트와  IP주소를 가진 <code>struct sockaddr</code> 에 대한 포인터이다. <code>addrlen</code>은 그 주소의 바이트 단위 길이이다.</p><p>으엑. 한 번에 많이 배웠다. 프로그램이 실행되는 호스트의 3490번 포트에 소켓을 바인드하는 예제를 보자.</p><div class="sourceCode" id="cb28"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb28-2" title="2"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb28-3" title="3"></a>
<a class="sourceLine" id="cb28-4" title="4"><span class="co">// 먼저 getaddrinfo()으로 구조체에 정보를 불러온다.</span></a>
<a class="sourceLine" id="cb28-5" title="5"></a>
<a class="sourceLine" id="cb28-6" title="6">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb28-7" title="7">hints.ai_family = AF_UNSPEC;  <span class="co">// IPv4나 IPv6 중 아무 것이나 쓴다</span></a>
<a class="sourceLine" id="cb28-8" title="8">hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb28-9" title="9">hints.ai_flags = AI_PASSIVE;     <span class="co">// IP는 나의 아이피로 채운다.</span></a>
<a class="sourceLine" id="cb28-10" title="10"></a>
<a class="sourceLine" id="cb28-11" title="11">getaddrinfo(NULL, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb28-12" title="12"></a>
<a class="sourceLine" id="cb28-13" title="13"><span class="co">// 소켓을 만든다.</span></a>
<a class="sourceLine" id="cb28-14" title="14"></a>
<a class="sourceLine" id="cb28-15" title="15">sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb28-16" title="16"></a>
<a class="sourceLine" id="cb28-17" title="17"><span class="co">// getaddrinfo()에 넘겼던 포트에 바인드한다.</span></a>
<a class="sourceLine" id="cb28-18" title="18"></a>
<a class="sourceLine" id="cb28-19" title="19">bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a></code></pre></div><p><code>AI_PASSIVE</code>플래그를 써서 프로그램에게 실행중인 호스트의 IP에 바인드하라고 알려줍니다. 특정한 로컬 IP주소에 바인드하고싶다면 <code>AI_PASSIVE</code>을 버리고 <code>getaddrinfo()</code>의 첫 번째 인수로 IP주소를 넣으라.</p><p><code>bind()</code>도 오류가 발생하면 <code>-1</code>을 돌려주고 <code>errno</code>을 오류의 값으로 설정한다.</p><p>많은 오래된 코드들이 <code>bind()</code>을 호출하기 전에 <code>struct sockaddr_in</code>을 직접 채워넣는다. 이것은 분명히 IPv4 전용이지만 같은 일을 IPv6에 대해서도 못 할 이유는 없다. 단지 <code>getaddrinfo()</code>을 쓰는 편이 일반적으로 더 쉽다. 어쨌든 예전 코드는 이런 방식이다.</p><div class="sourceCode" id="cb29"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1"><span class="co">// !!! 이것은 예전 방식이다 !!!</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb29-4" title="4"><span class="kw">struct</span> sockaddr_in my_addr;</a>
<a class="sourceLine" id="cb29-5" title="5"></a>
<a class="sourceLine" id="cb29-6" title="6">sockfd = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb29-7" title="7"></a>
<a class="sourceLine" id="cb29-8" title="8">my_addr.sin_family = AF_INET;</a>
<a class="sourceLine" id="cb29-9" title="9">my_addr.sin_port = htons(MYPORT);     <span class="co">// short, 네트워크 바이트 순서</span></a>
<a class="sourceLine" id="cb29-10" title="10">my_addr.sin_addr.s_addr = inet_addr(<span class="st">&quot;10.12.110.57&quot;</span>);</a>
<a class="sourceLine" id="cb29-11" title="11">memset(my_addr.sin_zero, &#39;\<span class="dv">0</span>&#39;, <span class="kw">sizeof</span> my_addr.sin_zero);</a>
<a class="sourceLine" id="cb29-12" title="12"></a>
<a class="sourceLine" id="cb29-13" title="13">bind(sockfd, (<span class="kw">struct</span> sockaddr *)&amp;my_addr, <span class="kw">sizeof</span> my_addr);</a></code></pre></div><p>위의 코드에서 당신의 로컬 IP 주소에 바인드하고 싶었다면(위의 <code>AI_PASSIVE</code>처럼) <code>s_addr</code>필드에 <code>INADDR_ANY</code>을 대입할 수 있다. IPv6버전의 <code>INADDR_ANY</code>은 당신의 <code>struct sockaddr_in6</code>의 <code>sin6_addr</code>필드에 대입해야 하는 전역변수인 <code>in6addr_any</code>이다. (변수 초기화식에 쓸 수 있는 <code>IN6ADDR_ANY_INIT</code>이라는 매크로도 있다.)</p><p><code>bind()</code>을 쓸 때 주의해야 할 것 : 포트 번호는 낮은 것을 쓰지 말 것.  1024번 아래의 모든 포트는 예약되어 있다(슈퍼유저가 아닌 이상)! 그 위의 포트 번호는 (다른 프로그램이 이미 쓰고 있지 않다면) 65535까지 아무 것이나 쓸 수 있다.</p><p>눈치챌 수 있듯이 때때로 서버를 다시 실행하려고 하면 <code>bind()</code>가 실패하고  “주소가 이미 사용중입니다..”라고 할 때가 있다. 그것은 연결되었던 소켓 중 일부가 여전히 커널에서 대기중이고 포트를 사용하고 있다는 것을 의미한다. 여러분은 그것이 정리될 때까지 1분 정도를 기다리거나 당신의 프로그램이 포트를 재사용할 수 있도록 하는 코드를 넣을 수도 있다.</p><p> </p><div class="sourceCode" id="cb30"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="dt">int</span> yes=<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb30-2" title="2"><span class="co">//char yes=&#39;1&#39;; // 솔라리스는 이것을 사용</span></a>
<a class="sourceLine" id="cb30-3" title="3"></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="co">// &quot;주소가 이미 사용중입니다&quot;라는 오류 메시지를 제거</span></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="cf">if</span> (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&amp;yes,<span class="kw">sizeof</span> yes) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb30-6" title="6">    perror(<span class="st">&quot;setsockopt&quot;</span>);</a>
<a class="sourceLine" id="cb30-7" title="7">    exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb30-8" title="8">} </a></code></pre></div><p> <code>bind()</code>에 대해서 한마디 더: 이 함수를 호출할 필요가 전혀 없는 경우도 있습니다.  <code>connect()</code>를 호출해서 원격 장치에 연결하려고 하고, 로컬 포트에 대해서는 신경쓰지 않는다면(<code>telnet</code>의 경우 처럼 원격지 포트만 신경쓰는 경우) <code>connect()</code>가 자동으로 소켓이 바인드되지 않았는지 확인하고 필요하다면 사용하지 않은 로컬 포트에 <code>bind()</code>해줄 것입니다.</p><h2 id="connect"><span class="header-section-number">5.4</span> <code>connect()</code>—이봐, 안녕!</h2><p> 몇 분만 여러분이 텔넷 응용프로그램이 되었다고 생각해봅시다. 여러분의 사용자들이 소켓 파일 설명자를 얻기 위해서 여러분에게 명령을 내립니다 (영화  <em>트론</em> 에서처럼요). 여러분은 그에 따라 <code>socket()</code>을 호출합니다. 다음으로 사용자가 여러분에게 “<code>10.12.110.57</code>”의 “<code>23</code>”번 포트(텔넷 표준 포트)에 연결하라고 합니다. 어떻게 해야할까요?</p><p>응용프로그램 여러분, <code>connect()</code>에 대한 절을 읽는 중이라니 운이 좋습니다! 이 절은 원격 호스트에 어떻게 연결하는지에 대해 알려줍니다. 거침없이 읽어봅시다! 낭비할 시간이 없습니다!</p><p><code>connect()</code>에 대한 호출은 아래와 같습니다:</p><div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb31-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb31-3" title="3"></a>
<a class="sourceLine" id="cb31-4" title="4"><span class="dt">int</span> connect(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *serv_addr, <span class="dt">int</span> addrlen); </a></code></pre></div><p><code>sockfd</code>는 <code>socket()</code>함수 호출이 돌려주는 우리의 친근한 이웃인 소켓 파일 설명자 입니다. <code>serv_addr</code>는 <code>struct sockaddr</code>이고 목적지 포트와 아이피 주소를 담고 있습니다. <code>addrlen</code>은 서버 주소 구조체의 바이트단위 길이를 담고 있습니다.</p><p>모든 정보는 멋진 <code>getaddrinfo()</code>호출의 결과에서 추출할 수 있습니다.</p><p>이해가 되기 시작합니까? 여기서는 대답을 들을 수 없으니 그럴 것이라 생각하겠습니다. “<code>www.example.com</code>”의 <code>3490</code>포트로 소켓 연결을 만드는 예제를 살펴봅시다:</p><div class="sourceCode" id="cb32"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb32-2" title="2"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb32-3" title="3"></a>
<a class="sourceLine" id="cb32-4" title="4"><span class="co">// getaddrinfo()으로 주소 구조체를 채웁니다:</span></a>
<a class="sourceLine" id="cb32-5" title="5"></a>
<a class="sourceLine" id="cb32-6" title="6">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb32-7" title="7">hints.ai_family = AF_UNSPEC;</a>
<a class="sourceLine" id="cb32-8" title="8">hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb32-9" title="9"></a>
<a class="sourceLine" id="cb32-10" title="10">getaddrinfo(<span class="st">&quot;www.example.com&quot;</span>, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb32-11" title="11"></a>
<a class="sourceLine" id="cb32-12" title="12"><span class="co">// 소켓을 만듭니다:</span></a>
<a class="sourceLine" id="cb32-13" title="13"></a>
<a class="sourceLine" id="cb32-14" title="14">sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb32-15" title="15"></a>
<a class="sourceLine" id="cb32-16" title="16"><span class="co">// 연결합니다!</span></a>
<a class="sourceLine" id="cb32-17" title="17"></a>
<a class="sourceLine" id="cb32-18" title="18">connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a></code></pre></div><p>다시 이야기하자면 구식 프로그램들은 <code>connect()</code>에 넘겨줄 <code>struct sockaddr_in</code> 을 직접 채워넣었습니다. 그렇게 하고싶다면 해도 됩니다. 위에 있는 <a href="#bind"><code>bind()</code> 절</a> 에서 비슷한 내용을 참고하십시오.</p><p><code>connect()</code>의 복귀값을 확인하는 것을 잊지 마십시오. 오류가 발생하면 <code>-1</code>을 돌려주고 <code>errno</code>변수를 설정할 것입니다.</p><p></p><p>우리가 <code>bind()</code>를 호출하지 않았음에 주목하십시오. 간단히 말하자면 우리의 로컬 포트 번호에 대해서는 신경쓰지 않습니다. 우리가 어디로 가는지만 신경씁니다 (원격지 포트). 커널이 우리 대신 로컬 포트를 고를 것입니다. 우리가 접속하는 사이트는 이 정보를 자동으로 우리에게서 얻어냅니다. 신경쓰실 필요가 없습니다.</p><h2 id="listen"><span class="header-section-number">5.5</span> <code>listen()</code>—누가 연락 좀 해주실래요?</h2><p> 이제 흐름이 변할 때입니다. 우리가 원격지 호스트에 접속하고 싶지 않은 경우라면 어떻게 하시겠습니까? 재미로 하는 말이지만, 들어오는 연결을 기다리고 그것을 어떤 방식으로 다루고자 한다면 어떻게 하시겠습니까? 그 과정은 두 단계입니다. 먼저 <code>listen()</code>를 호출하고,  <code>accept()</code>를 씁니다.(아래를 참고하십시오.)</p><p><code>listen()</code>함수 호출은 꽤 단순하지만 약간의 설명이 필요합니다:</p><div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb33-1" title="1"><span class="dt">int</span> listen(<span class="dt">int</span> sockfd, <span class="dt">int</span> backlog); </a></code></pre></div><p><code>sockfd</code>은 <code>socket()</code>시스템 함수 호출로 얻어온 평범한 소켓 파일 설명자입니다.  <code>backlog</code>는 들어오는 큐에 허용되는 연결의 숫자입니다. 이것이 무슨 뜻인지 궁금하십니까? 들어오는 연결들은 여러분이 <code>accept()</code>를 해주기 전까지(아래를 참고하십시오) 이 큐 안에서 기다릴 것이고 이것은 몇 개의 연결이 대기할 수 있는가를 정합니다. 대개의 시스템은 이 값을 조용히 20 정도로 제한합니다. 그러나 <code>5</code>나 <code>10</code>정도의 값으로 설정해도 괜찮을 것입니다.</p><p>또 평소와 다름없이 <code>listen()</code>도 오류가 발생할 경우 <code>-1</code>을 돌려주고 <code>errno</code>을 설정할 것입니다.</p><p>아마도 상상하실 수 있겠지만 서버가 특정 포트에서 실행되도록 하기 위해서는 <code>listen()</code>을 호출하기 전에 <code>bind()</code>을 호출해야 합니다. (여러분의 친구들에게 어떤 포트로 연결해야 할지 말해줄 수 있어야 합니다.) 이런 식입니다.</p><div class="sourceCode" id="cb34"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb34-1" title="1">getaddrinfo();</a>
<a class="sourceLine" id="cb34-2" title="2">socket();</a>
<a class="sourceLine" id="cb34-3" title="3">bind();</a>
<a class="sourceLine" id="cb34-4" title="4">listen();</a>
<a class="sourceLine" id="cb34-5" title="5"><span class="co">/* accept()는 아래에 온다 */</span> </a></code></pre></div><p>I’ll just leave that in the place of sample code, since it’s fairly self-explanatory. (The code in the <code>accept()</code> section, below, is more complete.) The really tricky part of this whole sha-bang is the call to <code>accept()</code>.</p><h2 id="accept3490포트에-접속해주셔서-감사합니다.."><span class="header-section-number">5.6</span> <code>accept()</code>—“3490포트에 접속해주셔서 감사합니다..”</h2><p> 각오하십시오! <code>accept()</code>함수는 조금 이상합니다. 이렇게 돌아갑니다: 아주 먼 곳에 있는 누군가가 여러분의 장치에 <code>connect()</code> 함수로 연결하려고 합니다. 여러분은 특정 포트에서 <code>listen()</code>을 실행하고 있습니다. 그들의 연결은 <code>accept()</code>로 받아들여질 때까지 대기열에 쌓일 것입니다. 여러분은 <code>accept()</code>을 해서 대기중인 연결을 받아들이겠다고 알려줍니다. <code>accept()</code>는 이 연결만을 위해서 쓸 <em>완전히 새로운 소켓 파일 설명자</em> 를 돌려줄 것입니다. 그렇습니다! 갑자기 <code>send()</code>와 <code>recv()</code>를 쓸 수 있는 <em>두 개</em> 의 소켓 파일을 가지게 된 것입니다.</p><p>호출은 아래와 같이 합니다:</p><div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb35-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb35-3" title="3"></a>
<a class="sourceLine" id="cb35-4" title="4"><span class="dt">int</span> accept(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *addr, socklen_t *addrlen); </a></code></pre></div><p><code>sockfd</code>은 <code>listen()</code>을 하고있는 소켓 설명자입니다. 어렵지 않습니다. <code>addr</code>은 대개 로컬 <code>struct sockaddr_storage</code>에 대한 포인터입니다. 여기에 들어오는 연결의 정보가 들어가게 됩니다(그리고 그것을 통해서 어떤 호스트가 어떤 포트에서 여러분을 호출하고 있는지 알 수 있습니다.) <code>addrlen</code>은 sockaddr_storage을 <code>accept()</code>에 넘기기 전에 <code>sizeof(struct sockaddr_storage)</code>으로 설정되어야 하는 로컬 정수 변수입니다. <code>accept()</code>는 <code>addr</code>에 <code>addrlen</code>의 크기 이상의 바이트를 적지 않을 것입니다. 예상하셨습니까? <code>accept()</code>도 오류가 발생하면 <code>-1</code>을 돌려주고 <code>errno</code>에 값을 설정합니다. 전혀 예상하지 못하셨으리라 생각합니다.</p><p>전과 마찬가지로 한 번에 많은 내용입니다. 여러분의 독서를 위한 예제 코드 조각입니다:</p><div class="sourceCode" id="cb36"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb36-1" title="1"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb36-5" title="5"></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="pp">#define MYPORT &quot;3490&quot;  </span><span class="co">// 사용자들이 접속할 포트</span></a>
<a class="sourceLine" id="cb36-7" title="7"><span class="pp">#define BACKLOG 10     </span><span class="co">// 대기열에 몇 개의 연결이 대기할 수 있는가</span></a>
<a class="sourceLine" id="cb36-8" title="8"></a>
<a class="sourceLine" id="cb36-9" title="9"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb36-10" title="10">{</a>
<a class="sourceLine" id="cb36-11" title="11">    <span class="kw">struct</span> sockaddr_storage their_addr;</a>
<a class="sourceLine" id="cb36-12" title="12">    socklen_t addr_size;</a>
<a class="sourceLine" id="cb36-13" title="13">    <span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb36-14" title="14">    <span class="dt">int</span> sockfd, new_fd;</a>
<a class="sourceLine" id="cb36-15" title="15"></a>
<a class="sourceLine" id="cb36-16" title="16">    <span class="co">// !! 이 호출들에 대한 오류 확인을 잊지 마십시오 !!</span></a>
<a class="sourceLine" id="cb36-17" title="17"></a>
<a class="sourceLine" id="cb36-18" title="18">    <span class="co">// getaddrinfo()으로 정보를 채워넣습니다:</span></a>
<a class="sourceLine" id="cb36-19" title="19"></a>
<a class="sourceLine" id="cb36-20" title="20">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb36-21" title="21">    hints.ai_family = AF_UNSPEC;  <span class="co">// IPv4또는 IPv6, 아무것이나 씁니다.</span></a>
<a class="sourceLine" id="cb36-22" title="22">    hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb36-23" title="23">    hints.ai_flags = AI_PASSIVE;     <span class="co">// 나를 위해 자동으로 내 IP를 채워넣을 것.</span></a>
<a class="sourceLine" id="cb36-24" title="24"></a>
<a class="sourceLine" id="cb36-25" title="25">    getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb36-26" title="26"></a>
<a class="sourceLine" id="cb36-27" title="27">    <span class="co">// 소켓을 만들고, 바인드하고, 듣기 시작:</span></a>
<a class="sourceLine" id="cb36-28" title="28"></a>
<a class="sourceLine" id="cb36-29" title="29">    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb36-30" title="30">    bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a>
<a class="sourceLine" id="cb36-31" title="31">    listen(sockfd, BACKLOG);</a>
<a class="sourceLine" id="cb36-32" title="32"></a>
<a class="sourceLine" id="cb36-33" title="33">    <span class="co">// 들어오는 연결을 받습니다:</span></a>
<a class="sourceLine" id="cb36-34" title="34"></a>
<a class="sourceLine" id="cb36-35" title="35">    addr_size = <span class="kw">sizeof</span> their_addr;</a>
<a class="sourceLine" id="cb36-36" title="36">    new_fd = accept(sockfd, (<span class="kw">struct</span> sockaddr *)&amp;their_addr, &amp;addr_size);</a>
<a class="sourceLine" id="cb36-37" title="37"></a>
<a class="sourceLine" id="cb36-38" title="38">    <span class="co">// new_fd 소켓 설명자에서 통신할 준비 완료!</span></a>
<a class="sourceLine" id="cb36-39" title="39">    .</a>
<a class="sourceLine" id="cb36-40" title="40">    .</a>
<a class="sourceLine" id="cb36-41" title="41">    .</a></code></pre></div><p>다시 말하지만 모든 <code>send()</code>와 <code>recv()</code> 호출에 대해서 <code>new_fd</code>를 사용할 것입니다. 만약 단 한 개의 연결만을 받아들이길 원한다면 추가적인 연결이 같은 포트를 통해 들어오는 것을 막기 위해서 <code>sockfd</code>을 <code>close()</code>처리할 수 있습니다.</p><h2 id="sendrecv"><span class="header-section-number">5.7</span> <code>send()</code>와 <code>recv()</code>—Talk to me, baby!</h2><p>(역자 주 : Talk to me, baby!는 Elmore James의 노래입니다. 그러나 원저자의 의도가 이것인지 확실하지는 않습니다.) 이 두 함수들은 스트림 소켓이나 연결된 데이터그램 소켓을 통해 통신하기 위해서 쓰입니다. 일반적인 연결되지 않은 데이터그램 소켓을 쓰고싶다면 <a href="#sendtorecv"><code>sendto()</code>과 <code>recvfrom()</code></a> 절을 보시면 됩니다.</p><p> <code>send()</code> 함수:</p><div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb37-1" title="1"><span class="dt">int</span> send(<span class="dt">int</span> sockfd, <span class="dt">const</span> <span class="dt">void</span> *msg, <span class="dt">int</span> len, <span class="dt">int</span> flags); </a></code></pre></div><p><code>sockfd</code> 은 데이터를 보내고 싶은 소켓 설명자(<code>socket()</code>으로 만들었든 <code>accept()</code>로 만들었든)입니다. <code>msg</code>는 당신이 보낼 데이터에 대한 포인터이며, <code>len</code>은 그 길이입니다.</p><p>예제 코드는 이렇게 될 수 있겠습니다:</p><div class="sourceCode" id="cb38"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb38-1" title="1"><span class="dt">char</span> *msg = <span class="st">&quot;Beej was here!&quot;</span>;</a>
<a class="sourceLine" id="cb38-2" title="2"><span class="dt">int</span> len, bytes_sent;</a>
<a class="sourceLine" id="cb38-3" title="3">.</a>
<a class="sourceLine" id="cb38-4" title="4">.</a>
<a class="sourceLine" id="cb38-5" title="5">.</a>
<a class="sourceLine" id="cb38-6" title="6">len = strlen(msg);</a>
<a class="sourceLine" id="cb38-7" title="7">bytes_sent = send(sockfd, msg, len, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb38-8" title="8">.</a>
<a class="sourceLine" id="cb38-9" title="9">.</a>
<a class="sourceLine" id="cb38-10" title="10">. </a></code></pre></div><p>한 방에 모든 것을 보냈습니다. 다시 강조하지만 오류가 발생하면 <code>-1</code>이 반환되고 <code>errno</code>가 오류 번호로 설정됩니다.</p><p> <code>recv()</code>함수는 많은 면에서 유사합니다:</p><div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb39-1" title="1"><span class="dt">int</span> recv(<span class="dt">int</span> sockfd, <span class="dt">void</span> *buf, <span class="dt">int</span> len, <span class="dt">int</span> flags);</a></code></pre></div><p><code>sockfd</code>은 읽어들일 소켓 설명자이며, <code>buf</code>는 정보를 읽어들일 버퍼이고, <code>len</code>은 버퍼의 최대 길이이고 <code>flags</code>는 여기서도 0으로 설정될 수 있습니다. (플래그 정보에 대해서는 <code>recv()</code>의 man page를 참고하십시오.)</p><p><code>recv()</code>는 실제로 버퍼에 읽어들인 바이트의 수를 돌려주거나 오류가 발생할 경우 (<code>errno</code> 를 적절한 값으로 설정하고) <code>-1</code>을 돌려줍니다.</p><p>잠깐! <code>recv()</code>는 <code>0</code>을 돌려줄 수 있습니다. 이것은 한 가지 의미입니다: 원격지 측에서 당신에 대한 연결을 닫은 것입니다! 복귀값 <code>0</code>은 <code>recv()</code>가 연결이 끊어졌음을 알려주는 방식입니다.</p><p>자, 정말 쉽지않습니까? 이제 여러분은 스트림 소켓에서 자료를 주고받을 수 있습니다. 와! 이제 여러분은 유닉스 네트워크 프로그래머입니다!</p><h2 id="sendtorecv"><span class="header-section-number">5.8</span> <code>sendto()</code>와 <code>recvfrom()</code>—Talk to me, DGRAM-방식</h2><p> “이제 다 깔끔하고 좋네요”라고 말씀하시는 소리가 들립니다. “그렇지만 연결이 없는 데이터그램 소켓은 어떻게 처리하지요?”라고도 하시는군요. 문제 없습니다, 토모다치여(역자 주 : 원문은 amigo). 딱 맞는 것이 있습니다.</p><p>데이터그램 소켓은 원격지 호스트에 연결되어 있지 않으므로, 패킷을 보낼 때에 필요한 정보는 조금 다릅니다. 그렇습니다. 목적지 주소가 필요합니다. 이런 식입니다:</p><div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb40-1" title="1"><span class="dt">int</span> sendto(<span class="dt">int</span> sockfd, <span class="dt">const</span> <span class="dt">void</span> *msg, <span class="dt">int</span> len, <span class="dt">unsigned</span> <span class="dt">int</span> flags,</a>
<a class="sourceLine" id="cb40-2" title="2">           <span class="dt">const</span> <span class="kw">struct</span> sockaddr *to, socklen_t tolen); </a></code></pre></div><p>보시다시피 <code>send()</code>와 같지만 두 개의 정보가 더 있습니다. <code>to</code>는 목적지의  IP주소와  포트를 담은 <code>struct sockaddr</code> 이며(아마도 여러분이 형변환해서 사용하실 <code>struct sockaddr_in</code>이나 <code>struct sockaddr_in6</code> 또는 <code>struct sockaddr_storage</code>일 것입니다.) <code>tolen</code>은 내부적으로는 <code>int</code>이며 간단하게 <code>sizeof *to</code>나 <code>sizeof(struct sockaddr_storage)</code>로 설정하면 됩니다.</p><p>목적지 주소 구조체를 얻으려면 <code>getaddrinfo()</code>이나 아래의 <code>recvfrom()</code>을 사용하시거나 수작업으로 값을 채워넣을 수도 있습니다.</p><p><code>send()</code>와 마찬가지로 <code>sendto()</code>도 실제로 보낸 바이트 수를 돌려줍니다. ( 그 말은 보내려고 한 바이트의 수보다 적은 수가 돌아올 수도 있다는 의미입니다.) 오류가 발생하면 <code>-1</code>을 돌려줍니다.</p><p>이와 유사한 관계가 <code>recv()</code>과  <code>recvfrom()</code>입니다. <code>recvfrom()</code>의 개요는 이렇습니다:</p><div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb41-1" title="1"><span class="dt">int</span> recvfrom(<span class="dt">int</span> sockfd, <span class="dt">void</span> *buf, <span class="dt">int</span> len, <span class="dt">unsigned</span> <span class="dt">int</span> flags,</a>
<a class="sourceLine" id="cb41-2" title="2">             <span class="kw">struct</span> sockaddr *from, <span class="dt">int</span> *fromlen); </a></code></pre></div><p>또 다시 이것은 몇 개의 추가적인 필드가 있는 <code>recv()</code>과 같습니다. <code>from</code>은 근원지 장치의 아이피 주소와 포트로 채워진 로컬  <code>struct sockaddr_storage</code>에 대한 포인터입니다. <code>fromlen</code>은 로컬 <code>int</code>에 대한 포인터이며 <code>sizeof *from</code>이나 <code>sizeof(struct sockaddr_storage)</code>으로 초기화되어야 합니다. 함수가 반환될 때 <code>fromlen</code>은 <code>from</code>에 실제로 저장된 주소의 길이로 설정되어 있을 것입니다.</p><p><code>recvfrom()</code>은 받은 바이트의 갯수를 반환하며 오류가 나면 (<code>errno</code>를 적절히 설정하고) <code>-1</code>을 돌려줍니다.</p><p>여기 질문이 하나 있을 것입니다: 왜 우리는 <code>struct sockaddr_storage</code>을 소켓의 타입으로 사용하는가? 왜 그냥 <code>struct sockaddr_in</code>을 쓸 수 없는가? 이유는 보시다시피 우리가 IPv4나 IPv6중 하나에 얽메이고 싶지 않기 때문입니다. 그래서 우리는 양쪽 모두에 충분히 크고 일반적인 <code>struct sockaddr_storage</code>을 사용합니다.</p><p>(그럼… 여기에서 다른 질문 하나: 왜 <code>struct sockaddr</code>을 모든 주소를 담을 수 있을 정도로 크게 만들지 않았는가? 우리는 일반 목적의 <code>struct sockaddr_storage</code> 을 다시 일반 목적의 <code>struct sockaddr</code>으로 형변환하고 있습니다! 이런 동작은 과하고 불필요해 보입니다. 여기에 대한 대답은 그냥 이 <code>struct sockaddr</code>은 만들어질 때부터 그렇게 크지 않았다는 것이고, 이제와서 그것을 바꾸는 것은 문제의 소지가 있다는 것입니다. 그래서 그들은 그냥 새로운 타입을 만들었습니다.) (역자 주 : <code>struct sockaddr</code>은 소켓 통신의 초기에 만들어진 구조체이므로 IPv6을 담기에 충분하지 않은 것은 당연한 일입니다.)</p><p>만약 여러분이 데이터그램 소켓을  <code>connect()</code>하게 되면 모든 통신에 <code>send()</code>와 <code>recv()</code>을 쓸 수 있음을 기억하십시오. 소켓 자체는 여전히 데이터그램 소켓일 것이고 패킷은 여전히 UDP를 사용할 것이지만 소켓 인터페이스가 자동으로 여러분을 위해서 목적지와 원천지 정보를 추가할 것입니다.</p><h2 id="close와-shutdown내-앞에서-꺼져"><span class="header-section-number">5.9</span> <code>close()</code>와 <code>shutdown()</code>—내 앞에서 꺼져!</h2><p>휴! 여러분은 하루 종일 <code>send()</code>와 <code>recv()</code>을 사용했고, 이제 충분합니다. 이제 여러분의 소켓 설명자를 닫을 준비가 되었습니다. 이건 쉽습니다. 그냥 평범한 유닉스 파일 설명자 닫기 함수인  <code>close()</code> 를 쓸 수 있습니다:</p><div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb42-1" title="1">close(sockfd); </a></code></pre></div><p>이것은 해당 소켓에 대한 후속 읽기와 쓰기를 방지할 것입니다. 원격지에서 이 소켓을 쓰거나 읽으려는 모든 시도는 오류를 반환할 것입니다.</p><p>소켓이 어떻게 닫히는지 좀 더 조절하고 싶은 경우에  <code>shutdown()</code> 함수를 사용할 수 있습니다. 이것은 특정 방향으로의 통신만 끊는 일을 할 수 있으며 양쪽 모두 막을 수도 있습니다(마치 <code>close()</code>가 하듯이). 개요는 이렇습니다:</p><div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb43-1" title="1"><span class="dt">int</span> shutdown(<span class="dt">int</span> sockfd, <span class="dt">int</span> how); </a></code></pre></div><p><code>sockfd</code>는 종료하고 싶은 소켓 파일 설명자이고, <code>how</code>는 다음 중 하나입니다:</p><table><thead><tr class="header"><th style="text-align: center;"><code>how</code></th><th>효과</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>0</code></td><td>후속 수신이 금지됩니다.</td></tr><tr class="even"><td style="text-align: center;"><code>1</code></td><td>후속 송신이 금지됩니다.</td></tr><tr class="odd"><td style="text-align: center;"><code>2</code></td><td>후속 송수신이 금지됩니다. (<code>close()</code>처럼)</td></tr></tbody></table><p><code>shutdown()</code>은 성공시에 <code>0</code>을 반환하고, 오류가 발생하면 (<code>errno</code>를 적절한 값으로 설정하고) <code>-1</code>을 반환합니다.</p><p>연결되지 않은 데이터그램 소켓에 기꺼이 <code>shutdown()</code>을 해주신다면, 그것은 단순히 해당 소켓에 <code>send()</code>와 <code>recv()</code>를 사용할 수 없도록 만들 것입니다(데이터그램 소켓에 <code>connect()</code>를 사용하면 이 두 함수를 사용할 수 있음을 기억하십시오).</p><p><code>shutdown()</code>이 실제로 파일 설명자를 닫지는 않음에 주목하십시오. 소켓 설명자를 해제하기 위해서는 <code>close()</code>를 호출해야 합니다.</p><p>별 것 없군요.</p><p>(예외적으로 여러분이  윈도우즈와  Winsock을 사용하실 경우 <code>close()</code>대신  <code>closesocket()</code>을 호출해야 합니다.)</p><h2 id="getpeername누구십니까"><span class="header-section-number">5.10</span> <code>getpeername()</code>—누구십니까?</h2><p> 이 함수는 너무 쉽습니다.</p><p>너무 쉬워서 이 함수에 별도의 장을 주지도 않았습니다. 아무튼 알려드리겠습니다.</p><p><code>getpeername()</code>함수는 연결된 스트림 소켓의 반대편 끝에 누가 있는지를 알려줄 것입니다. 개요입니다:</p><div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb44-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb44-2" title="2"></a>
<a class="sourceLine" id="cb44-3" title="3"><span class="dt">int</span> getpeername(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *addr, <span class="dt">int</span> *addrlen); </a></code></pre></div><p><code>sockfd</code>는 연결된 스트림 소켓의 설명자입니다. <code>addr</code>은 연결의 반대편 끝에 대한 정보를 담을 <code>struct sockaddr</code> (또는 <code>struct sockaddr_in</code>) 에 대한 포인터입니다. <code>addrlen</code>은 <code>int</code>에 대한 포인터이며 <code>sizeof *addr</code>이나 <code>sizeof(struct sockaddr)</code>으로 초기화되어야 합니다. (역자 주 : 이 함수도 IPv6과 동작하기 위해서 <code>struct sockaddr_storage</code> 을 사용할 수 있습니다.)</p><p>이 함수는 오류가 발생하면 <code>-1</code>을 돌려주고 <code>errno</code>를 알맞게 설정합니다.</p><p>여러분이 상대방의 주소를 가지면 그것을  <code>inet_ntop()</code>,  <code>getnameinfo()</code> 또는  <code>gethostbyaddr()</code>에 넣어서 화면에 출력하거나 추가적인 정보를 가져올 수 있습니다. 그들의 로그인 이름을 가져올 수는 없습니다. (좋습니다, 좋아요. 만약 저쪽 컴퓨터가 ident 데몬을 실행중이라면 가능합니다. 그러나 그것은 이 문서의 범위를 넘어섭니다. 더 자세한 정보를 원한다면 <a href="https://tools.ietf.org/html/rfc1413">RFC 1413</a><a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a>을 참고하십시오.)</p><h2 id="gethostname나는-누구인가"><span class="header-section-number">5.11</span> <code>gethostname()</code>—나는 누구인가?</h2><p> <code>getpeername()</code>보다 더 쉬운 것이 바로 <code>gethostname()</code> 함수입니다. 이것은 여러분의 프로그램이 실행되고 있는 컴퓨터의 이름을 돌려줍니다. 돌려받은 이름은 위에 있는  <code>getaddrinfo()</code> 을 써서 여러분의 로컬 장치의  IP주소를 알아내는 일에 쓰일 수 있습니다.</p><p>이보다 더 재미있는 일이 있을 수 있겠습니까? 사실 몇 가지 생각나긴 합니다만 소켓 프로그래밍에 대한 것이 아니군요. 아무튼 정리하자면 이렇습니다:</p><div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb45-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb45-2" title="2"></a>
<a class="sourceLine" id="cb45-3" title="3"><span class="dt">int</span> gethostname(<span class="dt">char</span> *hostname, <span class="dt">size_t</span> size); </a></code></pre></div><p>인수들은 단순합니다: <code>hostname</code>은 함수가 반환하는 호스트 이름을 담을 char의 배열에 대한 포인터입니다. <code>size</code>는 <code>hostname</code>배열의 길이입니다.</p><p>함수는 성공적인 완료 후에 <code>0</code>을 반환하고, 오류에 대해서는 흔히 그렇듯 <code>errno</code>를 설정하고 <code>-1</code>을 반환합니다.</p><h1 id="클라인트-서버-배경지식"><span class="header-section-number">6</span> 클라인트-서버 배경지식</h1><p></p><p>클라이언트-서버에 대해 이야기할 차례이다. 통신망에 있는 거의 모든 것들은 서버 프로세스에게 이야기하는 클라이언트 프로세스를 상대하거나 그 반대이다. <code>telnet</code>을 예로 들어보자. 여러분이 텔넷(클라이언트)로 원격지 호스트의 23번 포트에 접속할 때 그 호스트의 프로그램(<code>telnetd</code>라고 불리는 서버)이 생명을 얻는다. 그것이 들어오는 텔넷 요청을 처리하고 당신에게 로그인 프롬프트를 띄워주는 등의 일을 처리한다.</p><figure><embed src="cs.svg" title="[클라이언트- 서버 상호작용 도표]" /><figcaption>클라이언트 - 서버 상호작용</figcaption></figure><p>위의 도표에 클라이언트와 서버의 정보 교환이 정리되어 있습니다.</p><p>클라이언트-서버 쌍은 <code>SOCK_STREAM</code>이나 <code>SOCK_DGRAM</code> 또는 다른 어떤 것이라도 말할 수 있음을 기억하십시오.(둘이 같은 방식으로 말하기만 한다면) 클라이언트-서버 쌍의 좋은 예시는 <code>telnet</code>/<code>telnetd</code>, <code>ftp</code>/<code>ftpd</code> 또는 <code>Firefox</code>/<code>Apache</code> 입니다. 당신이 <code>ftp</code>를 쓸 때마다 당신의 요청을 받아들이는 원격지 프로그램인 <code>ftpd</code>가 있습니다.</p><p>흔히 한 개의 장기체는 오직 하나의 서버만이 있을 것이며 그 서버는  <code>fork()</code> 를 통해서 여러 클라이언트를 처리할 것입니다. 기본적인 과정은 아래와 같습니다. 서버가 연결을 기다리고, <code>accept()</code>한 후, 요청을 처리할 자식 프로세스를 <code>fork()</code> 합니다. 이것이 다음 절에서 우리의 예제 서버가 하는 일입니다.</p><h2 id="단순한-스트림-서버"><span class="header-section-number">6.1</span> 단순한 스트림 서버</h2><p></p><p>이 서버가 하는 일은 스트림 연결에 “<code>Hello, world!</code>”을 전송하는 것 뿐입니다. 이 서버를 시험하기 위해서 할 일은 하나의 창에서 이것을 실행한 후 다른 창에서 텔넷에 아래 명령어로 접속하는 일 뿐입니다.</p><pre><code>$ telnet remotehostname 3490</code></pre><p><code>remotehostname</code>은 당신이 실행하는 장치의 아이피입니다.</p><p><a href="https://beej.us/guide/bgnet/examples/server.c">The server code</a><a href="#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a>:</p><div class="sourceCode" id="cb47"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb47-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb47-2" title="2"><span class="co">** server.c -- a stream socket server demo</span></a>
<a class="sourceLine" id="cb47-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb47-4" title="4"></a>
<a class="sourceLine" id="cb47-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb47-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb47-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb47-8" title="8"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb47-9" title="9"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb47-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb47-11" title="11"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb47-12" title="12"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb47-13" title="13"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb47-14" title="14"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb47-15" title="15"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb47-16" title="16"><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb47-17" title="17"></a>
<a class="sourceLine" id="cb47-18" title="18"><span class="pp">#define PORT &quot;3490&quot;  </span><span class="co">// 사용자들이 접속할 포트</span></a>
<a class="sourceLine" id="cb47-19" title="19"></a>
<a class="sourceLine" id="cb47-20" title="20"><span class="pp">#define BACKLOG 10   </span><span class="co">// 몇 개의 대기중인 연결이 유지될 것인가</span></a>
<a class="sourceLine" id="cb47-21" title="21"></a>
<a class="sourceLine" id="cb47-22" title="22"><span class="dt">void</span> sigchld_handler(<span class="dt">int</span> s)</a>
<a class="sourceLine" id="cb47-23" title="23">{</a>
<a class="sourceLine" id="cb47-24" title="24">    <span class="co">// waitpid()이 errno를 덮어쓸 수 있으므로 저장했다가 되살린다.</span></a>
<a class="sourceLine" id="cb47-25" title="25">    <span class="dt">int</span> saved_errno = errno;</a>
<a class="sourceLine" id="cb47-26" title="26"></a>
<a class="sourceLine" id="cb47-27" title="27">    <span class="cf">while</span>(waitpid(-<span class="dv">1</span>, NULL, WNOHANG) &gt; <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb47-28" title="28"></a>
<a class="sourceLine" id="cb47-29" title="29">    errno = saved_errno;</a>
<a class="sourceLine" id="cb47-30" title="30">}</a>
<a class="sourceLine" id="cb47-31" title="31"></a>
<a class="sourceLine" id="cb47-32" title="32"></a>
<a class="sourceLine" id="cb47-33" title="33"><span class="co">// IPv4 또는 IPv6 sockaddr을 받아온다.</span></a>
<a class="sourceLine" id="cb47-34" title="34"><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</a>
<a class="sourceLine" id="cb47-35" title="35">{</a>
<a class="sourceLine" id="cb47-36" title="36">    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</a>
<a class="sourceLine" id="cb47-37" title="37">        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</a>
<a class="sourceLine" id="cb47-38" title="38">    }</a>
<a class="sourceLine" id="cb47-39" title="39"></a>
<a class="sourceLine" id="cb47-40" title="40">    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</a>
<a class="sourceLine" id="cb47-41" title="41">}</a>
<a class="sourceLine" id="cb47-42" title="42"></a>
<a class="sourceLine" id="cb47-43" title="43"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb47-44" title="44">{</a>
<a class="sourceLine" id="cb47-45" title="45">    <span class="dt">int</span> sockfd, new_fd;  <span class="co">// sock_fd에서 대기하고 들어오는 연결은 new_fd에 저장</span></a>
<a class="sourceLine" id="cb47-46" title="46">    <span class="kw">struct</span> addrinfo hints, *servinfo, *p;</a>
<a class="sourceLine" id="cb47-47" title="47">    <span class="kw">struct</span> sockaddr_storage their_addr; <span class="co">// 접속자의 주소 정보</span></a>
<a class="sourceLine" id="cb47-48" title="48">    socklen_t sin_size;</a>
<a class="sourceLine" id="cb47-49" title="49">    <span class="kw">struct</span> sigaction sa;</a>
<a class="sourceLine" id="cb47-50" title="50">    <span class="dt">int</span> yes=<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb47-51" title="51">    <span class="dt">char</span> s[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb47-52" title="52">    <span class="dt">int</span> rv;</a>
<a class="sourceLine" id="cb47-53" title="53"></a>
<a class="sourceLine" id="cb47-54" title="54">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb47-55" title="55">    hints.ai_family = AF_UNSPEC;</a>
<a class="sourceLine" id="cb47-56" title="56">    hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb47-57" title="57">    hints.ai_flags = AI_PASSIVE; <span class="co">// use my IP</span></a>
<a class="sourceLine" id="cb47-58" title="58"></a>
<a class="sourceLine" id="cb47-59" title="59">    <span class="cf">if</span> ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb47-60" title="60">        fprintf(stderr, <span class="st">&quot;getaddrinfo: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(rv));</a>
<a class="sourceLine" id="cb47-61" title="61">        <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb47-62" title="62">    }</a>
<a class="sourceLine" id="cb47-63" title="63"></a>
<a class="sourceLine" id="cb47-64" title="64">    <span class="co">// 모든 결과를 조회하고 쓸 수 있는 첫 번째 것을 사용</span></a>
<a class="sourceLine" id="cb47-65" title="65">    <span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb47-66" title="66">        <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</a>
<a class="sourceLine" id="cb47-67" title="67">                p-&gt;ai_protocol)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb47-68" title="68">            perror(<span class="st">&quot;server: socket&quot;</span>);</a>
<a class="sourceLine" id="cb47-69" title="69">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb47-70" title="70">        }</a>
<a class="sourceLine" id="cb47-71" title="71"></a>
<a class="sourceLine" id="cb47-72" title="72">        <span class="cf">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,</a>
<a class="sourceLine" id="cb47-73" title="73">                <span class="kw">sizeof</span>(<span class="dt">int</span>)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb47-74" title="74">            perror(<span class="st">&quot;setsockopt&quot;</span>);</a>
<a class="sourceLine" id="cb47-75" title="75">            exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb47-76" title="76">        }</a>
<a class="sourceLine" id="cb47-77" title="77"></a>
<a class="sourceLine" id="cb47-78" title="78">        <span class="cf">if</span> (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb47-79" title="79">            close(sockfd);</a>
<a class="sourceLine" id="cb47-80" title="80">            perror(<span class="st">&quot;server: bind&quot;</span>);</a>
<a class="sourceLine" id="cb47-81" title="81">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb47-82" title="82">        }</a>
<a class="sourceLine" id="cb47-83" title="83"></a>
<a class="sourceLine" id="cb47-84" title="84">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb47-85" title="85">    }</a>
<a class="sourceLine" id="cb47-86" title="86"></a>
<a class="sourceLine" id="cb47-87" title="87">    freeaddrinfo(servinfo); <span class="co">// 이 구조체는 더 이상 필요없음</span></a>
<a class="sourceLine" id="cb47-88" title="88"></a>
<a class="sourceLine" id="cb47-89" title="89">    <span class="cf">if</span> (p == NULL)  {</a>
<a class="sourceLine" id="cb47-90" title="90">        fprintf(stderr, <span class="st">&quot;server: failed to bind</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb47-91" title="91">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb47-92" title="92">    }</a>
<a class="sourceLine" id="cb47-93" title="93"></a>
<a class="sourceLine" id="cb47-94" title="94">    <span class="cf">if</span> (listen(sockfd, BACKLOG) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb47-95" title="95">        perror(<span class="st">&quot;listen&quot;</span>);</a>
<a class="sourceLine" id="cb47-96" title="96">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb47-97" title="97">    }</a>
<a class="sourceLine" id="cb47-98" title="98"></a>
<a class="sourceLine" id="cb47-99" title="99">    sa.sa_handler = sigchld_handler; <span class="co">// 죽은 프로세스를 다 거둬들이자</span></a>
<a class="sourceLine" id="cb47-100" title="100">    sigemptyset(&amp;sa.sa_mask);</a>
<a class="sourceLine" id="cb47-101" title="101">    sa.sa_flags =   ;</a>
<a class="sourceLine" id="cb47-102" title="102">    <span class="cf">if</span> (sigaction(SIGCHLD, &amp;sa, NULL) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb47-103" title="103">        perror(<span class="st">&quot;sigaction&quot;</span>);</a>
<a class="sourceLine" id="cb47-104" title="104">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb47-105" title="105">    }</a>
<a class="sourceLine" id="cb47-106" title="106"></a>
<a class="sourceLine" id="cb47-107" title="107">    printf(<span class="st">&quot;server: waiting for connections...</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb47-108" title="108"></a>
<a class="sourceLine" id="cb47-109" title="109">    <span class="cf">while</span>(<span class="dv">1</span>) {  <span class="co">// 주 accept() 루프</span></a>
<a class="sourceLine" id="cb47-110" title="110">        sin_size = <span class="kw">sizeof</span> their_addr;</a>
<a class="sourceLine" id="cb47-111" title="111">        new_fd = accept(sockfd, (<span class="kw">struct</span> sockaddr *)&amp;their_addr, &amp;sin_size);</a>
<a class="sourceLine" id="cb47-112" title="112">        <span class="cf">if</span> (new_fd == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb47-113" title="113">            perror(<span class="st">&quot;accept&quot;</span>);</a>
<a class="sourceLine" id="cb47-114" title="114">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb47-115" title="115">        }</a>
<a class="sourceLine" id="cb47-116" title="116"></a>
<a class="sourceLine" id="cb47-117" title="117">        inet_ntop(their_addr.ss_family,</a>
<a class="sourceLine" id="cb47-118" title="118">            get_in_addr((<span class="kw">struct</span> sockaddr *)&amp;their_addr),</a>
<a class="sourceLine" id="cb47-119" title="119">            s, <span class="kw">sizeof</span> s);</a>
<a class="sourceLine" id="cb47-120" title="120">        printf(<span class="st">&quot;server: got connection from %s</span><span class="sc">\n</span><span class="st">&quot;</span>, s);</a>
<a class="sourceLine" id="cb47-121" title="121"></a>
<a class="sourceLine" id="cb47-122" title="122">        <span class="cf">if</span> (!fork()) { <span class="co">// 자식 프로세스이다.</span></a>
<a class="sourceLine" id="cb47-123" title="123">            close(sockfd); <span class="co">// 자식은 리스너가 필요없다.</span></a>
<a class="sourceLine" id="cb47-124" title="124">            <span class="cf">if</span> (send(new_fd, <span class="st">&quot;Hello, world!&quot;</span>, <span class="dv">13</span>, <span class="dv">0</span>) == <span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb47-125" title="125">                perror(<span class="st">&quot;send&quot;</span>);</a>
<a class="sourceLine" id="cb47-126" title="126">            close(new_fd);</a>
<a class="sourceLine" id="cb47-127" title="127">            exit(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb47-128" title="128">        }</a>
<a class="sourceLine" id="cb47-129" title="129">        close(new_fd);  <span class="co">// 부모는 이것이 필요없다.</span></a>
<a class="sourceLine" id="cb47-130" title="130">    }</a>
<a class="sourceLine" id="cb47-131" title="131"></a>
<a class="sourceLine" id="cb47-132" title="132">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb47-133" title="133">}</a></code></pre></div><p>궁금한 독자들을 위해 덧붙이자면 구문의 명료함을 위해서 하나의 큰 <code>main()</code>함수 안에 모든 코드를 다 적었습니다. 원한다면 더 작은 함수들로 나누어도 좋습니다.</p><p>(아마도 이  <code>sigaction()</code>을 처음 볼 수도 있는데 괜찮다. 이 코드는 <code>fork()</code>된 자식 프로세스가 종료되면서 생기는 좀비 프로세스를 거둬들이는 데 사용된다. 좀비 프로세스를 많이 만들고 거둬들이지 않으면 시스템 관리자가 흥분할 것이다.)</p><p>다음 절에 나오는 클라이언트를 사용해서 이 서버로부터 데이터를 얻을 수 있다.</p><p></p><h2 id="단순한-스트림-클라이언트"><span class="header-section-number">6.2</span> 단순한 스트림 클라이언트</h2><p></p><p>이 녀석은 서버보다도 더 쉽다. 이 클라이언트가 하는 일은 당신이 명령줄에 지정한 호스트의 3490번 포트로 접속하는 것이다. 이것은 서버가 보낸 문자열을 받는다.</p><p><a href="https://beej.us/guide/bgnet/examples/client.c">The client source</a><a href="#fn24" class="footnote-ref" id="fnref24"><sup>24</sup></a>:</p><div class="sourceCode" id="cb48"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb48-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb48-2" title="2"><span class="co">** client.c -- a stream socket client demo</span></a>
<a class="sourceLine" id="cb48-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb48-4" title="4"></a>
<a class="sourceLine" id="cb48-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb48-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb48-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb48-8" title="8"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb48-9" title="9"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb48-10" title="10"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb48-11" title="11"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb48-12" title="12"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb48-13" title="13"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb48-14" title="14"></a>
<a class="sourceLine" id="cb48-15" title="15"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb48-16" title="16"></a>
<a class="sourceLine" id="cb48-17" title="17"><span class="pp">#define PORT &quot;3490&quot; </span><span class="co">// 클라이언트가 접속할 포트</span></a>
<a class="sourceLine" id="cb48-18" title="18"></a>
<a class="sourceLine" id="cb48-19" title="19"><span class="pp">#define MAXDATASIZE 100 </span><span class="co">// 한 번에 받을 수 있는 최대 바이트 갯수</span></a>
<a class="sourceLine" id="cb48-20" title="20"></a>
<a class="sourceLine" id="cb48-21" title="21"><span class="co">// get sockaddr, IPv4 or IPv6:</span></a>
<a class="sourceLine" id="cb48-22" title="22"><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</a>
<a class="sourceLine" id="cb48-23" title="23">{</a>
<a class="sourceLine" id="cb48-24" title="24">    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</a>
<a class="sourceLine" id="cb48-25" title="25">        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</a>
<a class="sourceLine" id="cb48-26" title="26">    }</a>
<a class="sourceLine" id="cb48-27" title="27"></a>
<a class="sourceLine" id="cb48-28" title="28">    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</a>
<a class="sourceLine" id="cb48-29" title="29">}</a>
<a class="sourceLine" id="cb48-30" title="30"></a>
<a class="sourceLine" id="cb48-31" title="31"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb48-32" title="32">{</a>
<a class="sourceLine" id="cb48-33" title="33">    <span class="dt">int</span> sockfd, numbytes;</a>
<a class="sourceLine" id="cb48-34" title="34">    <span class="dt">char</span> buf[MAXDATASIZE];</a>
<a class="sourceLine" id="cb48-35" title="35">    <span class="kw">struct</span> addrinfo hints, *servinfo, *p;</a>
<a class="sourceLine" id="cb48-36" title="36">    <span class="dt">int</span> rv;</a>
<a class="sourceLine" id="cb48-37" title="37">    <span class="dt">char</span> s[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb48-38" title="38"></a>
<a class="sourceLine" id="cb48-39" title="39">    <span class="cf">if</span> (argc != <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb48-40" title="40">        fprintf(stderr,<span class="st">&quot;usage: client hostname</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb48-41" title="41">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb48-42" title="42">    }</a>
<a class="sourceLine" id="cb48-43" title="43"></a>
<a class="sourceLine" id="cb48-44" title="44">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb48-45" title="45">    hints.ai_family = AF_UNSPEC;</a>
<a class="sourceLine" id="cb48-46" title="46">    hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb48-47" title="47"></a>
<a class="sourceLine" id="cb48-48" title="48">    <span class="cf">if</span> ((rv = getaddrinfo(argv[<span class="dv">1</span>], PORT, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb48-49" title="49">        fprintf(stderr, <span class="st">&quot;getaddrinfo: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(rv));</a>
<a class="sourceLine" id="cb48-50" title="50">        <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb48-51" title="51">    }</a>
<a class="sourceLine" id="cb48-52" title="52"></a>
<a class="sourceLine" id="cb48-53" title="53">    <span class="co">// 모든 결과를 순회하면서 쓸 수 있는 가장 첫 번째 것을 씀</span></a>
<a class="sourceLine" id="cb48-54" title="54">    <span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb48-55" title="55">        <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</a>
<a class="sourceLine" id="cb48-56" title="56">                p-&gt;ai_protocol)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb48-57" title="57">            perror(<span class="st">&quot;client: socket&quot;</span>);</a>
<a class="sourceLine" id="cb48-58" title="58">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb48-59" title="59">        }</a>
<a class="sourceLine" id="cb48-60" title="60"></a>
<a class="sourceLine" id="cb48-61" title="61">        <span class="cf">if</span> (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb48-62" title="62">            close(sockfd);</a>
<a class="sourceLine" id="cb48-63" title="63">            perror(<span class="st">&quot;client: connect&quot;</span>);</a>
<a class="sourceLine" id="cb48-64" title="64">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb48-65" title="65">        }</a>
<a class="sourceLine" id="cb48-66" title="66"></a>
<a class="sourceLine" id="cb48-67" title="67">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb48-68" title="68">    }</a>
<a class="sourceLine" id="cb48-69" title="69"></a>
<a class="sourceLine" id="cb48-70" title="70">    <span class="cf">if</span> (p == NULL) {</a>
<a class="sourceLine" id="cb48-71" title="71">        fprintf(stderr, <span class="st">&quot;client: failed to connect</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb48-72" title="72">        <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb48-73" title="73">    }</a>
<a class="sourceLine" id="cb48-74" title="74"></a>
<a class="sourceLine" id="cb48-75" title="75">    inet_ntop(p-&gt;ai_family, get_in_addr((<span class="kw">struct</span> sockaddr *)p-&gt;ai_addr),</a>
<a class="sourceLine" id="cb48-76" title="76">            s, <span class="kw">sizeof</span> s);</a>
<a class="sourceLine" id="cb48-77" title="77">    printf(<span class="st">&quot;client: connecting to %s</span><span class="sc">\n</span><span class="st">&quot;</span>, s);</a>
<a class="sourceLine" id="cb48-78" title="78"></a>
<a class="sourceLine" id="cb48-79" title="79">    freeaddrinfo(servinfo); <span class="co">// 이 구조체는 더 이상 필요 없음</span></a>
<a class="sourceLine" id="cb48-80" title="80"></a>
<a class="sourceLine" id="cb48-81" title="81">    <span class="cf">if</span> ((numbytes = recv(sockfd, buf, MAXDATASIZE<span class="dv">-1</span>, <span class="dv">0</span>)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb48-82" title="82">        perror(<span class="st">&quot;recv&quot;</span>);</a>
<a class="sourceLine" id="cb48-83" title="83">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb48-84" title="84">    }</a>
<a class="sourceLine" id="cb48-85" title="85"></a>
<a class="sourceLine" id="cb48-86" title="86">    buf[numbytes] = &#39;\<span class="dv">0</span>&#39;;</a>
<a class="sourceLine" id="cb48-87" title="87"></a>
<a class="sourceLine" id="cb48-88" title="88">    printf(<span class="st">&quot;client: received &#39;%s&#39;</span><span class="sc">\n</span><span class="st">&quot;</span>,buf);</a>
<a class="sourceLine" id="cb48-89" title="89"></a>
<a class="sourceLine" id="cb48-90" title="90">    close(sockfd);</a>
<a class="sourceLine" id="cb48-91" title="91"></a>
<a class="sourceLine" id="cb48-92" title="92">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb48-93" title="93">}</a></code></pre></div><p>클라이언트를 실행하기 전에 서버를 실행하지 않으면 <code>connect()</code>는  “Connection refused”를 반환한다는 점을 기억하라. 아주 유용하다.</p><p></p><h2 id="datagram"><span class="header-section-number">6.3</span> 데이터그램 소켓</h2><p></p><p>위에서 <code>sendto()</code>과 <code>recvfrom()</code>에 대해 논의할 때 UDP 데이터그램 소켓의 기본에 대해서 이미 알아보았다. 그러므로 바로 2개의 예제 프로그램을 제시하겠다. <code>talker.c</code>와 <code>listener.c</code>이다.</p><p><code>listener</code>는 장치에서 포트 4950으로 들어오는 패킷을 대기한다. <code>talker</code>는 지정한 장치의 해당 포트로 사용자가 명령줄에 입력한 내용을 담은 패킷을 보낸다.</p><p>데이터그램 소켓은 연결이 없고 소켓을 이더넷에 발송한 후 성공 여부는 신경쓰지 않기 때문에 클라이언트와 서버에 IPv6을 사용하도록 명시할 것이다. 이렇게 하면 서버가 IPv6에서 듣고 클라이언트가 IPv4에서 발송해서 데이터를 받을 수 없는 상황을 피할 수 있을 것이다. (우리의 TCP 스트림 소켓 세상에서도 이런 불일치가 발생할 수 있지만 <code>connect()</code>에서 하나의 주소 체계에 대해 에러를 발생시키고 다른 주소체계를 쓰도록 해준다.)</p><p>여기에 <a href="https://beej.us/guide/bgnet/examples/listener.c"><code>listener.c</code>의 소스코드가 있다.</a><a href="#fn25" class="footnote-ref" id="fnref25"><sup>25</sup></a>:</p><div class="sourceCode" id="cb49"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb49-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb49-2" title="2"><span class="co">** listener.c -- a datagram sockets &quot;server&quot; demo</span></a>
<a class="sourceLine" id="cb49-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb49-4" title="4"></a>
<a class="sourceLine" id="cb49-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb49-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb49-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb49-8" title="8"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb49-9" title="9"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb49-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb49-11" title="11"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb49-12" title="12"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb49-13" title="13"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb49-14" title="14"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb49-15" title="15"></a>
<a class="sourceLine" id="cb49-16" title="16"><span class="pp">#define MYPORT &quot;4950&quot;    </span><span class="co">// the port users will be connecting to</span></a>
<a class="sourceLine" id="cb49-17" title="17"></a>
<a class="sourceLine" id="cb49-18" title="18"><span class="pp">#define MAXBUFLEN 100</span></a>
<a class="sourceLine" id="cb49-19" title="19"></a>
<a class="sourceLine" id="cb49-20" title="20"><span class="co">// get sockaddr, IPv4 or IPv6:</span></a>
<a class="sourceLine" id="cb49-21" title="21"><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</a>
<a class="sourceLine" id="cb49-22" title="22">{</a>
<a class="sourceLine" id="cb49-23" title="23">    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</a>
<a class="sourceLine" id="cb49-24" title="24">        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</a>
<a class="sourceLine" id="cb49-25" title="25">    }</a>
<a class="sourceLine" id="cb49-26" title="26"></a>
<a class="sourceLine" id="cb49-27" title="27">    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</a>
<a class="sourceLine" id="cb49-28" title="28">}</a>
<a class="sourceLine" id="cb49-29" title="29"></a>
<a class="sourceLine" id="cb49-30" title="30"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb49-31" title="31">{</a>
<a class="sourceLine" id="cb49-32" title="32">    <span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb49-33" title="33">    <span class="kw">struct</span> addrinfo hints, *servinfo, *p;</a>
<a class="sourceLine" id="cb49-34" title="34">    <span class="dt">int</span> rv;</a>
<a class="sourceLine" id="cb49-35" title="35">    <span class="dt">int</span> numbytes;</a>
<a class="sourceLine" id="cb49-36" title="36">    <span class="kw">struct</span> sockaddr_storage their_addr;</a>
<a class="sourceLine" id="cb49-37" title="37">    <span class="dt">char</span> buf[MAXBUFLEN];</a>
<a class="sourceLine" id="cb49-38" title="38">    socklen_t addr_len;</a>
<a class="sourceLine" id="cb49-39" title="39">    <span class="dt">char</span> s[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb49-40" title="40"></a>
<a class="sourceLine" id="cb49-41" title="41">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb49-42" title="42">    hints.ai_family = AF_INET6; <span class="co">// set to AF_INET to use IPv4</span></a>
<a class="sourceLine" id="cb49-43" title="43">    hints.ai_socktype = SOCK_DGRAM;</a>
<a class="sourceLine" id="cb49-44" title="44">    hints.ai_flags = AI_PASSIVE; <span class="co">// use my IP</span></a>
<a class="sourceLine" id="cb49-45" title="45"></a>
<a class="sourceLine" id="cb49-46" title="46">    <span class="cf">if</span> ((rv = getaddrinfo(NULL, MYPORT, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb49-47" title="47">        fprintf(stderr, <span class="st">&quot;getaddrinfo: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(rv));</a>
<a class="sourceLine" id="cb49-48" title="48">        <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb49-49" title="49">    }</a>
<a class="sourceLine" id="cb49-50" title="50"></a>
<a class="sourceLine" id="cb49-51" title="51">    <span class="co">// loop through all the results and bind to the first we can</span></a>
<a class="sourceLine" id="cb49-52" title="52">    <span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb49-53" title="53">        <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</a>
<a class="sourceLine" id="cb49-54" title="54">                p-&gt;ai_protocol)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb49-55" title="55">            perror(<span class="st">&quot;listener: socket&quot;</span>);</a>
<a class="sourceLine" id="cb49-56" title="56">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb49-57" title="57">        }</a>
<a class="sourceLine" id="cb49-58" title="58"></a>
<a class="sourceLine" id="cb49-59" title="59">        <span class="cf">if</span> (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb49-60" title="60">            close(sockfd);</a>
<a class="sourceLine" id="cb49-61" title="61">            perror(<span class="st">&quot;listener: bind&quot;</span>);</a>
<a class="sourceLine" id="cb49-62" title="62">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb49-63" title="63">        }</a>
<a class="sourceLine" id="cb49-64" title="64"></a>
<a class="sourceLine" id="cb49-65" title="65">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb49-66" title="66">    }</a>
<a class="sourceLine" id="cb49-67" title="67"></a>
<a class="sourceLine" id="cb49-68" title="68">    <span class="cf">if</span> (p == NULL) {</a>
<a class="sourceLine" id="cb49-69" title="69">        fprintf(stderr, <span class="st">&quot;listener: failed to bind socket</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb49-70" title="70">        <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb49-71" title="71">    }</a>
<a class="sourceLine" id="cb49-72" title="72"></a>
<a class="sourceLine" id="cb49-73" title="73">    freeaddrinfo(servinfo);</a>
<a class="sourceLine" id="cb49-74" title="74"></a>
<a class="sourceLine" id="cb49-75" title="75">    printf(<span class="st">&quot;listener: waiting to recvfrom...</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb49-76" title="76"></a>
<a class="sourceLine" id="cb49-77" title="77">    addr_len = <span class="kw">sizeof</span> their_addr;</a>
<a class="sourceLine" id="cb49-78" title="78">    <span class="cf">if</span> ((numbytes = recvfrom(sockfd, buf, MAXBUFLEN<span class="dv">-1</span> , <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb49-79" title="79">        (<span class="kw">struct</span> sockaddr *)&amp;their_addr, &amp;addr_len)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb49-80" title="80">        perror(<span class="st">&quot;recvfrom&quot;</span>);</a>
<a class="sourceLine" id="cb49-81" title="81">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb49-82" title="82">    }</a>
<a class="sourceLine" id="cb49-83" title="83"></a>
<a class="sourceLine" id="cb49-84" title="84">    printf(<span class="st">&quot;listener: got packet from %s</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb49-85" title="85">        inet_ntop(their_addr.ss_family,</a>
<a class="sourceLine" id="cb49-86" title="86">            get_in_addr((<span class="kw">struct</span> sockaddr *)&amp;their_addr),</a>
<a class="sourceLine" id="cb49-87" title="87">            s, <span class="kw">sizeof</span> s));</a>
<a class="sourceLine" id="cb49-88" title="88">    printf(<span class="st">&quot;listener: packet is %d bytes long</span><span class="sc">\n</span><span class="st">&quot;</span>, numbytes);</a>
<a class="sourceLine" id="cb49-89" title="89">    buf[numbytes] = &#39;\<span class="dv">0</span>&#39;;</a>
<a class="sourceLine" id="cb49-90" title="90">    printf(<span class="st">&quot;listener: packet contains </span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;\n</span><span class="st">&quot;</span>, buf);</a>
<a class="sourceLine" id="cb49-91" title="91"></a>
<a class="sourceLine" id="cb49-92" title="92">    close(sockfd);</a>
<a class="sourceLine" id="cb49-93" title="93"></a>
<a class="sourceLine" id="cb49-94" title="94">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb49-95" title="95">}</a></code></pre></div><p><code>getaddrinfo()</code>에서 우리가 마침내 <code>SOCK_DGRAM</code>을 사용한다는 것에 주목하라. 또한, <code>listen()</code>와 <code>accept()</code>이 필요하지 않다는 점도 기억하라. 이것이 연결 없는 데이터그램 소켓을 사용할 때의 장점 중 하나이다. Notice that in our call to <code>getaddrinfo()</code> we’re finally using <code>SOCK_DGRAM</code>. Also, note that there’s no need to <code>listen()</code> or <code>accept()</code>. This is one of the perks of using unconnected datagram sockets!</p><p></p><p></p><p>Next comes the <a href="https://beej.us/guide/bgnet/examples/talker.c">source for <code>talker.c</code></a><a href="#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a>:</p><div class="sourceCode" id="cb50"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb50-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb50-2" title="2"><span class="co">** talker.c -- a datagram &quot;client&quot; demo</span></a>
<a class="sourceLine" id="cb50-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb50-4" title="4"></a>
<a class="sourceLine" id="cb50-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb50-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb50-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb50-8" title="8"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb50-9" title="9"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb50-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb50-11" title="11"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb50-12" title="12"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb50-13" title="13"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb50-14" title="14"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb50-15" title="15"></a>
<a class="sourceLine" id="cb50-16" title="16"><span class="pp">#define SERVERPORT &quot;4950&quot;    </span><span class="co">// the port users will be connecting to</span></a>
<a class="sourceLine" id="cb50-17" title="17"></a>
<a class="sourceLine" id="cb50-18" title="18"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb50-19" title="19">{</a>
<a class="sourceLine" id="cb50-20" title="20">    <span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb50-21" title="21">    <span class="kw">struct</span> addrinfo hints, *servinfo, *p;</a>
<a class="sourceLine" id="cb50-22" title="22">    <span class="dt">int</span> rv;</a>
<a class="sourceLine" id="cb50-23" title="23">    <span class="dt">int</span> numbytes;</a>
<a class="sourceLine" id="cb50-24" title="24"></a>
<a class="sourceLine" id="cb50-25" title="25">    <span class="cf">if</span> (argc != <span class="dv">3</span>) {</a>
<a class="sourceLine" id="cb50-26" title="26">        fprintf(stderr,<span class="st">&quot;usage: talker hostname message</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb50-27" title="27">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb50-28" title="28">    }</a>
<a class="sourceLine" id="cb50-29" title="29"></a>
<a class="sourceLine" id="cb50-30" title="30">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb50-31" title="31">    hints.ai_family = AF_INET6; <span class="co">// set to AF_INET to use IPv4</span></a>
<a class="sourceLine" id="cb50-32" title="32">    hints.ai_socktype = SOCK_DGRAM;</a>
<a class="sourceLine" id="cb50-33" title="33"></a>
<a class="sourceLine" id="cb50-34" title="34">    <span class="cf">if</span> ((rv = getaddrinfo(argv[<span class="dv">1</span>], SERVERPORT, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb50-35" title="35">        fprintf(stderr, <span class="st">&quot;getaddrinfo: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(rv));</a>
<a class="sourceLine" id="cb50-36" title="36">        <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb50-37" title="37">    }</a>
<a class="sourceLine" id="cb50-38" title="38"></a>
<a class="sourceLine" id="cb50-39" title="39">    <span class="co">// loop through all the results and make a socket</span></a>
<a class="sourceLine" id="cb50-40" title="40">    <span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb50-41" title="41">        <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</a>
<a class="sourceLine" id="cb50-42" title="42">                p-&gt;ai_protocol)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb50-43" title="43">            perror(<span class="st">&quot;talker: socket&quot;</span>);</a>
<a class="sourceLine" id="cb50-44" title="44">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb50-45" title="45">        }</a>
<a class="sourceLine" id="cb50-46" title="46"></a>
<a class="sourceLine" id="cb50-47" title="47">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb50-48" title="48">    }</a>
<a class="sourceLine" id="cb50-49" title="49"></a>
<a class="sourceLine" id="cb50-50" title="50">    <span class="cf">if</span> (p == NULL) {</a>
<a class="sourceLine" id="cb50-51" title="51">        fprintf(stderr, <span class="st">&quot;talker: failed to create socket</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb50-52" title="52">        <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb50-53" title="53">    }</a>
<a class="sourceLine" id="cb50-54" title="54"></a>
<a class="sourceLine" id="cb50-55" title="55">    <span class="cf">if</span> ((numbytes = sendto(sockfd, argv[<span class="dv">2</span>], strlen(argv[<span class="dv">2</span>]), <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb50-56" title="56">             p-&gt;ai_addr, p-&gt;ai_addrlen)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb50-57" title="57">        perror(<span class="st">&quot;talker: sendto&quot;</span>);</a>
<a class="sourceLine" id="cb50-58" title="58">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb50-59" title="59">    }</a>
<a class="sourceLine" id="cb50-60" title="60"></a>
<a class="sourceLine" id="cb50-61" title="61">    freeaddrinfo(servinfo);</a>
<a class="sourceLine" id="cb50-62" title="62"></a>
<a class="sourceLine" id="cb50-63" title="63">    printf(<span class="st">&quot;talker: sent %d bytes to %s</span><span class="sc">\n</span><span class="st">&quot;</span>, numbytes, argv[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb50-64" title="64">    close(sockfd);</a>
<a class="sourceLine" id="cb50-65" title="65"></a>
<a class="sourceLine" id="cb50-66" title="66">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb50-67" title="67">}</a></code></pre></div><p>이것이 전부다! 하나의 장치에서 <code>listener</code>를 실행하고 <code>talker</code>를 다른 장치에서 실행하라.(역자 주 : 하나의 장치에서도 순서만 맞게 실행하면 문제는 없다. 여러 터미널을 동시에 열 수 있는 다양한 방법이 있다.) 그것들이 통신하는 것을 지켜보라. 핵가족 전체를 위한 전연령 엔터테인먼트다.</p><p>이번에는 서버르 실행할 필요도 없다! <code>talker</code>를 혼자 실행시키면 패킷을 행복하게 발송하고, 아무도 반대쪽에서 <code>recvfrom()</code>을 호출하지 않는다면 그저 패킷은 사라질 뿐이다. 기억하라 : UDP 데이터그램 소켓으로 보낸 데이터는 도착을 보장하지 않는다.!</p><p></p><p>전에 몇 번 말한 사소한 것 한 가지를 빼면 전부다:  연결된 데이터그램 소켓이 그것이다. 그것에 대해서 여기에서 말해야하는데, 이 문서의 데이터그램에 대한 부분이 바로 여기이기 때문이다. 위의 <code>talker</code> 가 <code>listener</code>의 주소를 지정하고 <code>connect()</code>를 호출한다고 하자. 그 순간부터 <code>talker</code>는 <code>connect()</code>로 지정한 주소로만 데이터를 보내고 받을 수 있다. 이런 이유로 <code>sendto()</code>와 <code>recvfrom()</code>을 쓸 필요가 없다. 단순히 <code>send()</code> 와 <code>recv()</code>를 쓰면 된다.</p><p></p><h1 id="slightly-advanced-techniques"><span class="header-section-number">7</span> Slightly Advanced Techniques</h1><p>These aren’t <em>really</em> advanced, but they’re getting out of the more basic levels we’ve already covered. In fact, if you’ve gotten this far, you should consider yourself fairly accomplished in the basics of Unix network programming! Congratulations!</p><p>So here we go into the brave new world of some of the more esoteric things you might want to learn about sockets. Have at it!</p><h2 id="blocking"><span class="header-section-number">7.1</span> Blocking</h2><p></p><p>Blocking. You’ve heard about it—now what the heck is it? In a nutshell, “block” is techie jargon for “sleep”. You probably noticed that when you run <code>listener</code>, above, it just sits there until a packet arrives. What happened is that it called <code>recvfrom()</code>, there was no data, and so <code>recvfrom()</code> is said to “block” (that is, sleep there) until some data arrives.</p><p>Lots of functions block. <code>accept()</code> blocks. All the <code>recv()</code> functions block. The reason they can do this is because they’re allowed to. When you first create the socket descriptor with <code>socket()</code>, the kernel sets it to blocking.  If you don’t want a socket to be blocking, you have to make a call to  <code>fcntl()</code>:</p><div class="sourceCode" id="cb51"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb51-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb51-2" title="2"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb51-3" title="3">.</a>
<a class="sourceLine" id="cb51-4" title="4">.</a>
<a class="sourceLine" id="cb51-5" title="5">.</a>
<a class="sourceLine" id="cb51-6" title="6">sockfd = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb51-7" title="7">fcntl(sockfd, F_SETFL, O_NONBLOCK);</a>
<a class="sourceLine" id="cb51-8" title="8">.</a>
<a class="sourceLine" id="cb51-9" title="9">.</a>
<a class="sourceLine" id="cb51-10" title="10">. </a></code></pre></div><p>By setting a socket to non-blocking, you can effectively “poll” the socket for information. If you try to read from a non-blocking socket and there’s no data there, it’s not allowed to block—it will return <code>-1</code> and <code>errno</code> will be set to  <code>EAGAIN</code> or  <code>EWOULDBLOCK</code>.</p><p>(Wait—it can return  <code>EAGAIN</code> <em>or</em>  <code>EWOULDBLOCK</code>? Which do you check for? The specification doesn’t actually specify which your system will return, so for portability, check them both.)</p><p>Generally speaking, however, this type of polling is a bad idea. If you put your program in a busy-wait looking for data on the socket, you’ll suck up CPU time like it was going out of style. A more elegant solution for checking to see if there’s data waiting to be read comes in the following section on  <code>poll()</code>.</p><p></p><h2 id="poll"><span class="header-section-number">7.2</span> <code>poll()</code>—Synchronous I/O Multiplexing</h2><p></p><p>What you really want to be able to do is somehow monitor a <em>bunch</em> of sockets at once and then handle the ones that have data ready. This way you don’t have to continuously poll all those sockets to see which are ready to read.</p><blockquote><p><em>A word of warning: <code>poll()</code> is horribly slow when it comes to giant numbers of connections. In those circumstances, you’ll get better performance out of an event library such as <a href="https://libevent.org/">libevent</a><a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a> that attempts to use the fastest possible method availabile on your system.</em></p></blockquote><p>So how can you avoid polling? Not slightly ironically, you can avoid polling by using the <code>poll()</code> system call. In a nutshell, we’re going to ask the operating system to do all the dirty work for us, and just let us know when some data is ready to read on which sockets. In the meantime, our process can go to sleep, saving system resources.</p><p>The general gameplan is to keep an array of <code>struct pollfd</code>s with information about which socket descriptors we want to monitor, and what kind of events we want to monitor for. The OS will block on the <code>poll()</code> call until one of those events occurs (e.g. “socket ready to read!”) or until a user-specified timeout occurs.</p><p>Usefully, a <code>listen()</code>ing socket will return “ready to read” when a new incoming connection is ready to be <code>accept()</code>ed.</p><p>That’s enough banter. How do we use this?</p><div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb52-1" title="1"><span class="pp">#include </span><span class="im">&lt;poll.h&gt;</span></a>
<a class="sourceLine" id="cb52-2" title="2"></a>
<a class="sourceLine" id="cb52-3" title="3"><span class="dt">int</span> poll(<span class="kw">struct</span> pollfd fds[], nfds_t nfds, <span class="dt">int</span> timeout);</a></code></pre></div><p><code>fds</code> is our array of information (which sockets to monitor for what), <code>nfds</code> is the count of elements in the array, and <code>timeout</code> is a timeout in milliseconds. It returns the number of elements in the array that have had an event occur.</p><p>Let’s have a look at that <code>struct</code>:</p><p></p><div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb53-1" title="1"><span class="kw">struct</span> pollfd {</a>
<a class="sourceLine" id="cb53-2" title="2">    <span class="dt">int</span> fd;         <span class="co">// the socket descriptor</span></a>
<a class="sourceLine" id="cb53-3" title="3">    <span class="dt">short</span> events;   <span class="co">// bitmap of events we&#39;re interested in</span></a>
<a class="sourceLine" id="cb53-4" title="4">    <span class="dt">short</span> revents;  <span class="co">// when poll() returns, bitmap of events that occurred</span></a>
<a class="sourceLine" id="cb53-5" title="5">};</a></code></pre></div><p>So we’re going to have an array of those, and we’ll set the <code>fd</code> field for each element to a socket descriptor we’re interested in monitoring. And then we’ll set the <code>events</code> field to indicate the type of events we’re interested in.</p><p>The <code>events</code> field is the bitwise-OR of the following:</p><table><thead><tr class="header"><th>Macro</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>POLLIN</code></td><td>Alert me when data is ready to <code>recv()</code> on this socket.</td></tr><tr class="even"><td><code>POLLOUT</code></td><td>Alert me when I can <code>send()</code> data to this socket without blocking.</td></tr></tbody></table><p>Once you have your array of <code>struct pollfd</code>s in order, then you can pass it to <code>poll()</code>, also passing the size of the array, as well as a timeout value in milliseconds. (You can specify a negative timeout to wait forever.)</p><p>After <code>poll()</code> returns, you can check the <code>revents</code> field to see if <code>POLLIN</code> or <code>POLLOUT</code> is set, indicating that event occurred.</p><p>(There’s actually more that you can do with the <code>poll()</code> call. See the <a href="#pollman"><code>poll()</code> man page, below</a>, for more details.)</p><p>Here’s <a href="https://beej.us/guide/bgnet/examples/poll.c">an example</a><a href="#fn28" class="footnote-ref" id="fnref28"><sup>28</sup></a> where we’ll wait 2.5 seconds for data to be ready to read from standard input, i.e. when you hit <code>RETURN</code>:</p><div class="sourceCode" id="cb54"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb54-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb54-2" title="2"><span class="pp">#include </span><span class="im">&lt;poll.h&gt;</span></a>
<a class="sourceLine" id="cb54-3" title="3"></a>
<a class="sourceLine" id="cb54-4" title="4"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb54-5" title="5">{</a>
<a class="sourceLine" id="cb54-6" title="6">    <span class="kw">struct</span> pollfd pfds[<span class="dv">1</span>]; <span class="co">// More if you want to monitor more</span></a>
<a class="sourceLine" id="cb54-7" title="7"></a>
<a class="sourceLine" id="cb54-8" title="8">    pfds[<span class="dv">0</span>].fd = <span class="dv">0</span>;          <span class="co">// Standard input</span></a>
<a class="sourceLine" id="cb54-9" title="9">    pfds[<span class="dv">0</span>].events = POLLIN; <span class="co">// Tell me when ready to read</span></a>
<a class="sourceLine" id="cb54-10" title="10"></a>
<a class="sourceLine" id="cb54-11" title="11">    <span class="co">// If you needed to monitor other things, as well:</span></a>
<a class="sourceLine" id="cb54-12" title="12">    <span class="co">//pfds[1].fd = some_socket; // Some socket descriptor</span></a>
<a class="sourceLine" id="cb54-13" title="13">    <span class="co">//pfds[1].events = POLLIN;  // Tell me when ready to read</span></a>
<a class="sourceLine" id="cb54-14" title="14"></a>
<a class="sourceLine" id="cb54-15" title="15">    printf(<span class="st">&quot;Hit RETURN or wait 2.5 seconds for timeout</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb54-16" title="16"></a>
<a class="sourceLine" id="cb54-17" title="17">    <span class="dt">int</span> num_events = poll(pfds, <span class="dv">1</span>, <span class="dv">2500</span>); <span class="co">// 2.5 second timeout</span></a>
<a class="sourceLine" id="cb54-18" title="18"></a>
<a class="sourceLine" id="cb54-19" title="19">    <span class="cf">if</span> (num_events == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb54-20" title="20">        printf(<span class="st">&quot;Poll timed out!</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb54-21" title="21">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb54-22" title="22">        <span class="dt">int</span> pollin_happened = pfds[<span class="dv">0</span>].revents &amp; POLLIN;</a>
<a class="sourceLine" id="cb54-23" title="23"></a>
<a class="sourceLine" id="cb54-24" title="24">        <span class="cf">if</span> (pollin_happened) {</a>
<a class="sourceLine" id="cb54-25" title="25">            printf(<span class="st">&quot;File descriptor %d is ready to read</span><span class="sc">\n</span><span class="st">&quot;</span>, pfds[<span class="dv">0</span>].fd);</a>
<a class="sourceLine" id="cb54-26" title="26">        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb54-27" title="27">            printf(<span class="st">&quot;Unexpected event occurred: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, pfds[<span class="dv">0</span>].revents);</a>
<a class="sourceLine" id="cb54-28" title="28">        }</a>
<a class="sourceLine" id="cb54-29" title="29">    }</a>
<a class="sourceLine" id="cb54-30" title="30"></a>
<a class="sourceLine" id="cb54-31" title="31">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb54-32" title="32">}</a></code></pre></div><p>Notice again that <code>poll()</code> returns the number of elements in the <code>pfds</code> array for which events have occurred. It doesn’t tell you <em>which</em> elements in the array (you still have to scan for that), but it does tell you how many entries have a non-zero <code>revents</code> field (so you can stop scanning after you find that many).</p><p>A couple questions might come up here: how to add new file descriptors to the set I pass to <code>poll()</code>? For this, simply make sure you have enough space in the array for all you need, or <code>realloc()</code> more space as needed.</p><p>What about deleting items from the set? For this, you can copy the last element in the array over-top the one you’re deleting. And then pass in one fewer as the count to <code>poll()</code>. Another option is that you can set any <code>fd</code> field to a negative number and <code>poll()</code> will ignore it.</p><p>How can we put it all together into a chat server that you can <code>telnet</code> to?</p><p>What we’ll do is start a listener socket, and add it to the set of file descriptors to <code>poll()</code>. (It will show ready-to-read when there’s an incoming connection.)</p><p>Then we’ll add new connections to our <code>struct pollfd</code> array. And we’ll grow it dynamically if we run out of space.</p><p>When a connection is closed, we’ll remove it from the array.</p><p>And when a connection is ready-to-read, we’ll read the data from it and send that data to all the other connections so they can see what the other users typed.</p><p>So give <a href="https://beej.us/guide/bgnet/examples/pollserver.c">this poll server</a><a href="#fn29" class="footnote-ref" id="fnref29"><sup>29</sup></a> a try. Run it in one window, then <code>telnet localhost 9034</code> from a number of other terminal windows. You should be able to see what you type in one window in the other ones (after you hit RETURN).</p><p>Not only that, but if you hit <code>CTRL-]</code> and type <code>quit</code> to exit <code>telnet</code>, the server should detect the disconnection and remove you from the array of file descriptors.</p><div class="sourceCode" id="cb55"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb55-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb55-2" title="2"><span class="co">** pollserver.c -- a cheezy multiperson chat server</span></a>
<a class="sourceLine" id="cb55-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb55-4" title="4"></a>
<a class="sourceLine" id="cb55-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb55-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb55-7" title="7"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb55-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb55-9" title="9"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb55-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb55-11" title="11"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb55-12" title="12"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb55-13" title="13"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb55-14" title="14"><span class="pp">#include </span><span class="im">&lt;poll.h&gt;</span></a>
<a class="sourceLine" id="cb55-15" title="15"></a>
<a class="sourceLine" id="cb55-16" title="16"><span class="pp">#define PORT &quot;9034&quot;   </span><span class="co">// Port we&#39;re listening on</span></a>
<a class="sourceLine" id="cb55-17" title="17"></a>
<a class="sourceLine" id="cb55-18" title="18"><span class="co">// Get sockaddr, IPv4 or IPv6:</span></a>
<a class="sourceLine" id="cb55-19" title="19"><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</a>
<a class="sourceLine" id="cb55-20" title="20">{</a>
<a class="sourceLine" id="cb55-21" title="21">    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</a>
<a class="sourceLine" id="cb55-22" title="22">        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</a>
<a class="sourceLine" id="cb55-23" title="23">    }</a>
<a class="sourceLine" id="cb55-24" title="24"></a>
<a class="sourceLine" id="cb55-25" title="25">    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</a>
<a class="sourceLine" id="cb55-26" title="26">}</a>
<a class="sourceLine" id="cb55-27" title="27"></a>
<a class="sourceLine" id="cb55-28" title="28"><span class="co">// Return a listening socket</span></a>
<a class="sourceLine" id="cb55-29" title="29"><span class="dt">int</span> get_listener_socket(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb55-30" title="30">{</a>
<a class="sourceLine" id="cb55-31" title="31">    <span class="dt">int</span> listener;     <span class="co">// Listening socket descriptor</span></a>
<a class="sourceLine" id="cb55-32" title="32">    <span class="dt">int</span> yes=<span class="dv">1</span>;        <span class="co">// For setsockopt() SO_REUSEADDR, below</span></a>
<a class="sourceLine" id="cb55-33" title="33">    <span class="dt">int</span> rv;</a>
<a class="sourceLine" id="cb55-34" title="34"></a>
<a class="sourceLine" id="cb55-35" title="35">    <span class="kw">struct</span> addrinfo hints, *ai, *p;</a>
<a class="sourceLine" id="cb55-36" title="36"></a>
<a class="sourceLine" id="cb55-37" title="37">    <span class="co">// Get us a socket and bind it</span></a>
<a class="sourceLine" id="cb55-38" title="38">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb55-39" title="39">    hints.ai_family = AF_UNSPEC;</a>
<a class="sourceLine" id="cb55-40" title="40">    hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb55-41" title="41">    hints.ai_flags = AI_PASSIVE;</a>
<a class="sourceLine" id="cb55-42" title="42">    <span class="cf">if</span> ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb55-43" title="43">        fprintf(stderr, <span class="st">&quot;selectserver: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(rv));</a>
<a class="sourceLine" id="cb55-44" title="44">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb55-45" title="45">    }</a>
<a class="sourceLine" id="cb55-46" title="46">    </a>
<a class="sourceLine" id="cb55-47" title="47">    <span class="cf">for</span>(p = ai; p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb55-48" title="48">        listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb55-49" title="49">        <span class="cf">if</span> (listener &lt; <span class="dv">0</span>) { </a>
<a class="sourceLine" id="cb55-50" title="50">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb55-51" title="51">        }</a>
<a class="sourceLine" id="cb55-52" title="52">        </a>
<a class="sourceLine" id="cb55-53" title="53">        <span class="co">// Lose the pesky &quot;address already in use&quot; error message</span></a>
<a class="sourceLine" id="cb55-54" title="54">        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, <span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb55-55" title="55"></a>
<a class="sourceLine" id="cb55-56" title="56">        <span class="cf">if</span> (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb55-57" title="57">            close(listener);</a>
<a class="sourceLine" id="cb55-58" title="58">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb55-59" title="59">        }</a>
<a class="sourceLine" id="cb55-60" title="60"></a>
<a class="sourceLine" id="cb55-61" title="61">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb55-62" title="62">    }</a>
<a class="sourceLine" id="cb55-63" title="63"></a>
<a class="sourceLine" id="cb55-64" title="64">    freeaddrinfo(ai); <span class="co">// All done with this</span></a>
<a class="sourceLine" id="cb55-65" title="65"></a>
<a class="sourceLine" id="cb55-66" title="66">    <span class="co">// If we got here, it means we didn&#39;t get bound</span></a>
<a class="sourceLine" id="cb55-67" title="67">    <span class="cf">if</span> (p == NULL) {</a>
<a class="sourceLine" id="cb55-68" title="68">        <span class="cf">return</span> <span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb55-69" title="69">    }</a>
<a class="sourceLine" id="cb55-70" title="70"></a>
<a class="sourceLine" id="cb55-71" title="71">    <span class="co">// Listen</span></a>
<a class="sourceLine" id="cb55-72" title="72">    <span class="cf">if</span> (listen(listener, <span class="dv">10</span>) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb55-73" title="73">        <span class="cf">return</span> <span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb55-74" title="74">    }</a>
<a class="sourceLine" id="cb55-75" title="75"></a>
<a class="sourceLine" id="cb55-76" title="76">    <span class="cf">return</span> listener;</a>
<a class="sourceLine" id="cb55-77" title="77">}</a>
<a class="sourceLine" id="cb55-78" title="78"></a>
<a class="sourceLine" id="cb55-79" title="79"><span class="co">// Add a new file descriptor to the set</span></a>
<a class="sourceLine" id="cb55-80" title="80"><span class="dt">void</span> add_to_pfds(<span class="kw">struct</span> pollfd *pfds[], <span class="dt">int</span> newfd, <span class="dt">int</span> *fd_count, <span class="dt">int</span> *fd_size)</a>
<a class="sourceLine" id="cb55-81" title="81">{</a>
<a class="sourceLine" id="cb55-82" title="82">    <span class="co">// If we don&#39;t have room, add more space in the pfds array</span></a>
<a class="sourceLine" id="cb55-83" title="83">    <span class="cf">if</span> (*fd_count == *fd_size) {</a>
<a class="sourceLine" id="cb55-84" title="84">        *fd_size *= <span class="dv">2</span>; <span class="co">// Double it</span></a>
<a class="sourceLine" id="cb55-85" title="85"></a>
<a class="sourceLine" id="cb55-86" title="86">        *pfds = realloc(*pfds, <span class="kw">sizeof</span>(**pfds) * (*fd_size));</a>
<a class="sourceLine" id="cb55-87" title="87">    }</a>
<a class="sourceLine" id="cb55-88" title="88"></a>
<a class="sourceLine" id="cb55-89" title="89">    (*pfds)[*fd_count].fd = newfd;</a>
<a class="sourceLine" id="cb55-90" title="90">    (*pfds)[*fd_count].events = POLLIN; <span class="co">// Check ready-to-read</span></a>
<a class="sourceLine" id="cb55-91" title="91"></a>
<a class="sourceLine" id="cb55-92" title="92">    (*fd_count)++;</a>
<a class="sourceLine" id="cb55-93" title="93">}</a>
<a class="sourceLine" id="cb55-94" title="94"></a>
<a class="sourceLine" id="cb55-95" title="95"><span class="co">// Remove an index from the set</span></a>
<a class="sourceLine" id="cb55-96" title="96"><span class="dt">void</span> del_from_pfds(<span class="kw">struct</span> pollfd pfds[], <span class="dt">int</span> i, <span class="dt">int</span> *fd_count)</a>
<a class="sourceLine" id="cb55-97" title="97">{</a>
<a class="sourceLine" id="cb55-98" title="98">    <span class="co">// Copy the one from the end over this one</span></a>
<a class="sourceLine" id="cb55-99" title="99">    pfds[i] = pfds[*fd_count<span class="dv">-1</span>];</a>
<a class="sourceLine" id="cb55-100" title="100"></a>
<a class="sourceLine" id="cb55-101" title="101">    (*fd_count)--;</a>
<a class="sourceLine" id="cb55-102" title="102">}</a>
<a class="sourceLine" id="cb55-103" title="103"></a>
<a class="sourceLine" id="cb55-104" title="104"><span class="co">// Main</span></a>
<a class="sourceLine" id="cb55-105" title="105"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb55-106" title="106">{</a>
<a class="sourceLine" id="cb55-107" title="107">    <span class="dt">int</span> listener;     <span class="co">// Listening socket descriptor</span></a>
<a class="sourceLine" id="cb55-108" title="108"></a>
<a class="sourceLine" id="cb55-109" title="109">    <span class="dt">int</span> newfd;        <span class="co">// Newly accept()ed socket descriptor</span></a>
<a class="sourceLine" id="cb55-110" title="110">    <span class="kw">struct</span> sockaddr_storage remoteaddr; <span class="co">// Client address</span></a>
<a class="sourceLine" id="cb55-111" title="111">    socklen_t addrlen;</a>
<a class="sourceLine" id="cb55-112" title="112"></a>
<a class="sourceLine" id="cb55-113" title="113">    <span class="dt">char</span> buf[<span class="dv">256</span>];    <span class="co">// Buffer for client data</span></a>
<a class="sourceLine" id="cb55-114" title="114"></a>
<a class="sourceLine" id="cb55-115" title="115">    <span class="dt">char</span> remoteIP[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb55-116" title="116"></a>
<a class="sourceLine" id="cb55-117" title="117">    <span class="co">// Start off with room for 5 connections</span></a>
<a class="sourceLine" id="cb55-118" title="118">    <span class="co">// (We&#39;ll realloc as necessary)</span></a>
<a class="sourceLine" id="cb55-119" title="119">    <span class="dt">int</span> fd_count = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb55-120" title="120">    <span class="dt">int</span> fd_size = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb55-121" title="121">    <span class="kw">struct</span> pollfd *pfds = malloc(<span class="kw">sizeof</span> *pfds * fd_size);</a>
<a class="sourceLine" id="cb55-122" title="122"></a>
<a class="sourceLine" id="cb55-123" title="123">    <span class="co">// Set up and get a listening socket</span></a>
<a class="sourceLine" id="cb55-124" title="124">    listener = get_listener_socket();</a>
<a class="sourceLine" id="cb55-125" title="125"></a>
<a class="sourceLine" id="cb55-126" title="126">    <span class="cf">if</span> (listener == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb55-127" title="127">        fprintf(stderr, <span class="st">&quot;error getting listening socket</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb55-128" title="128">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb55-129" title="129">    }</a>
<a class="sourceLine" id="cb55-130" title="130"></a>
<a class="sourceLine" id="cb55-131" title="131">    <span class="co">// Add the listener to set</span></a>
<a class="sourceLine" id="cb55-132" title="132">    pfds[<span class="dv">0</span>].fd = listener;</a>
<a class="sourceLine" id="cb55-133" title="133">    pfds[<span class="dv">0</span>].events = POLLIN; <span class="co">// Report ready to read on incoming connection</span></a>
<a class="sourceLine" id="cb55-134" title="134"></a>
<a class="sourceLine" id="cb55-135" title="135">    fd_count = <span class="dv">1</span>; <span class="co">// For the listener</span></a>
<a class="sourceLine" id="cb55-136" title="136"></a>
<a class="sourceLine" id="cb55-137" title="137">    <span class="co">// Main loop</span></a>
<a class="sourceLine" id="cb55-138" title="138">    <span class="cf">for</span>(;;) {</a>
<a class="sourceLine" id="cb55-139" title="139">        <span class="dt">int</span> poll_count = poll(pfds, fd_count, <span class="dv">-1</span>);</a>
<a class="sourceLine" id="cb55-140" title="140"></a>
<a class="sourceLine" id="cb55-141" title="141">        <span class="cf">if</span> (poll_count == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb55-142" title="142">            perror(<span class="st">&quot;poll&quot;</span>);</a>
<a class="sourceLine" id="cb55-143" title="143">            exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb55-144" title="144">        }</a>
<a class="sourceLine" id="cb55-145" title="145"></a>
<a class="sourceLine" id="cb55-146" title="146">        <span class="co">// Run through the existing connections looking for data to read</span></a>
<a class="sourceLine" id="cb55-147" title="147">        <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; fd_count; i++) {</a>
<a class="sourceLine" id="cb55-148" title="148"></a>
<a class="sourceLine" id="cb55-149" title="149">            <span class="co">// Check if someone&#39;s ready to read</span></a>
<a class="sourceLine" id="cb55-150" title="150">            <span class="cf">if</span> (pfds[i].revents &amp; POLLIN) { <span class="co">// We got one!!</span></a>
<a class="sourceLine" id="cb55-151" title="151"></a>
<a class="sourceLine" id="cb55-152" title="152">                <span class="cf">if</span> (pfds[i].fd == listener) {</a>
<a class="sourceLine" id="cb55-153" title="153">                    <span class="co">// If listener is ready to read, handle new connection</span></a>
<a class="sourceLine" id="cb55-154" title="154"></a>
<a class="sourceLine" id="cb55-155" title="155">                    addrlen = <span class="kw">sizeof</span> remoteaddr;</a>
<a class="sourceLine" id="cb55-156" title="156">                    newfd = accept(listener,</a>
<a class="sourceLine" id="cb55-157" title="157">                        (<span class="kw">struct</span> sockaddr *)&amp;remoteaddr,</a>
<a class="sourceLine" id="cb55-158" title="158">                        &amp;addrlen);</a>
<a class="sourceLine" id="cb55-159" title="159"></a>
<a class="sourceLine" id="cb55-160" title="160">                    <span class="cf">if</span> (newfd == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb55-161" title="161">                        perror(<span class="st">&quot;accept&quot;</span>);</a>
<a class="sourceLine" id="cb55-162" title="162">                    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb55-163" title="163">                        add_to_pfds(&amp;pfds, newfd, &amp;fd_count, &amp;fd_size);</a>
<a class="sourceLine" id="cb55-164" title="164"></a>
<a class="sourceLine" id="cb55-165" title="165">                        printf(<span class="st">&quot;pollserver: new connection from %s on &quot;</span></a>
<a class="sourceLine" id="cb55-166" title="166">                            <span class="st">&quot;socket %d</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb55-167" title="167">                            inet_ntop(remoteaddr.ss_family,</a>
<a class="sourceLine" id="cb55-168" title="168">                                get_in_addr((<span class="kw">struct</span> sockaddr*)&amp;remoteaddr),</a>
<a class="sourceLine" id="cb55-169" title="169">                                remoteIP, INET6_ADDRSTRLEN),</a>
<a class="sourceLine" id="cb55-170" title="170">                            newfd);</a>
<a class="sourceLine" id="cb55-171" title="171">                    }</a>
<a class="sourceLine" id="cb55-172" title="172">                } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb55-173" title="173">                    <span class="co">// If not the listener, we&#39;re just a regular client</span></a>
<a class="sourceLine" id="cb55-174" title="174">                    <span class="dt">int</span> nbytes = recv(pfds[i].fd, buf, <span class="kw">sizeof</span> buf, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb55-175" title="175"></a>
<a class="sourceLine" id="cb55-176" title="176">                    <span class="dt">int</span> sender_fd = pfds[i].fd;</a>
<a class="sourceLine" id="cb55-177" title="177"></a>
<a class="sourceLine" id="cb55-178" title="178">                    <span class="cf">if</span> (nbytes &lt;= <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb55-179" title="179">                        <span class="co">// Got error or connection closed by client</span></a>
<a class="sourceLine" id="cb55-180" title="180">                        <span class="cf">if</span> (nbytes == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb55-181" title="181">                            <span class="co">// Connection closed</span></a>
<a class="sourceLine" id="cb55-182" title="182">                            printf(<span class="st">&quot;pollserver: socket %d hung up</span><span class="sc">\n</span><span class="st">&quot;</span>, sender_fd);</a>
<a class="sourceLine" id="cb55-183" title="183">                        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb55-184" title="184">                            perror(<span class="st">&quot;recv&quot;</span>);</a>
<a class="sourceLine" id="cb55-185" title="185">                        }</a>
<a class="sourceLine" id="cb55-186" title="186"></a>
<a class="sourceLine" id="cb55-187" title="187">                        close(pfds[i].fd); <span class="co">// Bye!</span></a>
<a class="sourceLine" id="cb55-188" title="188"></a>
<a class="sourceLine" id="cb55-189" title="189">                        del_from_pfds(pfds, i, &amp;fd_count);</a>
<a class="sourceLine" id="cb55-190" title="190"></a>
<a class="sourceLine" id="cb55-191" title="191">                    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb55-192" title="192">                        <span class="co">// We got some good data from a client</span></a>
<a class="sourceLine" id="cb55-193" title="193"></a>
<a class="sourceLine" id="cb55-194" title="194">                        <span class="cf">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; fd_count; j++) {</a>
<a class="sourceLine" id="cb55-195" title="195">                            <span class="co">// Send to everyone!</span></a>
<a class="sourceLine" id="cb55-196" title="196">                            <span class="dt">int</span> dest_fd = pfds[j].fd;</a>
<a class="sourceLine" id="cb55-197" title="197"></a>
<a class="sourceLine" id="cb55-198" title="198">                            <span class="co">// Except the listener and ourselves</span></a>
<a class="sourceLine" id="cb55-199" title="199">                            <span class="cf">if</span> (dest_fd != listener &amp;&amp; dest_fd != sender_fd) {</a>
<a class="sourceLine" id="cb55-200" title="200">                                <span class="cf">if</span> (send(dest_fd, buf, nbytes, <span class="dv">0</span>) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb55-201" title="201">                                    perror(<span class="st">&quot;send&quot;</span>);</a>
<a class="sourceLine" id="cb55-202" title="202">                                }</a>
<a class="sourceLine" id="cb55-203" title="203">                            }</a>
<a class="sourceLine" id="cb55-204" title="204">                        }</a>
<a class="sourceLine" id="cb55-205" title="205">                    }</a>
<a class="sourceLine" id="cb55-206" title="206">                } <span class="co">// </span><span class="re">END</span><span class="co"> handle data from client</span></a>
<a class="sourceLine" id="cb55-207" title="207">            } <span class="co">// </span><span class="re">END</span><span class="co"> got ready-to-read from poll()</span></a>
<a class="sourceLine" id="cb55-208" title="208">        } <span class="co">// </span><span class="re">END</span><span class="co"> looping through file descriptors</span></a>
<a class="sourceLine" id="cb55-209" title="209">    } <span class="co">// </span><span class="re">END</span><span class="co"> for(;;)--and you thought it would never end!</span></a>
<a class="sourceLine" id="cb55-210" title="210">    </a>
<a class="sourceLine" id="cb55-211" title="211">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb55-212" title="212">}</a></code></pre></div><p>In the next section, we’ll look at a similar, older function called <code>select()</code>. Both <code>select()</code> and <code>poll()</code> offer similar functionality and performance, and only really differ in how they’re used. <code>select()</code> might be slightly more portable, but is perhaps a little clunkier in use. Choose the one you like the best, as long as it’s supported on your system.</p><p></p><h2 id="select"><span class="header-section-number">7.3</span> <code>select()</code>—Synchronous I/O Multiplexing, Old School</h2><p></p><p>This function is somewhat strange, but it’s very useful. Take the following situation: you are a server and you want to listen for incoming connections as well as keep reading from the connections you already have.</p><p>No problem, you say, just an <code>accept()</code> and a couple of <code>recv()</code>s. Not so fast, buster! What if you’re blocking on an <code>accept()</code> call? How are you going to <code>recv()</code> data at the same time? “Use non-blocking sockets!” No way! You don’t want to be a CPU hog. What, then?</p><p><code>select()</code> gives you the power to monitor several sockets at the same time. It’ll tell you which ones are ready for reading, which are ready for writing, and which sockets have raised exceptions, if you really want to know that.</p><blockquote><p><em>A word of warning: <code>select()</code>, though very portable, is terribly slow when it comes to giant numbers of connections. In those circumstances, you’ll get better performance out of an event library such as <a href="https://libevent.org/">libevent</a><a href="#fn30" class="footnote-ref" id="fnref30"><sup>30</sup></a> that attempts to use the fastest possible method availabile on your system.</em></p></blockquote><p>Without any further ado, I’ll offer the synopsis of <code>select()</code>:</p><div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb56-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/time.h&gt;</span></a>
<a class="sourceLine" id="cb56-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb56-3" title="3"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb56-4" title="4"></a>
<a class="sourceLine" id="cb56-5" title="5"><span class="dt">int</span> select(<span class="dt">int</span> numfds, fd_set *readfds, fd_set *writefds,</a>
<a class="sourceLine" id="cb56-6" title="6">           fd_set *exceptfds, <span class="kw">struct</span> timeval *timeout); </a></code></pre></div><p>The function monitors “sets” of file descriptors; in particular <code>readfds</code>, <code>writefds</code>, and <code>exceptfds</code>. If you want to see if you can read from standard input and some socket descriptor, <code>sockfd</code>, just add the file descriptors <code>0</code> and <code>sockfd</code> to the set <code>readfds</code>. The parameter <code>numfds</code> should be set to the values of the highest file descriptor plus one. In this example, it should be set to <code>sockfd+1</code>, since it is assuredly higher than standard input (<code>0</code>).</p><p>When <code>select()</code> returns, <code>readfds</code> will be modified to reflect which of the file descriptors you selected which is ready for reading. You can test them with the macro <code>FD_ISSET()</code>, below.</p><p>Before progressing much further, I’ll talk about how to manipulate these sets. Each set is of the type <code>fd_set</code>. The following macros operate on this type:</p><table><thead><tr class="header"><th>Function</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>FD_SET(int fd, fd_set *set);</code></td><td>Add <code>fd</code> to the <code>set</code>.</td></tr><tr class="even"><td><code>FD_CLR(int fd, fd_set *set);</code></td><td>Remove <code>fd</code> from the <code>set</code>.</td></tr><tr class="odd"><td><code>FD_ISSET(int fd, fd_set *set);</code></td><td>Return true if <code>fd</code> is in the <code>set</code>.</td></tr><tr class="even"><td><code>FD_ZERO(fd_set *set);</code></td><td>Clear all entries from the <code>set</code>.</td></tr></tbody></table><p></p><p>Finally, what is this weirded-out <code>struct timeval</code>? Well, sometimes you don’t want to wait forever for someone to send you some data. Maybe every 96 seconds you want to print “Still Going…” to the terminal even though nothing has happened. This time structure allows you to specify a timeout period. If the time is exceeded and <code>select()</code> still hasn’t found any ready file descriptors, it’ll return so you can continue processing.</p><p>The <code>struct timeval</code> has the follow fields:</p><div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb57-1" title="1"><span class="kw">struct</span> timeval {</a>
<a class="sourceLine" id="cb57-2" title="2">    <span class="dt">int</span> tv_sec;     <span class="co">// seconds</span></a>
<a class="sourceLine" id="cb57-3" title="3">    <span class="dt">int</span> tv_usec;    <span class="co">// microseconds</span></a>
<a class="sourceLine" id="cb57-4" title="4">}; </a></code></pre></div><p>Just set <code>tv_sec</code> to the number of seconds to wait, and set <code>tv_usec</code> to the number of microseconds to wait. Yes, that’s _micro_seconds, not milliseconds. There are 1,000 microseconds in a millisecond, and 1,000 milliseconds in a second. Thus, there are 1,000,000 microseconds in a second. Why is it “usec”? The “u” is supposed to look like the Greek letter μ (Mu) that we use for “micro”. Also, when the function returns, <code>timeout</code> <em>might</em> be updated to show the time still remaining. This depends on what flavor of Unix you’re running.</p><p>Yay! We have a microsecond resolution timer! Well, don’t count on it. You’ll probably have to wait some part of your standard Unix timeslice no matter how small you set your <code>struct timeval</code>.</p><p>Other things of interest: If you set the fields in your <code>struct timeval</code> to <code>0</code>, <code>select()</code> will timeout immediately, effectively polling all the file descriptors in your sets. If you set the parameter <code>timeout</code> to NULL, it will never timeout, and will wait until the first file descriptor is ready. Finally, if you don’t care about waiting for a certain set, you can just set it to NULL in the call to <code>select()</code>.</p><p><a href="https://beej.us/guide/bgnet/examples/select.c">The following code snippet</a><a href="#fn31" class="footnote-ref" id="fnref31"><sup>31</sup></a> waits 2.5 seconds for something to appear on standard input:</p><div class="sourceCode" id="cb58"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb58-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb58-2" title="2"><span class="co">** select.c -- a select() demo</span></a>
<a class="sourceLine" id="cb58-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb58-4" title="4"></a>
<a class="sourceLine" id="cb58-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb58-6" title="6"><span class="pp">#include </span><span class="im">&lt;sys/time.h&gt;</span></a>
<a class="sourceLine" id="cb58-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb58-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb58-9" title="9"></a>
<a class="sourceLine" id="cb58-10" title="10"><span class="pp">#define STDIN 0  </span><span class="co">// file descriptor for standard input</span></a>
<a class="sourceLine" id="cb58-11" title="11"></a>
<a class="sourceLine" id="cb58-12" title="12"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb58-13" title="13">{</a>
<a class="sourceLine" id="cb58-14" title="14">    <span class="kw">struct</span> timeval tv;</a>
<a class="sourceLine" id="cb58-15" title="15">    fd_set readfds;</a>
<a class="sourceLine" id="cb58-16" title="16"></a>
<a class="sourceLine" id="cb58-17" title="17">    tv.tv_sec = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb58-18" title="18">    tv.tv_usec = <span class="dv">500000</span>;</a>
<a class="sourceLine" id="cb58-19" title="19"></a>
<a class="sourceLine" id="cb58-20" title="20">    FD_ZERO(&amp;readfds);</a>
<a class="sourceLine" id="cb58-21" title="21">    FD_SET(STDIN, &amp;readfds);</a>
<a class="sourceLine" id="cb58-22" title="22"></a>
<a class="sourceLine" id="cb58-23" title="23">    <span class="co">// don&#39;t care about writefds and exceptfds:</span></a>
<a class="sourceLine" id="cb58-24" title="24">    select(STDIN+<span class="dv">1</span>, &amp;readfds, NULL, NULL, &amp;tv);</a>
<a class="sourceLine" id="cb58-25" title="25"></a>
<a class="sourceLine" id="cb58-26" title="26">    <span class="cf">if</span> (FD_ISSET(STDIN, &amp;readfds))</a>
<a class="sourceLine" id="cb58-27" title="27">        printf(<span class="st">&quot;A key was pressed!</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb58-28" title="28">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb58-29" title="29">        printf(<span class="st">&quot;Timed out.</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb58-30" title="30"></a>
<a class="sourceLine" id="cb58-31" title="31">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb58-32" title="32">} </a></code></pre></div><p>If you’re on a line buffered terminal, the key you hit should be RETURN or it will time out anyway.</p><p>Now, some of you might think this is a great way to wait for data on a datagram socket—and you are right: it <em>might</em> be. Some Unices can use select in this manner, and some can’t. You should see what your local man page says on the matter if you want to attempt it.</p><p>Some Unices update the time in your <code>struct timeval</code> to reflect the amount of time still remaining before a timeout. But others do not. Don’t rely on that occurring if you want to be portable. (Use  <code>gettimeofday()</code> if you need to track time elapsed. It’s a bummer, I know, but that’s the way it is.)</p><p></p><p>What happens if a socket in the read set closes the connection? Well, in that case, <code>select()</code> returns with that socket descriptor set as “ready to read”. When you actually do <code>recv()</code> from it, <code>recv()</code> will return <code>0</code>. That’s how you know the client has closed the connection.</p><p>One more note of interest about <code>select()</code>: if you have a socket that is   <code>listen()</code>ing, you can check to see if there is a new connection by putting that socket’s file descriptor in the <code>readfds</code> set.</p><p>And that, my friends, is a quick overview of the almighty <code>select()</code> function.</p><p>But, by popular demand, here is an in-depth example. Unfortunately, the difference between the dirt-simple example, above, and this one here is significant. But have a look, then read the description that follows it.</p><p><a href="https://beej.us/guide/bgnet/examples/selectserver.c">This program</a><a href="#fn32" class="footnote-ref" id="fnref32"><sup>32</sup></a> acts like a simple multi-user chat server. Start it running in one window, then <code>telnet</code> to it (“<code>telnet hostname 9034</code>”) from multiple other windows. When you type something in one <code>telnet</code> session, it should appear in all the others.</p><div class="sourceCode" id="cb59"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb59-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb59-2" title="2"><span class="co">** selectserver.c -- a cheezy multiperson chat server</span></a>
<a class="sourceLine" id="cb59-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb59-4" title="4"></a>
<a class="sourceLine" id="cb59-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb59-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb59-7" title="7"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb59-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb59-9" title="9"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb59-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb59-11" title="11"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb59-12" title="12"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb59-13" title="13"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb59-14" title="14"></a>
<a class="sourceLine" id="cb59-15" title="15"><span class="pp">#define PORT &quot;9034&quot;   </span><span class="co">// port we&#39;re listening on</span></a>
<a class="sourceLine" id="cb59-16" title="16"></a>
<a class="sourceLine" id="cb59-17" title="17"><span class="co">// get sockaddr, IPv4 or IPv6:</span></a>
<a class="sourceLine" id="cb59-18" title="18"><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</a>
<a class="sourceLine" id="cb59-19" title="19">{</a>
<a class="sourceLine" id="cb59-20" title="20">    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</a>
<a class="sourceLine" id="cb59-21" title="21">        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</a>
<a class="sourceLine" id="cb59-22" title="22">    }</a>
<a class="sourceLine" id="cb59-23" title="23"></a>
<a class="sourceLine" id="cb59-24" title="24">    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</a>
<a class="sourceLine" id="cb59-25" title="25">}</a>
<a class="sourceLine" id="cb59-26" title="26"></a>
<a class="sourceLine" id="cb59-27" title="27"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb59-28" title="28">{</a>
<a class="sourceLine" id="cb59-29" title="29">    fd_set master;    <span class="co">// master file descriptor list</span></a>
<a class="sourceLine" id="cb59-30" title="30">    fd_set read_fds;  <span class="co">// temp file descriptor list for select()</span></a>
<a class="sourceLine" id="cb59-31" title="31">    <span class="dt">int</span> fdmax;        <span class="co">// maximum file descriptor number</span></a>
<a class="sourceLine" id="cb59-32" title="32"></a>
<a class="sourceLine" id="cb59-33" title="33">    <span class="dt">int</span> listener;     <span class="co">// listening socket descriptor</span></a>
<a class="sourceLine" id="cb59-34" title="34">    <span class="dt">int</span> newfd;        <span class="co">// newly accept()ed socket descriptor</span></a>
<a class="sourceLine" id="cb59-35" title="35">    <span class="kw">struct</span> sockaddr_storage remoteaddr; <span class="co">// client address</span></a>
<a class="sourceLine" id="cb59-36" title="36">    socklen_t addrlen;</a>
<a class="sourceLine" id="cb59-37" title="37"></a>
<a class="sourceLine" id="cb59-38" title="38">    <span class="dt">char</span> buf[<span class="dv">256</span>];    <span class="co">// buffer for client data</span></a>
<a class="sourceLine" id="cb59-39" title="39">    <span class="dt">int</span> nbytes;</a>
<a class="sourceLine" id="cb59-40" title="40"></a>
<a class="sourceLine" id="cb59-41" title="41">    <span class="dt">char</span> remoteIP[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb59-42" title="42"></a>
<a class="sourceLine" id="cb59-43" title="43">    <span class="dt">int</span> yes=<span class="dv">1</span>;        <span class="co">// for setsockopt() SO_REUSEADDR, below</span></a>
<a class="sourceLine" id="cb59-44" title="44">    <span class="dt">int</span> i, j, rv;</a>
<a class="sourceLine" id="cb59-45" title="45"></a>
<a class="sourceLine" id="cb59-46" title="46">    <span class="kw">struct</span> addrinfo hints, *ai, *p;</a>
<a class="sourceLine" id="cb59-47" title="47"></a>
<a class="sourceLine" id="cb59-48" title="48">    FD_ZERO(&amp;master);    <span class="co">// clear the master and temp sets</span></a>
<a class="sourceLine" id="cb59-49" title="49">    FD_ZERO(&amp;read_fds);</a>
<a class="sourceLine" id="cb59-50" title="50"></a>
<a class="sourceLine" id="cb59-51" title="51">    <span class="co">// get us a socket and bind it</span></a>
<a class="sourceLine" id="cb59-52" title="52">    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb59-53" title="53">    hints.ai_family = AF_UNSPEC;</a>
<a class="sourceLine" id="cb59-54" title="54">    hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb59-55" title="55">    hints.ai_flags = AI_PASSIVE;</a>
<a class="sourceLine" id="cb59-56" title="56">    <span class="cf">if</span> ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb59-57" title="57">        fprintf(stderr, <span class="st">&quot;selectserver: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(rv));</a>
<a class="sourceLine" id="cb59-58" title="58">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb59-59" title="59">    }</a>
<a class="sourceLine" id="cb59-60" title="60">    </a>
<a class="sourceLine" id="cb59-61" title="61">    <span class="cf">for</span>(p = ai; p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb59-62" title="62">        listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb59-63" title="63">        <span class="cf">if</span> (listener &lt; <span class="dv">0</span>) { </a>
<a class="sourceLine" id="cb59-64" title="64">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb59-65" title="65">        }</a>
<a class="sourceLine" id="cb59-66" title="66">        </a>
<a class="sourceLine" id="cb59-67" title="67">        <span class="co">// lose the pesky &quot;address already in use&quot; error message</span></a>
<a class="sourceLine" id="cb59-68" title="68">        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, <span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb59-69" title="69"></a>
<a class="sourceLine" id="cb59-70" title="70">        <span class="cf">if</span> (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb59-71" title="71">            close(listener);</a>
<a class="sourceLine" id="cb59-72" title="72">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb59-73" title="73">        }</a>
<a class="sourceLine" id="cb59-74" title="74"></a>
<a class="sourceLine" id="cb59-75" title="75">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb59-76" title="76">    }</a>
<a class="sourceLine" id="cb59-77" title="77"></a>
<a class="sourceLine" id="cb59-78" title="78">    <span class="co">// if we got here, it means we didn&#39;t get bound</span></a>
<a class="sourceLine" id="cb59-79" title="79">    <span class="cf">if</span> (p == NULL) {</a>
<a class="sourceLine" id="cb59-80" title="80">        fprintf(stderr, <span class="st">&quot;selectserver: failed to bind</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb59-81" title="81">        exit(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb59-82" title="82">    }</a>
<a class="sourceLine" id="cb59-83" title="83"></a>
<a class="sourceLine" id="cb59-84" title="84">    freeaddrinfo(ai); <span class="co">// all done with this</span></a>
<a class="sourceLine" id="cb59-85" title="85"></a>
<a class="sourceLine" id="cb59-86" title="86">    <span class="co">// listen</span></a>
<a class="sourceLine" id="cb59-87" title="87">    <span class="cf">if</span> (listen(listener, <span class="dv">10</span>) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb59-88" title="88">        perror(<span class="st">&quot;listen&quot;</span>);</a>
<a class="sourceLine" id="cb59-89" title="89">        exit(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb59-90" title="90">    }</a>
<a class="sourceLine" id="cb59-91" title="91"></a>
<a class="sourceLine" id="cb59-92" title="92">    <span class="co">// add the listener to the master set</span></a>
<a class="sourceLine" id="cb59-93" title="93">    FD_SET(listener, &amp;master);</a>
<a class="sourceLine" id="cb59-94" title="94"></a>
<a class="sourceLine" id="cb59-95" title="95">    <span class="co">// keep track of the biggest file descriptor</span></a>
<a class="sourceLine" id="cb59-96" title="96">    fdmax = listener; <span class="co">// so far, it&#39;s this one</span></a>
<a class="sourceLine" id="cb59-97" title="97"></a>
<a class="sourceLine" id="cb59-98" title="98">    <span class="co">// main loop</span></a>
<a class="sourceLine" id="cb59-99" title="99">    <span class="cf">for</span>(;;) {</a>
<a class="sourceLine" id="cb59-100" title="100">        read_fds = master; <span class="co">// copy it</span></a>
<a class="sourceLine" id="cb59-101" title="101">        <span class="cf">if</span> (select(fdmax+<span class="dv">1</span>, &amp;read_fds, NULL, NULL, NULL) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb59-102" title="102">            perror(<span class="st">&quot;select&quot;</span>);</a>
<a class="sourceLine" id="cb59-103" title="103">            exit(<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb59-104" title="104">        }</a>
<a class="sourceLine" id="cb59-105" title="105"></a>
<a class="sourceLine" id="cb59-106" title="106">        <span class="co">// run through the existing connections looking for data to read</span></a>
<a class="sourceLine" id="cb59-107" title="107">        <span class="cf">for</span>(i = <span class="dv">0</span>; i &lt;= fdmax; i++) {</a>
<a class="sourceLine" id="cb59-108" title="108">            <span class="cf">if</span> (FD_ISSET(i, &amp;read_fds)) { <span class="co">// we got one!!</span></a>
<a class="sourceLine" id="cb59-109" title="109">                <span class="cf">if</span> (i == listener) {</a>
<a class="sourceLine" id="cb59-110" title="110">                    <span class="co">// handle new connections</span></a>
<a class="sourceLine" id="cb59-111" title="111">                    addrlen = <span class="kw">sizeof</span> remoteaddr;</a>
<a class="sourceLine" id="cb59-112" title="112">                    newfd = accept(listener,</a>
<a class="sourceLine" id="cb59-113" title="113">                        (<span class="kw">struct</span> sockaddr *)&amp;remoteaddr,</a>
<a class="sourceLine" id="cb59-114" title="114">                        &amp;addrlen);</a>
<a class="sourceLine" id="cb59-115" title="115"></a>
<a class="sourceLine" id="cb59-116" title="116">                    <span class="cf">if</span> (newfd == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb59-117" title="117">                        perror(<span class="st">&quot;accept&quot;</span>);</a>
<a class="sourceLine" id="cb59-118" title="118">                    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb59-119" title="119">                        FD_SET(newfd, &amp;master); <span class="co">// add to master set</span></a>
<a class="sourceLine" id="cb59-120" title="120">                        <span class="cf">if</span> (newfd &gt; fdmax) {    <span class="co">// keep track of the max</span></a>
<a class="sourceLine" id="cb59-121" title="121">                            fdmax = newfd;</a>
<a class="sourceLine" id="cb59-122" title="122">                        }</a>
<a class="sourceLine" id="cb59-123" title="123">                        printf(<span class="st">&quot;selectserver: new connection from %s on &quot;</span></a>
<a class="sourceLine" id="cb59-124" title="124">                            <span class="st">&quot;socket %d</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb59-125" title="125">                            inet_ntop(remoteaddr.ss_family,</a>
<a class="sourceLine" id="cb59-126" title="126">                                get_in_addr((<span class="kw">struct</span> sockaddr*)&amp;remoteaddr),</a>
<a class="sourceLine" id="cb59-127" title="127">                                remoteIP, INET6_ADDRSTRLEN),</a>
<a class="sourceLine" id="cb59-128" title="128">                            newfd);</a>
<a class="sourceLine" id="cb59-129" title="129">                    }</a>
<a class="sourceLine" id="cb59-130" title="130">                } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb59-131" title="131">                    <span class="co">// handle data from a client</span></a>
<a class="sourceLine" id="cb59-132" title="132">                    <span class="cf">if</span> ((nbytes = recv(i, buf, <span class="kw">sizeof</span> buf, <span class="dv">0</span>)) &lt;= <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb59-133" title="133">                        <span class="co">// got error or connection closed by client</span></a>
<a class="sourceLine" id="cb59-134" title="134">                        <span class="cf">if</span> (nbytes == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb59-135" title="135">                            <span class="co">// connection closed</span></a>
<a class="sourceLine" id="cb59-136" title="136">                            printf(<span class="st">&quot;selectserver: socket %d hung up</span><span class="sc">\n</span><span class="st">&quot;</span>, i);</a>
<a class="sourceLine" id="cb59-137" title="137">                        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb59-138" title="138">                            perror(<span class="st">&quot;recv&quot;</span>);</a>
<a class="sourceLine" id="cb59-139" title="139">                        }</a>
<a class="sourceLine" id="cb59-140" title="140">                        close(i); <span class="co">// bye!</span></a>
<a class="sourceLine" id="cb59-141" title="141">                        FD_CLR(i, &amp;master); <span class="co">// remove from master set</span></a>
<a class="sourceLine" id="cb59-142" title="142">                    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb59-143" title="143">                        <span class="co">// we got some data from a client</span></a>
<a class="sourceLine" id="cb59-144" title="144">                        <span class="cf">for</span>(j = <span class="dv">0</span>; j &lt;= fdmax; j++) {</a>
<a class="sourceLine" id="cb59-145" title="145">                            <span class="co">// send to everyone!</span></a>
<a class="sourceLine" id="cb59-146" title="146">                            <span class="cf">if</span> (FD_ISSET(j, &amp;master)) {</a>
<a class="sourceLine" id="cb59-147" title="147">                                <span class="co">// except the listener and ourselves</span></a>
<a class="sourceLine" id="cb59-148" title="148">                                <span class="cf">if</span> (j != listener &amp;&amp; j != i) {</a>
<a class="sourceLine" id="cb59-149" title="149">                                    <span class="cf">if</span> (send(j, buf, nbytes, <span class="dv">0</span>) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb59-150" title="150">                                        perror(<span class="st">&quot;send&quot;</span>);</a>
<a class="sourceLine" id="cb59-151" title="151">                                    }</a>
<a class="sourceLine" id="cb59-152" title="152">                                }</a>
<a class="sourceLine" id="cb59-153" title="153">                            }</a>
<a class="sourceLine" id="cb59-154" title="154">                        }</a>
<a class="sourceLine" id="cb59-155" title="155">                    }</a>
<a class="sourceLine" id="cb59-156" title="156">                } <span class="co">// </span><span class="re">END</span><span class="co"> handle data from client</span></a>
<a class="sourceLine" id="cb59-157" title="157">            } <span class="co">// </span><span class="re">END</span><span class="co"> got new incoming connection</span></a>
<a class="sourceLine" id="cb59-158" title="158">        } <span class="co">// </span><span class="re">END</span><span class="co"> looping through file descriptors</span></a>
<a class="sourceLine" id="cb59-159" title="159">    } <span class="co">// </span><span class="re">END</span><span class="co"> for(;;)--and you thought it would never end!</span></a>
<a class="sourceLine" id="cb59-160" title="160">    </a>
<a class="sourceLine" id="cb59-161" title="161">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb59-162" title="162">}</a></code></pre></div><p>Notice I have two file descriptor sets in the code: <code>master</code> and <code>read_fds</code>. The first, <code>master</code>, holds all the socket descriptors that are currently connected, as well as the socket descriptor that is listening for new connections.</p><p>The reason I have the <code>master</code> set is that <code>select()</code> actually <em>changes</em> the set you pass into it to reflect which sockets are ready to read. Since I have to keep track of the connections from one call of <code>select()</code> to the next, I must store these safely away somewhere. At the last minute, I copy the <code>master</code> into the <code>read_fds</code>, and then call <code>select()</code>.</p><p>But doesn’t this mean that every time I get a new connection, I have to add it to the <code>master</code> set? Yup! And every time a connection closes, I have to remove it from the <code>master</code> set? Yes, it does.</p><p>Notice I check to see when the <code>listener</code> socket is ready to read. When it is, it means I have a new connection pending, and I <code>accept()</code> it and add it to the <code>master</code> set. Similarly, when a client connection is ready to read, and <code>recv()</code> returns <code>0</code>, I know the client has closed the connection, and I must remove it from the <code>master</code> set.</p><p>If the client <code>recv()</code> returns non-zero, though, I know some data has been received. So I get it, and then go through the <code>master</code> list and send that data to all the rest of the connected clients.</p><p>And that, my friends, is a less-than-simple overview of the almighty <code>select()</code> function.</p><p>Quick note to all you Linux fans out there: sometimes, in rare circumstances, Linux’s <code>select()</code> can return “ready-to-read” and then not actually be ready to read! This means it will block on the <code>read()</code> after the <code>select()</code> says it won’t! Why you little—! Anyway, the workaround solution is to set the  <code>O_NONBLOCK</code> flag on the receiving socket so it errors with <code>EWOULDBLOCK</code> (which you can just safely ignore if it occurs). See the <a href="#fcntlman"><code>fcntl()</code> reference page</a> for more info on setting a socket to non-blocking.</p><p>In addition, here is a bonus afterthought: there is another function called  <code>poll()</code> which behaves much the same way <code>select()</code> does, but with a different system for managing the file descriptor sets. <a href="#pollman">Check it out!</a></p><p></p><h2 id="sendall"><span class="header-section-number">7.4</span> Handling Partial <code>send()</code>s</h2><p>Remember back in the <a href="#sendrecv">section about <code>send()</code></a>, above, when I said that <code>send()</code> might not send all the bytes you asked it to? That is, you want it to send 512 bytes, but it returns 412. What happened to the remaining 100 bytes?</p><p>Well, they’re still in your little buffer waiting to be sent out. Due to circumstances beyond your control, the kernel decided not to send all the data out in one chunk, and now, my friend, it’s up to you to get the data out there.</p><p> You could write a function like this to do it, too:</p><div class="sourceCode" id="cb60"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb60-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb60-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb60-3" title="3"></a>
<a class="sourceLine" id="cb60-4" title="4"><span class="dt">int</span> sendall(<span class="dt">int</span> s, <span class="dt">char</span> *buf, <span class="dt">int</span> *len)</a>
<a class="sourceLine" id="cb60-5" title="5">{</a>
<a class="sourceLine" id="cb60-6" title="6">    <span class="dt">int</span> total = <span class="dv">0</span>;        <span class="co">// how many bytes we&#39;ve sent</span></a>
<a class="sourceLine" id="cb60-7" title="7">    <span class="dt">int</span> bytesleft = *len; <span class="co">// how many we have left to send</span></a>
<a class="sourceLine" id="cb60-8" title="8">    <span class="dt">int</span> n;</a>
<a class="sourceLine" id="cb60-9" title="9"></a>
<a class="sourceLine" id="cb60-10" title="10">    <span class="cf">while</span>(total &lt; *len) {</a>
<a class="sourceLine" id="cb60-11" title="11">        n = send(s, buf+total, bytesleft, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb60-12" title="12">        <span class="cf">if</span> (n == <span class="dv">-1</span>) { <span class="cf">break</span>; }</a>
<a class="sourceLine" id="cb60-13" title="13">        total += n;</a>
<a class="sourceLine" id="cb60-14" title="14">        bytesleft -= n;</a>
<a class="sourceLine" id="cb60-15" title="15">    }</a>
<a class="sourceLine" id="cb60-16" title="16"></a>
<a class="sourceLine" id="cb60-17" title="17">    *len = total; <span class="co">// return number actually sent here</span></a>
<a class="sourceLine" id="cb60-18" title="18"></a>
<a class="sourceLine" id="cb60-19" title="19">    <span class="cf">return</span> n==-<span class="dv">1</span>?-<span class="dv">1</span>:<span class="dv">0</span>; <span class="co">// return -1 on failure, 0 on success</span></a>
<a class="sourceLine" id="cb60-20" title="20">} </a></code></pre></div><p>In this example, <code>s</code> is the socket you want to send the data to, <code>buf</code> is the buffer containing the data, and <code>len</code> is a pointer to an <code>int</code> containing the number of bytes in the buffer.</p><p>The function returns <code>-1</code> on error (and <code>errno</code> is still set from the call to <code>send()</code>). Also, the number of bytes actually sent is returned in <code>len</code>. This will be the same number of bytes you asked it to send, unless there was an error. <code>sendall()</code> will do it’s best, huffing and puffing, to send the data out, but if there’s an error, it gets back to you right away.</p><p>For completeness, here’s a sample call to the function:</p><div class="sourceCode" id="cb61"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb61-1" title="1"><span class="dt">char</span> buf[<span class="dv">10</span>] = <span class="st">&quot;Beej!&quot;</span>;</a>
<a class="sourceLine" id="cb61-2" title="2"><span class="dt">int</span> len;</a>
<a class="sourceLine" id="cb61-3" title="3"></a>
<a class="sourceLine" id="cb61-4" title="4">len = strlen(buf);</a>
<a class="sourceLine" id="cb61-5" title="5"><span class="cf">if</span> (sendall(s, buf, &amp;len) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb61-6" title="6">    perror(<span class="st">&quot;sendall&quot;</span>);</a>
<a class="sourceLine" id="cb61-7" title="7">    printf(<span class="st">&quot;We only sent %d bytes because of the error!</span><span class="sc">\n</span><span class="st">&quot;</span>, len);</a>
<a class="sourceLine" id="cb61-8" title="8">} </a></code></pre></div><p></p><p>What happens on the receiver’s end when part of a packet arrives? If the packets are variable length, how does the receiver know when one packet ends and another begins? Yes, real-world scenarios are a royal pain in the  donkeys. You probably have to  <em>encapsulate</em> (remember that from the <a href="#lowlevel">data encapsulation section</a> way back there at the beginning?) Read on for details!</p><h2 id="serialization"><span class="header-section-number">7.5</span> Serialization—How to Pack Data</h2><p></p><p>It’s easy enough to send text data across the network, you’re finding, but what happens if you want to send some “binary” data like <code>int</code>s or <code>float</code>s? It turns out you have a few options.</p><ol type="1"><li><p>Convert the number into text with a function like <code>sprintf()</code>, then send the text. The receiver will parse the text back into a number using a function like <code>strtol()</code>.</p></li><li><p>Just send the data raw, passing a pointer to the data to <code>send()</code>.</p></li><li><p>Encode the number into a portable binary form. The receiver will decode it.</p></li></ol><p>Sneak preview! Tonight only!</p><p>[<em>Curtain raises</em>]</p><p>Beej says, “I prefer Method Three, above!”</p><p>[<em>THE END</em>]</p><p>(Before I begin this section in earnest, I should tell you that there are libraries out there for doing this, and rolling your own and remaining portable and error-free is quite a challenge. So hunt around and do your homework before deciding to implement this stuff yourself. I include the information here for those curious about how things like this work.)</p><p>Actually all the methods, above, have their drawbacks and advantages, but, like I said, in general, I prefer the third method. First, though, let’s talk about some of the drawbacks and advantages to the other two.</p><p>The first method, encoding the numbers as text before sending, has the advantage that you can easily print and read the data that’s coming over the wire. Sometimes a human-readable protocol is excellent to use in a non-bandwidth-intensive situation, such as with  <a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">Internet Relay Chat (IRC)</a><a href="#fn33" class="footnote-ref" id="fnref33"><sup>33</sup></a>. However, it has the disadvantage that it is slow to convert, and the results almost always take up more space than the original number!</p><p>Method two: passing the raw data. This one is quite easy (but dangerous!): just take a pointer to the data to send, and call send with it.</p><div class="sourceCode" id="cb62"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb62-1" title="1"><span class="dt">double</span> d = <span class="fl">3490.15926535</span>;</a>
<a class="sourceLine" id="cb62-2" title="2"></a>
<a class="sourceLine" id="cb62-3" title="3">send(s, &amp;d, <span class="kw">sizeof</span> d, <span class="dv">0</span>);  <span class="co">/* </span><span class="al">DANGER</span><span class="co">--non-portable! */</span></a></code></pre></div><p>The receiver gets it like this:</p><div class="sourceCode" id="cb63"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb63-1" title="1"><span class="dt">double</span> d;</a>
<a class="sourceLine" id="cb63-2" title="2"></a>
<a class="sourceLine" id="cb63-3" title="3">recv(s, &amp;d, <span class="kw">sizeof</span> d, <span class="dv">0</span>);  <span class="co">/* </span><span class="al">DANGER</span><span class="co">--non-portable! */</span></a></code></pre></div><p>Fast, simple—what’s not to like? Well, it turns out that not all architectures represent a <code>double</code> (or <code>int</code> for that matter) with the same bit representation or even the same byte ordering! The code is decidedly non-portable. (Hey—maybe you don’t need portability, in which case this is nice and fast.)</p><p>When packing integer types, we’ve already seen how the  <code>htons()</code>-class of functions can help keep things portable by transforming the numbers into  Network Byte Order, and how that’s the Right Thing to do. Unfortunately, there are no similar functions for <code>float</code> types. Is all hope lost?</p><p>Fear not! (Were you afraid there for a second? No? Not even a little bit?) There is something we can do: we can pack (or “marshal”, or “serialize”, or one of a thousand million other names) the data into a known binary format that the receiver can unpack on the remote side.</p><p>What do I mean by “known binary format”? Well, we’ve already seen the <code>htons()</code> example, right? It changes (or “encodes”, if you want to think of it that way) a number from whatever the host format is into Network Byte Order. To reverse (unencode) the number, the receiver calls <code>ntohs()</code>.</p><p>But didn’t I just get finished saying there wasn’t any such function for other non-integer types? Yes. I did. And since there’s no standard way in C to do this, it’s a bit of a pickle (that a gratuitous pun there for you Python fans).</p><p>The thing to do is to pack the data into a known format and send that over the wire for decoding. For example, to pack <code>float</code>s, here’s <a href="https://beej.us/guide/bgnet/examples/pack.c">something quick and dirty with plenty of room for improvement</a><a href="#fn34" class="footnote-ref" id="fnref34"><sup>34</sup></a>:</p><div class="sourceCode" id="cb64"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb64-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb64-2" title="2"></a>
<a class="sourceLine" id="cb64-3" title="3"><span class="dt">uint32_t</span> htonf(<span class="dt">float</span> f)</a>
<a class="sourceLine" id="cb64-4" title="4">{</a>
<a class="sourceLine" id="cb64-5" title="5">    <span class="dt">uint32_t</span> p;</a>
<a class="sourceLine" id="cb64-6" title="6">    <span class="dt">uint32_t</span> sign;</a>
<a class="sourceLine" id="cb64-7" title="7"></a>
<a class="sourceLine" id="cb64-8" title="8">    <span class="cf">if</span> (f &lt; <span class="dv">0</span>) { sign = <span class="dv">1</span>; f = -f; }</a>
<a class="sourceLine" id="cb64-9" title="9">    <span class="cf">else</span> { sign = <span class="dv">0</span>; }</a>
<a class="sourceLine" id="cb64-10" title="10">        </a>
<a class="sourceLine" id="cb64-11" title="11">    p = ((((<span class="dt">uint32_t</span>)f)&amp;<span class="bn">0x7fff</span>)&lt;&lt;<span class="dv">16</span>) | (sign&lt;&lt;<span class="dv">31</span>); <span class="co">// whole part and sign</span></a>
<a class="sourceLine" id="cb64-12" title="12">    p |= (<span class="dt">uint32_t</span>)(((f - (<span class="dt">int</span>)f) * <span class="fl">65536.0f</span>))&amp;<span class="bn">0xffff</span>; <span class="co">// fraction</span></a>
<a class="sourceLine" id="cb64-13" title="13"></a>
<a class="sourceLine" id="cb64-14" title="14">    <span class="cf">return</span> p;</a>
<a class="sourceLine" id="cb64-15" title="15">}</a>
<a class="sourceLine" id="cb64-16" title="16"></a>
<a class="sourceLine" id="cb64-17" title="17"><span class="dt">float</span> ntohf(<span class="dt">uint32_t</span> p)</a>
<a class="sourceLine" id="cb64-18" title="18">{</a>
<a class="sourceLine" id="cb64-19" title="19">    <span class="dt">float</span> f = ((p&gt;&gt;<span class="dv">16</span>)&amp;<span class="bn">0x7fff</span>); <span class="co">// whole part</span></a>
<a class="sourceLine" id="cb64-20" title="20">    f += (p&amp;<span class="bn">0xffff</span>) / <span class="fl">65536.0f</span>; <span class="co">// fraction</span></a>
<a class="sourceLine" id="cb64-21" title="21"></a>
<a class="sourceLine" id="cb64-22" title="22">    <span class="cf">if</span> (((p&gt;&gt;<span class="dv">31</span>)&amp;<span class="bn">0x1</span>) == <span class="bn">0x1</span>) { f = -f; } <span class="co">// sign bit set</span></a>
<a class="sourceLine" id="cb64-23" title="23"></a>
<a class="sourceLine" id="cb64-24" title="24">    <span class="cf">return</span> f;</a>
<a class="sourceLine" id="cb64-25" title="25">}</a></code></pre></div><p>The above code is sort of a naive implementation that stores a <code>float</code> in a 32-bit number. The high bit (31) is used to store the sign of the number (“1” means negative), and the next seven bits (30-16) are used to store the whole number portion of the <code>float</code>. Finally, the remaining bits (15-0) are used to store the fractional portion of the number.</p><p>Usage is fairly straightforward:</p><div class="sourceCode" id="cb65"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb65-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb65-2" title="2"></a>
<a class="sourceLine" id="cb65-3" title="3"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb65-4" title="4">{</a>
<a class="sourceLine" id="cb65-5" title="5">    <span class="dt">float</span> f = <span class="fl">3.1415926</span>, f2;</a>
<a class="sourceLine" id="cb65-6" title="6">    <span class="dt">uint32_t</span> netf;</a>
<a class="sourceLine" id="cb65-7" title="7"></a>
<a class="sourceLine" id="cb65-8" title="8">    netf = htonf(f);  <span class="co">// convert to &quot;network&quot; form</span></a>
<a class="sourceLine" id="cb65-9" title="9">    f2 = ntohf(netf); <span class="co">// convert back to test</span></a>
<a class="sourceLine" id="cb65-10" title="10"></a>
<a class="sourceLine" id="cb65-11" title="11">    printf(<span class="st">&quot;Original: %f</span><span class="sc">\n</span><span class="st">&quot;</span>, f);        <span class="co">// 3.141593</span></a>
<a class="sourceLine" id="cb65-12" title="12">    printf(<span class="st">&quot; Network: 0x%08X</span><span class="sc">\n</span><span class="st">&quot;</span>, netf); <span class="co">// 0x0003243F</span></a>
<a class="sourceLine" id="cb65-13" title="13">    printf(<span class="st">&quot;Unpacked: %f</span><span class="sc">\n</span><span class="st">&quot;</span>, f2);       <span class="co">// 3.141586</span></a>
<a class="sourceLine" id="cb65-14" title="14"></a>
<a class="sourceLine" id="cb65-15" title="15">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb65-16" title="16">}</a></code></pre></div><p>On the plus side, it’s small, simple, and fast. On the minus side, it’s not an efficient use of space and the range is severely restricted—try storing a number greater-than 32767 in there and it won’t be very happy! You can also see in the above example that the last couple decimal places are not correctly preserved.</p><p>What can we do instead? Well, <em>The</em> Standard for storing floating point numbers is known as  <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE-754</a><a href="#fn35" class="footnote-ref" id="fnref35"><sup>35</sup></a>. Most computers use this format internally for doing floating point math, so in those cases, strictly speaking, conversion wouldn’t need to be done. But if you want your source code to be portable, that’s an assumption you can’t necessarily make. (On the other hand, if you want things to be fast, you should optimize this out on platforms that don’t need to do it! That’s what <code>htons()</code> and its ilk do.)</p><p><a href="https://beej.us/guide/bgnet/examples/ieee754.c">Here’s some code that encodes floats and doubles into IEEE-754 format</a><a href="#fn36" class="footnote-ref" id="fnref36"><sup>36</sup></a>. (Mostly—it doesn’t encode NaN or Infinity, but it could be modified to do that.)</p><div class="sourceCode" id="cb66"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb66-1" title="1"><span class="pp">#define pack754_32(f) (pack754((f), 32, 8))</span></a>
<a class="sourceLine" id="cb66-2" title="2"><span class="pp">#define pack754_64(f) (pack754((f), 64, 11))</span></a>
<a class="sourceLine" id="cb66-3" title="3"><span class="pp">#define unpack754_32(i) (unpack754((i), 32, 8))</span></a>
<a class="sourceLine" id="cb66-4" title="4"><span class="pp">#define unpack754_64(i) (unpack754((i), 64, 11))</span></a>
<a class="sourceLine" id="cb66-5" title="5"></a>
<a class="sourceLine" id="cb66-6" title="6"><span class="dt">uint64_t</span> pack754(<span class="dt">long</span> <span class="dt">double</span> f, <span class="dt">unsigned</span> bits, <span class="dt">unsigned</span> expbits)</a>
<a class="sourceLine" id="cb66-7" title="7">{</a>
<a class="sourceLine" id="cb66-8" title="8">    <span class="dt">long</span> <span class="dt">double</span> fnorm;</a>
<a class="sourceLine" id="cb66-9" title="9">    <span class="dt">int</span> shift;</a>
<a class="sourceLine" id="cb66-10" title="10">    <span class="dt">long</span> <span class="dt">long</span> sign, exp, significand;</a>
<a class="sourceLine" id="cb66-11" title="11">    <span class="dt">unsigned</span> significandbits = bits - expbits - <span class="dv">1</span>; <span class="co">// -1 for sign bit</span></a>
<a class="sourceLine" id="cb66-12" title="12"></a>
<a class="sourceLine" id="cb66-13" title="13">    <span class="cf">if</span> (f == <span class="fl">0.0</span>) <span class="cf">return</span> <span class="dv">0</span>; <span class="co">// get this special case out of the way</span></a>
<a class="sourceLine" id="cb66-14" title="14"></a>
<a class="sourceLine" id="cb66-15" title="15">    <span class="co">// check sign and begin normalization</span></a>
<a class="sourceLine" id="cb66-16" title="16">    <span class="cf">if</span> (f &lt; <span class="dv">0</span>) { sign = <span class="dv">1</span>; fnorm = -f; }</a>
<a class="sourceLine" id="cb66-17" title="17">    <span class="cf">else</span> { sign = <span class="dv">0</span>; fnorm = f; }</a>
<a class="sourceLine" id="cb66-18" title="18"></a>
<a class="sourceLine" id="cb66-19" title="19">    <span class="co">// get the normalized form of f and track the exponent</span></a>
<a class="sourceLine" id="cb66-20" title="20">    shift = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb66-21" title="21">    <span class="cf">while</span>(fnorm &gt;= <span class="fl">2.0</span>) { fnorm /= <span class="fl">2.0</span>; shift++; }</a>
<a class="sourceLine" id="cb66-22" title="22">    <span class="cf">while</span>(fnorm &lt; <span class="fl">1.0</span>) { fnorm *= <span class="fl">2.0</span>; shift--; }</a>
<a class="sourceLine" id="cb66-23" title="23">    fnorm = fnorm - <span class="fl">1.0</span>;</a>
<a class="sourceLine" id="cb66-24" title="24"></a>
<a class="sourceLine" id="cb66-25" title="25">    <span class="co">// calculate the binary form (non-float) of the significand data</span></a>
<a class="sourceLine" id="cb66-26" title="26">    significand = fnorm * ((1LL&lt;&lt;significandbits) + <span class="fl">0.5f</span>);</a>
<a class="sourceLine" id="cb66-27" title="27"></a>
<a class="sourceLine" id="cb66-28" title="28">    <span class="co">// get the biased exponent</span></a>
<a class="sourceLine" id="cb66-29" title="29">    exp = shift + ((<span class="dv">1</span>&lt;&lt;(expbits<span class="dv">-1</span>)) - <span class="dv">1</span>); <span class="co">// shift + bias</span></a>
<a class="sourceLine" id="cb66-30" title="30"></a>
<a class="sourceLine" id="cb66-31" title="31">    <span class="co">// return the final answer</span></a>
<a class="sourceLine" id="cb66-32" title="32">    <span class="cf">return</span> (sign&lt;&lt;(bits<span class="dv">-1</span>)) | (exp&lt;&lt;(bits-expbits<span class="dv">-1</span>)) | significand;</a>
<a class="sourceLine" id="cb66-33" title="33">}</a>
<a class="sourceLine" id="cb66-34" title="34"></a>
<a class="sourceLine" id="cb66-35" title="35"><span class="dt">long</span> <span class="dt">double</span> unpack754(<span class="dt">uint64_t</span> i, <span class="dt">unsigned</span> bits, <span class="dt">unsigned</span> expbits)</a>
<a class="sourceLine" id="cb66-36" title="36">{</a>
<a class="sourceLine" id="cb66-37" title="37">    <span class="dt">long</span> <span class="dt">double</span> result;</a>
<a class="sourceLine" id="cb66-38" title="38">    <span class="dt">long</span> <span class="dt">long</span> shift;</a>
<a class="sourceLine" id="cb66-39" title="39">    <span class="dt">unsigned</span> bias;</a>
<a class="sourceLine" id="cb66-40" title="40">    <span class="dt">unsigned</span> significandbits = bits - expbits - <span class="dv">1</span>; <span class="co">// -1 for sign bit</span></a>
<a class="sourceLine" id="cb66-41" title="41"></a>
<a class="sourceLine" id="cb66-42" title="42">    <span class="cf">if</span> (i == <span class="dv">0</span>) <span class="cf">return</span> <span class="fl">0.0</span>;</a>
<a class="sourceLine" id="cb66-43" title="43"></a>
<a class="sourceLine" id="cb66-44" title="44">    <span class="co">// pull the significand</span></a>
<a class="sourceLine" id="cb66-45" title="45">    result = (i&amp;((1LL&lt;&lt;significandbits)-<span class="dv">1</span>)); <span class="co">// mask</span></a>
<a class="sourceLine" id="cb66-46" title="46">    result /= (1LL&lt;&lt;significandbits); <span class="co">// convert back to float</span></a>
<a class="sourceLine" id="cb66-47" title="47">    result += <span class="fl">1.0f</span>; <span class="co">// add the one back on</span></a>
<a class="sourceLine" id="cb66-48" title="48"></a>
<a class="sourceLine" id="cb66-49" title="49">    <span class="co">// deal with the exponent</span></a>
<a class="sourceLine" id="cb66-50" title="50">    bias = (<span class="dv">1</span>&lt;&lt;(expbits<span class="dv">-1</span>)) - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb66-51" title="51">    shift = ((i&gt;&gt;significandbits)&amp;((1LL&lt;&lt;expbits)-<span class="dv">1</span>)) - bias;</a>
<a class="sourceLine" id="cb66-52" title="52">    <span class="cf">while</span>(shift &gt; <span class="dv">0</span>) { result *= <span class="fl">2.0</span>; shift--; }</a>
<a class="sourceLine" id="cb66-53" title="53">    <span class="cf">while</span>(shift &lt; <span class="dv">0</span>) { result /= <span class="fl">2.0</span>; shift++; }</a>
<a class="sourceLine" id="cb66-54" title="54"></a>
<a class="sourceLine" id="cb66-55" title="55">    <span class="co">// sign it</span></a>
<a class="sourceLine" id="cb66-56" title="56">    result *= (i&gt;&gt;(bits<span class="dv">-1</span>))&amp;<span class="dv">1</span>? <span class="fl">-1.0</span>: <span class="fl">1.0</span>;</a>
<a class="sourceLine" id="cb66-57" title="57"></a>
<a class="sourceLine" id="cb66-58" title="58">    <span class="cf">return</span> result;</a>
<a class="sourceLine" id="cb66-59" title="59">}</a></code></pre></div><p>I put some handy macros up there at the top for packing and unpacking 32-bit (probably a <code>float</code>) and 64-bit (probably a <code>double</code>) numbers, but the <code>pack754()</code> function could be called directly and told to encode <code>bits</code>-worth of data (<code>expbits</code> of which are reserved for the normalized number’s exponent).</p><p>Here’s sample usage:</p><div class="sourceCode" id="cb67"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb67-1" title="1"></a>
<a class="sourceLine" id="cb67-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb67-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span><span class="pp"> </span><span class="co">// defines uintN_t types</span></a>
<a class="sourceLine" id="cb67-4" title="4"><span class="pp">#include </span><span class="im">&lt;inttypes.h&gt;</span><span class="pp"> </span><span class="co">// defines PRIx macros</span></a>
<a class="sourceLine" id="cb67-5" title="5"></a>
<a class="sourceLine" id="cb67-6" title="6"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb67-7" title="7">{</a>
<a class="sourceLine" id="cb67-8" title="8">    <span class="dt">float</span> f = <span class="fl">3.1415926</span>, f2;</a>
<a class="sourceLine" id="cb67-9" title="9">    <span class="dt">double</span> d = <span class="fl">3.14159265358979323</span>, d2;</a>
<a class="sourceLine" id="cb67-10" title="10">    <span class="dt">uint32_t</span> fi;</a>
<a class="sourceLine" id="cb67-11" title="11">    <span class="dt">uint64_t</span> di;</a>
<a class="sourceLine" id="cb67-12" title="12"></a>
<a class="sourceLine" id="cb67-13" title="13">    fi = pack754_32(f);</a>
<a class="sourceLine" id="cb67-14" title="14">    f2 = unpack754_32(fi);</a>
<a class="sourceLine" id="cb67-15" title="15"></a>
<a class="sourceLine" id="cb67-16" title="16">    di = pack754_64(d);</a>
<a class="sourceLine" id="cb67-17" title="17">    d2 = unpack754_64(di);</a>
<a class="sourceLine" id="cb67-18" title="18"></a>
<a class="sourceLine" id="cb67-19" title="19">    printf(<span class="st">&quot;float before : %.7f</span><span class="sc">\n</span><span class="st">&quot;</span>, f);</a>
<a class="sourceLine" id="cb67-20" title="20">    printf(<span class="st">&quot;float encoded: 0x%08&quot;</span> PRIx32 <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>, fi);</a>
<a class="sourceLine" id="cb67-21" title="21">    printf(<span class="st">&quot;float after  : %.7f</span><span class="sc">\n\n</span><span class="st">&quot;</span>, f2);</a>
<a class="sourceLine" id="cb67-22" title="22"></a>
<a class="sourceLine" id="cb67-23" title="23">    printf(<span class="st">&quot;double before : %.20lf</span><span class="sc">\n</span><span class="st">&quot;</span>, d);</a>
<a class="sourceLine" id="cb67-24" title="24">    printf(<span class="st">&quot;double encoded: 0x%016&quot;</span> PRIx64 <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>, di);</a>
<a class="sourceLine" id="cb67-25" title="25">    printf(<span class="st">&quot;double after  : %.20lf</span><span class="sc">\n</span><span class="st">&quot;</span>, d2);</a>
<a class="sourceLine" id="cb67-26" title="26"></a>
<a class="sourceLine" id="cb67-27" title="27">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb67-28" title="28">}</a></code></pre></div><p>The above code produces this output:</p><pre><code>float before : 3.1415925
float encoded: 0x40490FDA
float after  : 3.1415925

double before : 3.14159265358979311600
double encoded: 0x400921FB54442D18
double after  : 3.14159265358979311600</code></pre><p>Another question you might have is how do you pack <code>struct</code>s? Unfortunately for you, the compiler is free to put padding all over the place in a <code>struct</code>, and that means you can’t portably send the whole thing over the wire in one chunk. (Aren’t you getting sick of hearing “can’t do this”, “can’t do that”? Sorry! To quote a friend, “Whenever anything goes wrong, I always blame Microsoft.” This one might not be Microsoft’s fault, admittedly, but my friend’s statement is completely true.)</p><p>Back to it: the best way to send the <code>struct</code> over the wire is to pack each field independently and then unpack them into the <code>struct</code> when they arrive on the other side.</p><p>That’s a lot of work, is what you’re thinking. Yes, it is. One thing you can do is write a helper function to help pack the data for you. It’ll be fun! Really!</p><p>In the book <a href="https://beej.us/guide/url/tpop"><em>The Practice of Programming</em></a><a href="#fn37" class="footnote-ref" id="fnref37"><sup>37</sup></a> by Kernighan and Pike, they implement <code>printf()</code>-like functions called <code>pack()</code> and <code>unpack()</code> that do exactly this. I’d link to them, but apparently those functions aren’t online with the rest of the source from the book.</p><p>(The Practice of Programming is an excellent read. Zeus saves a kitten every time I recommend it.)</p><p>At this point, I’m going to drop a pointer to a <a href="https://github.com/protobuf-c/protobuf-c">Protocol Buffers implementation in C</a><a href="#fn38" class="footnote-ref" id="fnref38"><sup>38</sup></a> which I’ve never used, but looks completely respectable. Python and Perl programmers will want to check out their language’s <code>pack()</code> and <code>unpack()</code> functions for accomplishing the same thing. And Java has a big-ol’ Serializable interface that can be used in a similar way.</p><p>But if you want to write your own packing utility in C, K&amp;P’s trick is to use variable argument lists to make <code>printf()</code>-like functions to build the packets. <a href="https://beej.us/guide/bgnet/examples/pack2.c">Here’s a version I cooked up</a><a href="#fn39" class="footnote-ref" id="fnref39"><sup>39</sup></a> on my own based on that which hopefully will be enough to give you an idea of how such a thing can work.</p><p>(This code references the <code>pack754()</code> functions, above. The <code>packi*()</code> functions operate like the familiar <code>htons()</code> family, except they pack into a <code>char</code> array instead of another integer.)</p><div class="sourceCode" id="cb69"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb69-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb69-2" title="2"><span class="pp">#include </span><span class="im">&lt;ctype.h&gt;</span></a>
<a class="sourceLine" id="cb69-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdarg.h&gt;</span></a>
<a class="sourceLine" id="cb69-4" title="4"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb69-5" title="5"></a>
<a class="sourceLine" id="cb69-6" title="6"><span class="co">/*</span></a>
<a class="sourceLine" id="cb69-7" title="7"><span class="co">** packi16() -- store a 16-bit int into a char buffer (like htons())</span></a>
<a class="sourceLine" id="cb69-8" title="8"><span class="co">*/</span> </a>
<a class="sourceLine" id="cb69-9" title="9"><span class="dt">void</span> packi16(<span class="dt">unsigned</span> <span class="dt">char</span> *buf, <span class="dt">unsigned</span> <span class="dt">int</span> i)</a>
<a class="sourceLine" id="cb69-10" title="10">{</a>
<a class="sourceLine" id="cb69-11" title="11">    *buf++ = i&gt;&gt;<span class="dv">8</span>; *buf++ = i;</a>
<a class="sourceLine" id="cb69-12" title="12">}</a>
<a class="sourceLine" id="cb69-13" title="13"></a>
<a class="sourceLine" id="cb69-14" title="14"><span class="co">/*</span></a>
<a class="sourceLine" id="cb69-15" title="15"><span class="co">** packi32() -- store a 32-bit int into a char buffer (like htonl())</span></a>
<a class="sourceLine" id="cb69-16" title="16"><span class="co">*/</span> </a>
<a class="sourceLine" id="cb69-17" title="17"><span class="dt">void</span> packi32(<span class="dt">unsigned</span> <span class="dt">char</span> *buf, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> i)</a>
<a class="sourceLine" id="cb69-18" title="18">{</a>
<a class="sourceLine" id="cb69-19" title="19">    *buf++ = i&gt;&gt;<span class="dv">24</span>; *buf++ = i&gt;&gt;<span class="dv">16</span>;</a>
<a class="sourceLine" id="cb69-20" title="20">    *buf++ = i&gt;&gt;<span class="dv">8</span>;  *buf++ = i;</a>
<a class="sourceLine" id="cb69-21" title="21">}</a>
<a class="sourceLine" id="cb69-22" title="22"></a>
<a class="sourceLine" id="cb69-23" title="23"><span class="co">/*</span></a>
<a class="sourceLine" id="cb69-24" title="24"><span class="co">** packi64() -- store a 64-bit int into a char buffer (like htonl())</span></a>
<a class="sourceLine" id="cb69-25" title="25"><span class="co">*/</span> </a>
<a class="sourceLine" id="cb69-26" title="26"><span class="dt">void</span> packi64(<span class="dt">unsigned</span> <span class="dt">char</span> *buf, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> i)</a>
<a class="sourceLine" id="cb69-27" title="27">{</a>
<a class="sourceLine" id="cb69-28" title="28">    *buf++ = i&gt;&gt;<span class="dv">56</span>; *buf++ = i&gt;&gt;<span class="dv">48</span>;</a>
<a class="sourceLine" id="cb69-29" title="29">    *buf++ = i&gt;&gt;<span class="dv">40</span>; *buf++ = i&gt;&gt;<span class="dv">32</span>;</a>
<a class="sourceLine" id="cb69-30" title="30">    *buf++ = i&gt;&gt;<span class="dv">24</span>; *buf++ = i&gt;&gt;<span class="dv">16</span>;</a>
<a class="sourceLine" id="cb69-31" title="31">    *buf++ = i&gt;&gt;<span class="dv">8</span>;  *buf++ = i;</a>
<a class="sourceLine" id="cb69-32" title="32">}</a>
<a class="sourceLine" id="cb69-33" title="33"></a>
<a class="sourceLine" id="cb69-34" title="34"><span class="co">/*</span></a>
<a class="sourceLine" id="cb69-35" title="35"><span class="co">** unpacki16() -- unpack a 16-bit int from a char buffer (like ntohs())</span></a>
<a class="sourceLine" id="cb69-36" title="36"><span class="co">*/</span> </a>
<a class="sourceLine" id="cb69-37" title="37"><span class="dt">int</span> unpacki16(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</a>
<a class="sourceLine" id="cb69-38" title="38">{</a>
<a class="sourceLine" id="cb69-39" title="39">    <span class="dt">unsigned</span> <span class="dt">int</span> i2 = ((<span class="dt">unsigned</span> <span class="dt">int</span>)buf[<span class="dv">0</span>]&lt;&lt;<span class="dv">8</span>) | buf[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb69-40" title="40">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb69-41" title="41"></a>
<a class="sourceLine" id="cb69-42" title="42">    <span class="co">// change unsigned numbers to signed</span></a>
<a class="sourceLine" id="cb69-43" title="43">    <span class="cf">if</span> (i2 &lt;= 0x7fffu) { i = i2; }</a>
<a class="sourceLine" id="cb69-44" title="44">    <span class="cf">else</span> { i = <span class="dv">-1</span> - (<span class="dt">unsigned</span> <span class="dt">int</span>)(0xffffu - i2); }</a>
<a class="sourceLine" id="cb69-45" title="45"></a>
<a class="sourceLine" id="cb69-46" title="46">    <span class="cf">return</span> i;</a>
<a class="sourceLine" id="cb69-47" title="47">}</a>
<a class="sourceLine" id="cb69-48" title="48"></a>
<a class="sourceLine" id="cb69-49" title="49"><span class="co">/*</span></a>
<a class="sourceLine" id="cb69-50" title="50"><span class="co">** unpacku16() -- unpack a 16-bit unsigned from a char buffer (like ntohs())</span></a>
<a class="sourceLine" id="cb69-51" title="51"><span class="co">*/</span> </a>
<a class="sourceLine" id="cb69-52" title="52"><span class="dt">unsigned</span> <span class="dt">int</span> unpacku16(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</a>
<a class="sourceLine" id="cb69-53" title="53">{</a>
<a class="sourceLine" id="cb69-54" title="54">    <span class="cf">return</span> ((<span class="dt">unsigned</span> <span class="dt">int</span>)buf[<span class="dv">0</span>]&lt;&lt;<span class="dv">8</span>) | buf[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb69-55" title="55">}</a>
<a class="sourceLine" id="cb69-56" title="56"></a>
<a class="sourceLine" id="cb69-57" title="57"><span class="co">/*</span></a>
<a class="sourceLine" id="cb69-58" title="58"><span class="co">** unpacki32() -- unpack a 32-bit int from a char buffer (like ntohl())</span></a>
<a class="sourceLine" id="cb69-59" title="59"><span class="co">*/</span> </a>
<a class="sourceLine" id="cb69-60" title="60"><span class="dt">long</span> <span class="dt">int</span> unpacki32(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</a>
<a class="sourceLine" id="cb69-61" title="61">{</a>
<a class="sourceLine" id="cb69-62" title="62">    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> i2 = ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">0</span>]&lt;&lt;<span class="dv">24</span>) |</a>
<a class="sourceLine" id="cb69-63" title="63">                           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">1</span>]&lt;&lt;<span class="dv">16</span>) |</a>
<a class="sourceLine" id="cb69-64" title="64">                           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">2</span>]&lt;&lt;<span class="dv">8</span>)  |</a>
<a class="sourceLine" id="cb69-65" title="65">                           buf[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb69-66" title="66">    <span class="dt">long</span> <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb69-67" title="67"></a>
<a class="sourceLine" id="cb69-68" title="68">    <span class="co">// change unsigned numbers to signed</span></a>
<a class="sourceLine" id="cb69-69" title="69">    <span class="cf">if</span> (i2 &lt;= 0x7fffffffu) { i = i2; }</a>
<a class="sourceLine" id="cb69-70" title="70">    <span class="cf">else</span> { i = <span class="dv">-1</span> - (<span class="dt">long</span> <span class="dt">int</span>)(0xffffffffu - i2); }</a>
<a class="sourceLine" id="cb69-71" title="71"></a>
<a class="sourceLine" id="cb69-72" title="72">    <span class="cf">return</span> i;</a>
<a class="sourceLine" id="cb69-73" title="73">}</a>
<a class="sourceLine" id="cb69-74" title="74"></a>
<a class="sourceLine" id="cb69-75" title="75"><span class="co">/*</span></a>
<a class="sourceLine" id="cb69-76" title="76"><span class="co">** unpacku32() -- unpack a 32-bit unsigned from a char buffer (like ntohl())</span></a>
<a class="sourceLine" id="cb69-77" title="77"><span class="co">*/</span> </a>
<a class="sourceLine" id="cb69-78" title="78"><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> unpacku32(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</a>
<a class="sourceLine" id="cb69-79" title="79">{</a>
<a class="sourceLine" id="cb69-80" title="80">    <span class="cf">return</span> ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">0</span>]&lt;&lt;<span class="dv">24</span>) |</a>
<a class="sourceLine" id="cb69-81" title="81">           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">1</span>]&lt;&lt;<span class="dv">16</span>) |</a>
<a class="sourceLine" id="cb69-82" title="82">           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">2</span>]&lt;&lt;<span class="dv">8</span>)  |</a>
<a class="sourceLine" id="cb69-83" title="83">           buf[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb69-84" title="84">}</a>
<a class="sourceLine" id="cb69-85" title="85"></a>
<a class="sourceLine" id="cb69-86" title="86"><span class="co">/*</span></a>
<a class="sourceLine" id="cb69-87" title="87"><span class="co">** unpacki64() -- unpack a 64-bit int from a char buffer (like ntohl())</span></a>
<a class="sourceLine" id="cb69-88" title="88"><span class="co">*/</span> </a>
<a class="sourceLine" id="cb69-89" title="89"><span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> unpacki64(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</a>
<a class="sourceLine" id="cb69-90" title="90">{</a>
<a class="sourceLine" id="cb69-91" title="91">    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> i2 = ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">0</span>]&lt;&lt;<span class="dv">56</span>) |</a>
<a class="sourceLine" id="cb69-92" title="92">                                ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">1</span>]&lt;&lt;<span class="dv">48</span>) |</a>
<a class="sourceLine" id="cb69-93" title="93">                                ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">2</span>]&lt;&lt;<span class="dv">40</span>) |</a>
<a class="sourceLine" id="cb69-94" title="94">                                ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">3</span>]&lt;&lt;<span class="dv">32</span>) |</a>
<a class="sourceLine" id="cb69-95" title="95">                                ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">4</span>]&lt;&lt;<span class="dv">24</span>) |</a>
<a class="sourceLine" id="cb69-96" title="96">                                ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">5</span>]&lt;&lt;<span class="dv">16</span>) |</a>
<a class="sourceLine" id="cb69-97" title="97">                                ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">6</span>]&lt;&lt;<span class="dv">8</span>)  |</a>
<a class="sourceLine" id="cb69-98" title="98">                                buf[<span class="dv">7</span>];</a>
<a class="sourceLine" id="cb69-99" title="99">    <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb69-100" title="100"></a>
<a class="sourceLine" id="cb69-101" title="101">    <span class="co">// change unsigned numbers to signed</span></a>
<a class="sourceLine" id="cb69-102" title="102">    <span class="cf">if</span> (i2 &lt;= 0x7fffffffffffffffu) { i = i2; }</a>
<a class="sourceLine" id="cb69-103" title="103">    <span class="cf">else</span> { i = <span class="dv">-1</span> -(<span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)(0xffffffffffffffffu - i2); }</a>
<a class="sourceLine" id="cb69-104" title="104"></a>
<a class="sourceLine" id="cb69-105" title="105">    <span class="cf">return</span> i;</a>
<a class="sourceLine" id="cb69-106" title="106">}</a>
<a class="sourceLine" id="cb69-107" title="107"></a>
<a class="sourceLine" id="cb69-108" title="108"><span class="co">/*</span></a>
<a class="sourceLine" id="cb69-109" title="109"><span class="co">** unpacku64() -- unpack a 64-bit unsigned from a char buffer (like ntohl())</span></a>
<a class="sourceLine" id="cb69-110" title="110"><span class="co">*/</span> </a>
<a class="sourceLine" id="cb69-111" title="111"><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> unpacku64(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</a>
<a class="sourceLine" id="cb69-112" title="112">{</a>
<a class="sourceLine" id="cb69-113" title="113">    <span class="cf">return</span> ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">0</span>]&lt;&lt;<span class="dv">56</span>) |</a>
<a class="sourceLine" id="cb69-114" title="114">           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">1</span>]&lt;&lt;<span class="dv">48</span>) |</a>
<a class="sourceLine" id="cb69-115" title="115">           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">2</span>]&lt;&lt;<span class="dv">40</span>) |</a>
<a class="sourceLine" id="cb69-116" title="116">           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">3</span>]&lt;&lt;<span class="dv">32</span>) |</a>
<a class="sourceLine" id="cb69-117" title="117">           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">4</span>]&lt;&lt;<span class="dv">24</span>) |</a>
<a class="sourceLine" id="cb69-118" title="118">           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">5</span>]&lt;&lt;<span class="dv">16</span>) |</a>
<a class="sourceLine" id="cb69-119" title="119">           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">6</span>]&lt;&lt;<span class="dv">8</span>)  |</a>
<a class="sourceLine" id="cb69-120" title="120">           buf[<span class="dv">7</span>];</a>
<a class="sourceLine" id="cb69-121" title="121">}</a>
<a class="sourceLine" id="cb69-122" title="122"></a>
<a class="sourceLine" id="cb69-123" title="123"><span class="co">/*</span></a>
<a class="sourceLine" id="cb69-124" title="124"><span class="co">** pack() -- store data dictated by the format string in the buffer</span></a>
<a class="sourceLine" id="cb69-125" title="125"><span class="co">**</span></a>
<a class="sourceLine" id="cb69-126" title="126"><span class="co">**   bits |signed   unsigned   float   string</span></a>
<a class="sourceLine" id="cb69-127" title="127"><span class="co">**   -----+----------------------------------</span></a>
<a class="sourceLine" id="cb69-128" title="128"><span class="co">**      8 |   c        C         </span></a>
<a class="sourceLine" id="cb69-129" title="129"><span class="co">**     16 |   h        H         f</span></a>
<a class="sourceLine" id="cb69-130" title="130"><span class="co">**     32 |   l        L         d</span></a>
<a class="sourceLine" id="cb69-131" title="131"><span class="co">**     64 |   q        Q         g</span></a>
<a class="sourceLine" id="cb69-132" title="132"><span class="co">**      - |                               s</span></a>
<a class="sourceLine" id="cb69-133" title="133"><span class="co">**</span></a>
<a class="sourceLine" id="cb69-134" title="134"><span class="co">**  (16-bit unsigned length is automatically prepended to strings)</span></a>
<a class="sourceLine" id="cb69-135" title="135"><span class="co">*/</span> </a>
<a class="sourceLine" id="cb69-136" title="136"></a>
<a class="sourceLine" id="cb69-137" title="137"><span class="dt">unsigned</span> <span class="dt">int</span> pack(<span class="dt">unsigned</span> <span class="dt">char</span> *buf, <span class="dt">char</span> *format, ...)</a>
<a class="sourceLine" id="cb69-138" title="138">{</a>
<a class="sourceLine" id="cb69-139" title="139">    <span class="dt">va_list</span> ap;</a>
<a class="sourceLine" id="cb69-140" title="140"></a>
<a class="sourceLine" id="cb69-141" title="141">    <span class="dt">signed</span> <span class="dt">char</span> c;              <span class="co">// 8-bit</span></a>
<a class="sourceLine" id="cb69-142" title="142">    <span class="dt">unsigned</span> <span class="dt">char</span> C;</a>
<a class="sourceLine" id="cb69-143" title="143"></a>
<a class="sourceLine" id="cb69-144" title="144">    <span class="dt">int</span> h;                      <span class="co">// 16-bit</span></a>
<a class="sourceLine" id="cb69-145" title="145">    <span class="dt">unsigned</span> <span class="dt">int</span> H;</a>
<a class="sourceLine" id="cb69-146" title="146"></a>
<a class="sourceLine" id="cb69-147" title="147">    <span class="dt">long</span> <span class="dt">int</span> l;                 <span class="co">// 32-bit</span></a>
<a class="sourceLine" id="cb69-148" title="148">    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> L;</a>
<a class="sourceLine" id="cb69-149" title="149"></a>
<a class="sourceLine" id="cb69-150" title="150">    <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> q;            <span class="co">// 64-bit</span></a>
<a class="sourceLine" id="cb69-151" title="151">    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> Q;</a>
<a class="sourceLine" id="cb69-152" title="152"></a>
<a class="sourceLine" id="cb69-153" title="153">    <span class="dt">float</span> f;                    <span class="co">// floats</span></a>
<a class="sourceLine" id="cb69-154" title="154">    <span class="dt">double</span> d;</a>
<a class="sourceLine" id="cb69-155" title="155">    <span class="dt">long</span> <span class="dt">double</span> g;</a>
<a class="sourceLine" id="cb69-156" title="156">    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> fhold;</a>
<a class="sourceLine" id="cb69-157" title="157"></a>
<a class="sourceLine" id="cb69-158" title="158">    <span class="dt">char</span> *s;                    <span class="co">// strings</span></a>
<a class="sourceLine" id="cb69-159" title="159">    <span class="dt">unsigned</span> <span class="dt">int</span> len;</a>
<a class="sourceLine" id="cb69-160" title="160"></a>
<a class="sourceLine" id="cb69-161" title="161">    <span class="dt">unsigned</span> <span class="dt">int</span> size = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb69-162" title="162"></a>
<a class="sourceLine" id="cb69-163" title="163">    va_start(ap, format);</a>
<a class="sourceLine" id="cb69-164" title="164"></a>
<a class="sourceLine" id="cb69-165" title="165">    <span class="cf">for</span>(; *format != &#39;\<span class="dv">0</span>&#39;; format++) {</a>
<a class="sourceLine" id="cb69-166" title="166">        <span class="cf">switch</span>(*format) {</a>
<a class="sourceLine" id="cb69-167" title="167">        <span class="cf">case</span> <span class="ch">&#39;c&#39;</span>: <span class="co">// 8-bit</span></a>
<a class="sourceLine" id="cb69-168" title="168">            size += <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb69-169" title="169">            c = (<span class="dt">signed</span> <span class="dt">char</span>)va_arg(ap, <span class="dt">int</span>); <span class="co">// promoted</span></a>
<a class="sourceLine" id="cb69-170" title="170">            *buf++ = c;</a>
<a class="sourceLine" id="cb69-171" title="171">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-172" title="172"></a>
<a class="sourceLine" id="cb69-173" title="173">        <span class="cf">case</span> <span class="ch">&#39;C&#39;</span>: <span class="co">// 8-bit unsigned</span></a>
<a class="sourceLine" id="cb69-174" title="174">            size += <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb69-175" title="175">            C = (<span class="dt">unsigned</span> <span class="dt">char</span>)va_arg(ap, <span class="dt">unsigned</span> <span class="dt">int</span>); <span class="co">// promoted</span></a>
<a class="sourceLine" id="cb69-176" title="176">            *buf++ = C;</a>
<a class="sourceLine" id="cb69-177" title="177">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-178" title="178"></a>
<a class="sourceLine" id="cb69-179" title="179">        <span class="cf">case</span> <span class="ch">&#39;h&#39;</span>: <span class="co">// 16-bit</span></a>
<a class="sourceLine" id="cb69-180" title="180">            size += <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb69-181" title="181">            h = va_arg(ap, <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb69-182" title="182">            packi16(buf, h);</a>
<a class="sourceLine" id="cb69-183" title="183">            buf += <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb69-184" title="184">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-185" title="185"></a>
<a class="sourceLine" id="cb69-186" title="186">        <span class="cf">case</span> <span class="ch">&#39;H&#39;</span>: <span class="co">// 16-bit unsigned</span></a>
<a class="sourceLine" id="cb69-187" title="187">            size += <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb69-188" title="188">            H = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb69-189" title="189">            packi16(buf, H);</a>
<a class="sourceLine" id="cb69-190" title="190">            buf += <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb69-191" title="191">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-192" title="192"></a>
<a class="sourceLine" id="cb69-193" title="193">        <span class="cf">case</span> <span class="ch">&#39;l&#39;</span>: <span class="co">// 32-bit</span></a>
<a class="sourceLine" id="cb69-194" title="194">            size += <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb69-195" title="195">            l = va_arg(ap, <span class="dt">long</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb69-196" title="196">            packi32(buf, l);</a>
<a class="sourceLine" id="cb69-197" title="197">            buf += <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb69-198" title="198">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-199" title="199"></a>
<a class="sourceLine" id="cb69-200" title="200">        <span class="cf">case</span> <span class="ch">&#39;L&#39;</span>: <span class="co">// 32-bit unsigned</span></a>
<a class="sourceLine" id="cb69-201" title="201">            size += <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb69-202" title="202">            L = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb69-203" title="203">            packi32(buf, L);</a>
<a class="sourceLine" id="cb69-204" title="204">            buf += <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb69-205" title="205">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-206" title="206"></a>
<a class="sourceLine" id="cb69-207" title="207">        <span class="cf">case</span> <span class="ch">&#39;q&#39;</span>: <span class="co">// 64-bit</span></a>
<a class="sourceLine" id="cb69-208" title="208">            size += <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb69-209" title="209">            q = va_arg(ap, <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb69-210" title="210">            packi64(buf, q);</a>
<a class="sourceLine" id="cb69-211" title="211">            buf += <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb69-212" title="212">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-213" title="213"></a>
<a class="sourceLine" id="cb69-214" title="214">        <span class="cf">case</span> <span class="ch">&#39;Q&#39;</span>: <span class="co">// 64-bit unsigned</span></a>
<a class="sourceLine" id="cb69-215" title="215">            size += <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb69-216" title="216">            Q = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb69-217" title="217">            packi64(buf, Q);</a>
<a class="sourceLine" id="cb69-218" title="218">            buf += <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb69-219" title="219">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-220" title="220"></a>
<a class="sourceLine" id="cb69-221" title="221">        <span class="cf">case</span> <span class="ch">&#39;f&#39;</span>: <span class="co">// float-16</span></a>
<a class="sourceLine" id="cb69-222" title="222">            size += <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb69-223" title="223">            f = (<span class="dt">float</span>)va_arg(ap, <span class="dt">double</span>); <span class="co">// promoted</span></a>
<a class="sourceLine" id="cb69-224" title="224">            fhold = pack754_16(f); <span class="co">// convert to IEEE 754</span></a>
<a class="sourceLine" id="cb69-225" title="225">            packi16(buf, fhold);</a>
<a class="sourceLine" id="cb69-226" title="226">            buf += <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb69-227" title="227">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-228" title="228"></a>
<a class="sourceLine" id="cb69-229" title="229">        <span class="cf">case</span> <span class="ch">&#39;d&#39;</span>: <span class="co">// float-32</span></a>
<a class="sourceLine" id="cb69-230" title="230">            size += <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb69-231" title="231">            d = va_arg(ap, <span class="dt">double</span>);</a>
<a class="sourceLine" id="cb69-232" title="232">            fhold = pack754_32(d); <span class="co">// convert to IEEE 754</span></a>
<a class="sourceLine" id="cb69-233" title="233">            packi32(buf, fhold);</a>
<a class="sourceLine" id="cb69-234" title="234">            buf += <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb69-235" title="235">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-236" title="236"></a>
<a class="sourceLine" id="cb69-237" title="237">        <span class="cf">case</span> <span class="ch">&#39;g&#39;</span>: <span class="co">// float-64</span></a>
<a class="sourceLine" id="cb69-238" title="238">            size += <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb69-239" title="239">            g = va_arg(ap, <span class="dt">long</span> <span class="dt">double</span>);</a>
<a class="sourceLine" id="cb69-240" title="240">            fhold = pack754_64(g); <span class="co">// convert to IEEE 754</span></a>
<a class="sourceLine" id="cb69-241" title="241">            packi64(buf, fhold);</a>
<a class="sourceLine" id="cb69-242" title="242">            buf += <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb69-243" title="243">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-244" title="244"></a>
<a class="sourceLine" id="cb69-245" title="245">        <span class="cf">case</span> <span class="ch">&#39;s&#39;</span>: <span class="co">// string</span></a>
<a class="sourceLine" id="cb69-246" title="246">            s = va_arg(ap, <span class="dt">char</span>*);</a>
<a class="sourceLine" id="cb69-247" title="247">            len = strlen(s);</a>
<a class="sourceLine" id="cb69-248" title="248">            size += len + <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb69-249" title="249">            packi16(buf, len);</a>
<a class="sourceLine" id="cb69-250" title="250">            buf += <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb69-251" title="251">            memcpy(buf, s, len);</a>
<a class="sourceLine" id="cb69-252" title="252">            buf += len;</a>
<a class="sourceLine" id="cb69-253" title="253">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-254" title="254">        }</a>
<a class="sourceLine" id="cb69-255" title="255">    }</a>
<a class="sourceLine" id="cb69-256" title="256"></a>
<a class="sourceLine" id="cb69-257" title="257">    va_end(ap);</a>
<a class="sourceLine" id="cb69-258" title="258"></a>
<a class="sourceLine" id="cb69-259" title="259">    <span class="cf">return</span> size;</a>
<a class="sourceLine" id="cb69-260" title="260">}</a>
<a class="sourceLine" id="cb69-261" title="261"></a>
<a class="sourceLine" id="cb69-262" title="262"><span class="co">/*</span></a>
<a class="sourceLine" id="cb69-263" title="263"><span class="co">** unpack() -- unpack data dictated by the format string into the buffer</span></a>
<a class="sourceLine" id="cb69-264" title="264"><span class="co">**</span></a>
<a class="sourceLine" id="cb69-265" title="265"><span class="co">**   bits |signed   unsigned   float   string</span></a>
<a class="sourceLine" id="cb69-266" title="266"><span class="co">**   -----+----------------------------------</span></a>
<a class="sourceLine" id="cb69-267" title="267"><span class="co">**      8 |   c        C         </span></a>
<a class="sourceLine" id="cb69-268" title="268"><span class="co">**     16 |   h        H         f</span></a>
<a class="sourceLine" id="cb69-269" title="269"><span class="co">**     32 |   l        L         d</span></a>
<a class="sourceLine" id="cb69-270" title="270"><span class="co">**     64 |   q        Q         g</span></a>
<a class="sourceLine" id="cb69-271" title="271"><span class="co">**      - |                               s</span></a>
<a class="sourceLine" id="cb69-272" title="272"><span class="co">**</span></a>
<a class="sourceLine" id="cb69-273" title="273"><span class="co">**  (string is extracted based on its stored length, but &#39;s&#39; can be</span></a>
<a class="sourceLine" id="cb69-274" title="274"><span class="co">**  prepended with a max length)</span></a>
<a class="sourceLine" id="cb69-275" title="275"><span class="co">*/</span></a>
<a class="sourceLine" id="cb69-276" title="276"><span class="dt">void</span> unpack(<span class="dt">unsigned</span> <span class="dt">char</span> *buf, <span class="dt">char</span> *format, ...)</a>
<a class="sourceLine" id="cb69-277" title="277">{</a>
<a class="sourceLine" id="cb69-278" title="278">    <span class="dt">va_list</span> ap;</a>
<a class="sourceLine" id="cb69-279" title="279"></a>
<a class="sourceLine" id="cb69-280" title="280">    <span class="dt">signed</span> <span class="dt">char</span> *c;              <span class="co">// 8-bit</span></a>
<a class="sourceLine" id="cb69-281" title="281">    <span class="dt">unsigned</span> <span class="dt">char</span> *C;</a>
<a class="sourceLine" id="cb69-282" title="282"></a>
<a class="sourceLine" id="cb69-283" title="283">    <span class="dt">int</span> *h;                      <span class="co">// 16-bit</span></a>
<a class="sourceLine" id="cb69-284" title="284">    <span class="dt">unsigned</span> <span class="dt">int</span> *H;</a>
<a class="sourceLine" id="cb69-285" title="285"></a>
<a class="sourceLine" id="cb69-286" title="286">    <span class="dt">long</span> <span class="dt">int</span> *l;                 <span class="co">// 32-bit</span></a>
<a class="sourceLine" id="cb69-287" title="287">    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> *L;</a>
<a class="sourceLine" id="cb69-288" title="288"></a>
<a class="sourceLine" id="cb69-289" title="289">    <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> *q;            <span class="co">// 64-bit</span></a>
<a class="sourceLine" id="cb69-290" title="290">    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> *Q;</a>
<a class="sourceLine" id="cb69-291" title="291"></a>
<a class="sourceLine" id="cb69-292" title="292">    <span class="dt">float</span> *f;                    <span class="co">// floats</span></a>
<a class="sourceLine" id="cb69-293" title="293">    <span class="dt">double</span> *d;</a>
<a class="sourceLine" id="cb69-294" title="294">    <span class="dt">long</span> <span class="dt">double</span> *g;</a>
<a class="sourceLine" id="cb69-295" title="295">    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> fhold;</a>
<a class="sourceLine" id="cb69-296" title="296"></a>
<a class="sourceLine" id="cb69-297" title="297">    <span class="dt">char</span> *s;</a>
<a class="sourceLine" id="cb69-298" title="298">    <span class="dt">unsigned</span> <span class="dt">int</span> len, maxstrlen=<span class="dv">0</span>, count;</a>
<a class="sourceLine" id="cb69-299" title="299"></a>
<a class="sourceLine" id="cb69-300" title="300">    va_start(ap, format);</a>
<a class="sourceLine" id="cb69-301" title="301"></a>
<a class="sourceLine" id="cb69-302" title="302">    <span class="cf">for</span>(; *format != &#39;\<span class="dv">0</span>&#39;; format++) {</a>
<a class="sourceLine" id="cb69-303" title="303">        <span class="cf">switch</span>(*format) {</a>
<a class="sourceLine" id="cb69-304" title="304">        <span class="cf">case</span> <span class="ch">&#39;c&#39;</span>: <span class="co">// 8-bit</span></a>
<a class="sourceLine" id="cb69-305" title="305">            c = va_arg(ap, <span class="dt">signed</span> <span class="dt">char</span>*);</a>
<a class="sourceLine" id="cb69-306" title="306">            <span class="cf">if</span> (*buf &lt;= <span class="bn">0x7f</span>) { *c = *buf;} <span class="co">// re-sign</span></a>
<a class="sourceLine" id="cb69-307" title="307">            <span class="cf">else</span> { *c = <span class="dv">-1</span> - (<span class="dt">unsigned</span> <span class="dt">char</span>)(0xffu - *buf); }</a>
<a class="sourceLine" id="cb69-308" title="308">            buf++;</a>
<a class="sourceLine" id="cb69-309" title="309">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-310" title="310"></a>
<a class="sourceLine" id="cb69-311" title="311">        <span class="cf">case</span> <span class="ch">&#39;C&#39;</span>: <span class="co">// 8-bit unsigned</span></a>
<a class="sourceLine" id="cb69-312" title="312">            C = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">char</span>*);</a>
<a class="sourceLine" id="cb69-313" title="313">            *C = *buf++;</a>
<a class="sourceLine" id="cb69-314" title="314">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-315" title="315"></a>
<a class="sourceLine" id="cb69-316" title="316">        <span class="cf">case</span> <span class="ch">&#39;h&#39;</span>: <span class="co">// 16-bit</span></a>
<a class="sourceLine" id="cb69-317" title="317">            h = va_arg(ap, <span class="dt">int</span>*);</a>
<a class="sourceLine" id="cb69-318" title="318">            *h = unpacki16(buf);</a>
<a class="sourceLine" id="cb69-319" title="319">            buf += <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb69-320" title="320">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-321" title="321"></a>
<a class="sourceLine" id="cb69-322" title="322">        <span class="cf">case</span> <span class="ch">&#39;H&#39;</span>: <span class="co">// 16-bit unsigned</span></a>
<a class="sourceLine" id="cb69-323" title="323">            H = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">int</span>*);</a>
<a class="sourceLine" id="cb69-324" title="324">            *H = unpacku16(buf);</a>
<a class="sourceLine" id="cb69-325" title="325">            buf += <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb69-326" title="326">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-327" title="327"></a>
<a class="sourceLine" id="cb69-328" title="328">        <span class="cf">case</span> <span class="ch">&#39;l&#39;</span>: <span class="co">// 32-bit</span></a>
<a class="sourceLine" id="cb69-329" title="329">            l = va_arg(ap, <span class="dt">long</span> <span class="dt">int</span>*);</a>
<a class="sourceLine" id="cb69-330" title="330">            *l = unpacki32(buf);</a>
<a class="sourceLine" id="cb69-331" title="331">            buf += <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb69-332" title="332">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-333" title="333"></a>
<a class="sourceLine" id="cb69-334" title="334">        <span class="cf">case</span> <span class="ch">&#39;L&#39;</span>: <span class="co">// 32-bit unsigned</span></a>
<a class="sourceLine" id="cb69-335" title="335">            L = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>*);</a>
<a class="sourceLine" id="cb69-336" title="336">            *L = unpacku32(buf);</a>
<a class="sourceLine" id="cb69-337" title="337">            buf += <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb69-338" title="338">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-339" title="339"></a>
<a class="sourceLine" id="cb69-340" title="340">        <span class="cf">case</span> <span class="ch">&#39;q&#39;</span>: <span class="co">// 64-bit</span></a>
<a class="sourceLine" id="cb69-341" title="341">            q = va_arg(ap, <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>*);</a>
<a class="sourceLine" id="cb69-342" title="342">            *q = unpacki64(buf);</a>
<a class="sourceLine" id="cb69-343" title="343">            buf += <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb69-344" title="344">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-345" title="345"></a>
<a class="sourceLine" id="cb69-346" title="346">        <span class="cf">case</span> <span class="ch">&#39;Q&#39;</span>: <span class="co">// 64-bit unsigned</span></a>
<a class="sourceLine" id="cb69-347" title="347">            Q = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>*);</a>
<a class="sourceLine" id="cb69-348" title="348">            *Q = unpacku64(buf);</a>
<a class="sourceLine" id="cb69-349" title="349">            buf += <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb69-350" title="350">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-351" title="351"></a>
<a class="sourceLine" id="cb69-352" title="352">        <span class="cf">case</span> <span class="ch">&#39;f&#39;</span>: <span class="co">// float</span></a>
<a class="sourceLine" id="cb69-353" title="353">            f = va_arg(ap, <span class="dt">float</span>*);</a>
<a class="sourceLine" id="cb69-354" title="354">            fhold = unpacku16(buf);</a>
<a class="sourceLine" id="cb69-355" title="355">            *f = unpack754_16(fhold);</a>
<a class="sourceLine" id="cb69-356" title="356">            buf += <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb69-357" title="357">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-358" title="358"></a>
<a class="sourceLine" id="cb69-359" title="359">        <span class="cf">case</span> <span class="ch">&#39;d&#39;</span>: <span class="co">// float-32</span></a>
<a class="sourceLine" id="cb69-360" title="360">            d = va_arg(ap, <span class="dt">double</span>*);</a>
<a class="sourceLine" id="cb69-361" title="361">            fhold = unpacku32(buf);</a>
<a class="sourceLine" id="cb69-362" title="362">            *d = unpack754_32(fhold);</a>
<a class="sourceLine" id="cb69-363" title="363">            buf += <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb69-364" title="364">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-365" title="365"></a>
<a class="sourceLine" id="cb69-366" title="366">        <span class="cf">case</span> <span class="ch">&#39;g&#39;</span>: <span class="co">// float-64</span></a>
<a class="sourceLine" id="cb69-367" title="367">            g = va_arg(ap, <span class="dt">long</span> <span class="dt">double</span>*);</a>
<a class="sourceLine" id="cb69-368" title="368">            fhold = unpacku64(buf);</a>
<a class="sourceLine" id="cb69-369" title="369">            *g = unpack754_64(fhold);</a>
<a class="sourceLine" id="cb69-370" title="370">            buf += <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb69-371" title="371">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-372" title="372"></a>
<a class="sourceLine" id="cb69-373" title="373">        <span class="cf">case</span> <span class="ch">&#39;s&#39;</span>: <span class="co">// string</span></a>
<a class="sourceLine" id="cb69-374" title="374">            s = va_arg(ap, <span class="dt">char</span>*);</a>
<a class="sourceLine" id="cb69-375" title="375">            len = unpacku16(buf);</a>
<a class="sourceLine" id="cb69-376" title="376">            buf += <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb69-377" title="377">            <span class="cf">if</span> (maxstrlen &gt; <span class="dv">0</span> &amp;&amp; len &gt;= maxstrlen) count = maxstrlen - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb69-378" title="378">            <span class="cf">else</span> count = len;</a>
<a class="sourceLine" id="cb69-379" title="379">            memcpy(s, buf, count);</a>
<a class="sourceLine" id="cb69-380" title="380">            s[count] = &#39;\<span class="dv">0</span>&#39;;</a>
<a class="sourceLine" id="cb69-381" title="381">            buf += len;</a>
<a class="sourceLine" id="cb69-382" title="382">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb69-383" title="383"></a>
<a class="sourceLine" id="cb69-384" title="384">        <span class="cf">default</span>:</a>
<a class="sourceLine" id="cb69-385" title="385">            <span class="cf">if</span> (isdigit(*format)) { <span class="co">// track max str len</span></a>
<a class="sourceLine" id="cb69-386" title="386">                maxstrlen = maxstrlen * <span class="dv">10</span> + (*format-<span class="ch">&#39;0&#39;</span>);</a>
<a class="sourceLine" id="cb69-387" title="387">            }</a>
<a class="sourceLine" id="cb69-388" title="388">        }</a>
<a class="sourceLine" id="cb69-389" title="389"></a>
<a class="sourceLine" id="cb69-390" title="390">        <span class="cf">if</span> (!isdigit(*format)) maxstrlen = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb69-391" title="391">    }</a>
<a class="sourceLine" id="cb69-392" title="392"></a>
<a class="sourceLine" id="cb69-393" title="393">    va_end(ap);</a>
<a class="sourceLine" id="cb69-394" title="394">}</a></code></pre></div><p>And <a href="https://beej.us/guide/bgnet/examples/pack2.c">here is a demonstration program</a><a href="#fn40" class="footnote-ref" id="fnref40"><sup>40</sup></a> of the above code that packs some data into <code>buf</code> and then unpacks it into variables. Note that when calling <code>unpack()</code> with a string argument (format specifier “<code>s</code>”), it’s wise to put a maximum length count in front of it to prevent a buffer overrun, e.g. “<code>96s</code>”. Be wary when unpacking data you get over the network—a malicious user might send badly-constructed packets in an effort to attack your system!</p><div class="sourceCode" id="cb70"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb70-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb70-2" title="2"></a>
<a class="sourceLine" id="cb70-3" title="3"><span class="co">// various bits for floating point types--</span></a>
<a class="sourceLine" id="cb70-4" title="4"><span class="co">// varies for different architectures</span></a>
<a class="sourceLine" id="cb70-5" title="5"><span class="kw">typedef</span> <span class="dt">float</span> float32_t;</a>
<a class="sourceLine" id="cb70-6" title="6"><span class="kw">typedef</span> <span class="dt">double</span> float64_t;</a>
<a class="sourceLine" id="cb70-7" title="7"></a>
<a class="sourceLine" id="cb70-8" title="8"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb70-9" title="9">{</a>
<a class="sourceLine" id="cb70-10" title="10">    <span class="dt">unsigned</span> <span class="dt">char</span> buf[<span class="dv">1024</span>];</a>
<a class="sourceLine" id="cb70-11" title="11">    <span class="dt">int8_t</span> magic;</a>
<a class="sourceLine" id="cb70-12" title="12">    <span class="dt">int16_t</span> monkeycount;</a>
<a class="sourceLine" id="cb70-13" title="13">    <span class="dt">int32_t</span> altitude;</a>
<a class="sourceLine" id="cb70-14" title="14">    float32_t absurdityfactor;</a>
<a class="sourceLine" id="cb70-15" title="15">    <span class="dt">char</span> *s = <span class="st">&quot;Great unmitigated Zot! You&#39;ve found the Runestaff!&quot;</span>;</a>
<a class="sourceLine" id="cb70-16" title="16">    <span class="dt">char</span> s2[<span class="dv">96</span>];</a>
<a class="sourceLine" id="cb70-17" title="17">    <span class="dt">int16_t</span> packetsize, ps2;</a>
<a class="sourceLine" id="cb70-18" title="18"></a>
<a class="sourceLine" id="cb70-19" title="19">    packetsize = pack(buf, <span class="st">&quot;chhlsf&quot;</span>, (<span class="dt">int8_t</span>)<span class="ch">&#39;B&#39;</span>, (<span class="dt">int16_t</span>)<span class="dv">0</span>, (<span class="dt">int16_t</span>)<span class="dv">37</span>, </a>
<a class="sourceLine" id="cb70-20" title="20">            (<span class="dt">int32_t</span>)-<span class="dv">5</span>, s, (float32_t)-<span class="fl">3490.6677</span>);</a>
<a class="sourceLine" id="cb70-21" title="21">    packi16(buf+<span class="dv">1</span>, packetsize); <span class="co">// store packet size in packet for kicks</span></a>
<a class="sourceLine" id="cb70-22" title="22"></a>
<a class="sourceLine" id="cb70-23" title="23">    printf(<span class="st">&quot;packet is %&quot;</span> PRId32 <span class="st">&quot; bytes</span><span class="sc">\n</span><span class="st">&quot;</span>, packetsize);</a>
<a class="sourceLine" id="cb70-24" title="24"></a>
<a class="sourceLine" id="cb70-25" title="25">    unpack(buf, <span class="st">&quot;chhl96sf&quot;</span>, &amp;magic, &amp;ps2, &amp;monkeycount, &amp;altitude, s2,</a>
<a class="sourceLine" id="cb70-26" title="26">        &amp;absurdityfactor);</a>
<a class="sourceLine" id="cb70-27" title="27"></a>
<a class="sourceLine" id="cb70-28" title="28">    printf(<span class="st">&quot;&#39;%c&#39; %&quot;</span> PRId32<span class="st">&quot; %&quot;</span> PRId16 <span class="st">&quot; %&quot;</span> PRId32</a>
<a class="sourceLine" id="cb70-29" title="29">            <span class="st">&quot; </span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;</span><span class="st"> %f</span><span class="sc">\n</span><span class="st">&quot;</span>, magic, ps2, monkeycount,</a>
<a class="sourceLine" id="cb70-30" title="30">            altitude, s2, absurdityfactor);</a>
<a class="sourceLine" id="cb70-31" title="31"></a>
<a class="sourceLine" id="cb70-32" title="32">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb70-33" title="33">}</a></code></pre></div><p>Whether you roll your own code or use someone else’s, it’s a good idea to have a general set of data packing routines for the sake of keeping bugs in check, rather than packing each bit by hand each time.</p><p>When packing the data, what’s a good format to use? Excellent question. Fortunately,  <a href="https://tools.ietf.org/html/rfc4506">RFC 4506</a><a href="#fn41" class="footnote-ref" id="fnref41"><sup>41</sup></a>, the External Data Representation Standard, already defines binary formats for a bunch of different types, like floating point types, integer types, arrays, raw data, etc. I suggest conforming to that if you’re going to roll the data yourself. But you’re not obligated to. The Packet Police are not right outside your door. At least, I don’t <em>think</em> they are.</p><p>In any case, encoding the data somehow or another before you send it is the right way of doing things!</p><p></p><h2 id="sonofdataencap"><span class="header-section-number">7.6</span> Son of Data Encapsulation</h2><p>What does it really mean to encapsulate data, anyway? In the simplest case, it means you’ll stick a header on there with either some identifying information or a packet length, or both.</p><p>What should your header look like? Well, it’s just some binary data that represents whatever you feel is necessary to complete your project.</p><p>Wow. That’s vague.</p><p>Okay. For instance, let’s say you have a multi-user chat program that uses <code>SOCK_STREAM</code>s. When a user types (“says”) something, two pieces of information need to be transmitted to the server: what was said and who said it.</p><p>So far so good? “What’s the problem?” you’re asking.</p><p>The problem is that the messages can be of varying lengths. One person named “tom” might say, “Hi”, and another person named “Benjamin” might say, “Hey guys what is up?”</p><p>So you <code>send()</code> all this stuff to the clients as it comes in. Your outgoing data stream looks like this:</p><pre><code>t o m H i B e n j a m i n H e y g u y s w h a t i s u p ?</code></pre><p>And so on. How does the client know when one message starts and another stops? You could, if you wanted, make all messages the same length and just call the  <code>sendall()</code> we implemented, <a href="#sendall">above</a>. But that wastes bandwidth! We don’t want to <code>send()</code> 1024 bytes just so “tom” can say “Hi”.</p><p>So we <em>encapsulate</em> the data in a tiny header and packet structure. Both the client and server know how to pack and unpack (sometimes referred to as “marshal” and “unmarshal”) this data. Don’t look now, but we’re starting to define a <em>protocol</em> that describes how a client and server communicate!</p><p>In this case, let’s assume the user name is a fixed length of 8 characters, padded with <code>'\0'</code>. And then let’s assume the data is variable length, up to a maximum of 128 characters. Let’s have a look a sample packet structure that we might use in this situation:</p><ol type="1"><li><p><code>len</code> (1 byte, unsigned)—The total length of the packet, counting the 8-byte user name and chat data.</p></li><li><p><code>name</code> (8 bytes)—The user’s name, NUL-padded if necessary.</p></li><li><p><code>chatdata</code> (<em>n</em>-bytes)—The data itself, no more than 128 bytes. The length of the packet should be calculated as the length of this data plus 8 (the length of the name field, above).</p></li></ol><p>Why did I choose the 8-byte and 128-byte limits for the fields? I pulled them out of the air, assuming they’d be long enough. Maybe, though, 8 bytes is too restrictive for your needs, and you can have a 30-byte name field, or whatever. The choice is up to you.</p><p>Using the above packet definition, the first packet would consist of the following information (in hex and ASCII):</p><pre><code>   0A     74 6F 6D 00 00 00 00 00      48 69
(length)  T  o  m    (padding)         H  i</code></pre><p>And the second is similar:</p><pre><code>   18     42 65 6E 6A 61 6D 69 6E      48 65 79 20 67 75 79 73 20 77 ...
(length)  B  e  n  j  a  m  i  n       H  e  y     g  u  y  s     w  ...</code></pre><p>(The length is stored in Network Byte Order, of course. In this case, it’s only one byte so it doesn’t matter, but generally speaking you’ll want all your binary integers to be stored in Network Byte Order in your packets.)</p><p>When you’re sending this data, you should be safe and use a command similar to <a href="#sendall"><code>sendall()</code></a>, above, so you know all the data is sent, even if it takes multiple calls to <code>send()</code> to get it all out.</p><p>Likewise, when you’re receiving this data, you need to do a bit of extra work. To be safe, you should assume that you might receive a partial packet (like maybe we receive “<code>18 42 65 6E 6A</code>” from Benjamin, above, but that’s all we get in this call to <code>recv()</code>). We need to call <code>recv()</code> over and over again until the packet is completely received.</p><p>But how? Well, we know the number of bytes we need to receive in total for the packet to be complete, since that number is tacked on the front of the packet. We also know the maximum packet size is 1+8+128, or 137 bytes (because that’s how we defined the packet).</p><p>There are actually a couple things you can do here. Since you know every packet starts off with a length, you can call <code>recv()</code> just to get the packet length. Then once you have that, you can call it again specifying exactly the remaining length of the packet (possibly repeatedly to get all the data) until you have the complete packet. The advantage of this method is that you only need a buffer large enough for one packet, while the disadvantage is that you need to call <code>recv()</code> at least twice to get all the data.</p><p>Another option is just to call <code>recv()</code> and say the amount you’re willing to receive is the maximum number of bytes in a packet. Then whatever you get, stick it onto the back of a buffer, and finally check to see if the packet is complete. Of course, you might get some of the next packet, so you’ll need to have room for that.</p><p>What you can do is declare an array big enough for two packets. This is your work array where you will reconstruct packets as they arrive.</p><p>Every time you <code>recv()</code> data, you’ll append it into the work buffer and check to see if the packet is complete. That is, the number of bytes in the buffer is greater than or equal to the length specified in the header (+1, because the length in the header doesn’t include the byte for the length itself). If the number of bytes in the buffer is less than 1, the packet is not complete, obviously. You have to make a special case for this, though, since the first byte is garbage and you can’t rely on it for the correct packet length.</p><p>Once the packet is complete, you can do with it what you will. Use it, and remove it from your work buffer.</p><p>Whew! Are you juggling that in your head yet? Well, here’s the second of the one-two punch: you might have read past the end of one packet and onto the next in a single <code>recv()</code> call. That is, you have a work buffer with one complete packet, and an incomplete part of the next packet! Bloody heck. (But this is why you made your work buffer large enough to hold <em>two</em> packets—in case this happened!)</p><p>Since you know the length of the first packet from the header, and you’ve been keeping track of the number of bytes in the work buffer, you can subtract and calculate how many of the bytes in the work buffer belong to the second (incomplete) packet. When you’ve handled the first one, you can clear it out of the work buffer and move the partial second packet down the to front of the buffer so it’s all ready to go for the next <code>recv()</code>.</p><p>(Some of you readers will note that actually moving the partial second packet to the beginning of the work buffer takes time, and the program can be coded to not require this by using a circular buffer. Unfortunately for the rest of you, a discussion on circular buffers is beyond the scope of this article. If you’re still curious, grab a data structures book and go from there.)</p><p>I never said it was easy. Ok, I did say it was easy. And it is; you just need practice and pretty soon it’ll come to you naturally. By  Excalibur I swear it!</p><h2 id="broadcast-packetshello-world"><span class="header-section-number">7.7</span> Broadcast Packets—Hello, World!</h2><p>So far, this guide has talked about sending data from one host to one other host. But it is possible, I insist, that you can, with the proper authority, send data to multiple hosts <em>at the same time</em>!</p><p>With  UDP (only UDP, not TCP) and standard IPv4, this is done through a mechanism called  <em>broadcasting</em>. With IPv6, broadcasting isn’t supported, and you have to resort to the often superior technique of <em>multicasting</em>, which, sadly I won’t be discussing at this time. But enough of the starry-eyed future—we’re stuck in the 32-bit present.</p><p>But wait! You can’t just run off and start broadcasting willy-nilly; You have to  set the socket option  <code>SO_BROADCAST</code> before you can send a broadcast packet out on the network. It’s like a one of those little plastic covers they put over the missile launch switch! That’s just how much power you hold in your hands!</p><p>But seriously, though, there is a danger to using broadcast packets, and that is: every system that receives a broadcast packet must undo all the onion-skin layers of data encapsulation until it finds out what port the data is destined to. And then it hands the data over or discards it. In either case, it’s a lot of work for each machine that receives the broadcast packet, and since it is all of them on the local network, that could be a lot of machines doing a lot of unnecessary work. When the game Doom first came out, this was a complaint about its network code.</p><p>Now, there is more than one way to skin a cat… wait a minute. Is there really more than one way to skin a cat? What kind of expression is that? Uh, and likewise, there is more than one way to send a broadcast packet. So, to get to the meat and potatoes of the whole thing: how do you specify the destination address for a broadcast message? There are two common ways:</p><ol type="1"><li><p>Send the data to a specific subnet’s broadcast address. This is the subnet’s network number with all one-bits set for the host portion of the address. For instance, at home my network is <code>192.168.1.0</code>, my netmask is <code>255.255.255.0</code>, so the last byte of the address is my host number (because the first three bytes, according to the netmask, are the network number). So my broadcast address is <code>192.168.1.255</code>. Under Unix, the <code>ifconfig</code> command will actually give you all this data. (If you’re curious, the bitwise logic to get your broadcast address is <code>network_number</code> OR (NOT <code>netmask</code>).) You can send this type of broadcast packet to remote networks as well as your local network, but you run the risk of the packet being dropped by the destination’s router. (If they didn’t drop it, then some random smurf could start flooding their LAN with broadcast traffic.)</p></li><li><p>Send the data to the “global” broadcast address. This is  <code>255.255.255.255</code>, aka  <code>INADDR_BROADCAST</code>. Many machines will automatically bitwise AND this with your network number to convert it to a network broadcast address, but some won’t. It varies. Routers do not forward this type of broadcast packet off your local network, ironically enough.</p></li></ol><p>So what happens if you try to send data on the broadcast address without first setting the <code>SO_BROADCAST</code> socket option? Well, let’s fire up good old <a href="#datagram"><code>talker</code> and <code>listener</code></a> and see what happens.</p><pre><code>$ talker 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ talker 192.168.1.255 foo
sendto: Permission denied
$ talker 255.255.255.255 foo
sendto: Permission denied</code></pre><p>Yes, it’s not happy at all…because we didn’t set the <code>SO_BROADCAST</code> socket option. Do that, and now you can <code>sendto()</code> anywhere you want!</p><p>In fact, that’s the <em>only difference</em> between a UDP application that can broadcast and one that can’t. So let’s take the old <code>talker</code> application and add one section that sets the <code>SO_BROADCAST</code> socket option. We’ll call this program <a href="https://beej.us/guide/bgnet/examples/broadcaster.c"><code>broadcaster.c</code></a><a href="#fn42" class="footnote-ref" id="fnref42"><sup>42</sup></a>:</p><div class="sourceCode" id="cb75"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb75-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb75-2" title="2"><span class="co">** broadcaster.c -- a datagram &quot;client&quot; like talker.c, except</span></a>
<a class="sourceLine" id="cb75-3" title="3"><span class="co">**                  this one can broadcast</span></a>
<a class="sourceLine" id="cb75-4" title="4"><span class="co">*/</span></a>
<a class="sourceLine" id="cb75-5" title="5"></a>
<a class="sourceLine" id="cb75-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb75-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb75-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb75-9" title="9"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb75-10" title="10"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb75-11" title="11"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb75-12" title="12"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb75-13" title="13"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb75-14" title="14"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb75-15" title="15"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb75-16" title="16"></a>
<a class="sourceLine" id="cb75-17" title="17"><span class="pp">#define SERVERPORT 4950 </span><span class="co">// the port users will be connecting to</span></a>
<a class="sourceLine" id="cb75-18" title="18"></a>
<a class="sourceLine" id="cb75-19" title="19"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb75-20" title="20">{</a>
<a class="sourceLine" id="cb75-21" title="21">    <span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb75-22" title="22">    <span class="kw">struct</span> sockaddr_in their_addr; <span class="co">// connector&#39;s address information</span></a>
<a class="sourceLine" id="cb75-23" title="23">    <span class="kw">struct</span> hostent *he;</a>
<a class="sourceLine" id="cb75-24" title="24">    <span class="dt">int</span> numbytes;</a>
<a class="sourceLine" id="cb75-25" title="25">    <span class="dt">int</span> broadcast = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb75-26" title="26">    <span class="co">//char broadcast = &#39;1&#39;; // if that doesn&#39;t work, try this</span></a>
<a class="sourceLine" id="cb75-27" title="27"></a>
<a class="sourceLine" id="cb75-28" title="28">    <span class="cf">if</span> (argc != <span class="dv">3</span>) {</a>
<a class="sourceLine" id="cb75-29" title="29">        fprintf(stderr,<span class="st">&quot;usage: broadcaster hostname message</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb75-30" title="30">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb75-31" title="31">    }</a>
<a class="sourceLine" id="cb75-32" title="32"></a>
<a class="sourceLine" id="cb75-33" title="33">    <span class="cf">if</span> ((he=gethostbyname(argv[<span class="dv">1</span>])) == NULL) {  <span class="co">// get the host info</span></a>
<a class="sourceLine" id="cb75-34" title="34">        perror(<span class="st">&quot;gethostbyname&quot;</span>);</a>
<a class="sourceLine" id="cb75-35" title="35">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb75-36" title="36">    }</a>
<a class="sourceLine" id="cb75-37" title="37"></a>
<a class="sourceLine" id="cb75-38" title="38">    <span class="cf">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="dv">0</span>)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb75-39" title="39">        perror(<span class="st">&quot;socket&quot;</span>);</a>
<a class="sourceLine" id="cb75-40" title="40">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb75-41" title="41">    }</a>
<a class="sourceLine" id="cb75-42" title="42"></a>
<a class="sourceLine" id="cb75-43" title="43">    <span class="co">// this call is what allows broadcast packets to be sent:</span></a>
<a class="sourceLine" id="cb75-44" title="44">    <span class="cf">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;broadcast,</a>
<a class="sourceLine" id="cb75-45" title="45">        <span class="kw">sizeof</span> broadcast) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb75-46" title="46">        perror(<span class="st">&quot;setsockopt (SO_BROADCAST)&quot;</span>);</a>
<a class="sourceLine" id="cb75-47" title="47">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb75-48" title="48">    }</a>
<a class="sourceLine" id="cb75-49" title="49"></a>
<a class="sourceLine" id="cb75-50" title="50">    their_addr.sin_family = AF_INET;     <span class="co">// host byte order</span></a>
<a class="sourceLine" id="cb75-51" title="51">    their_addr.sin_port = htons(SERVERPORT); <span class="co">// short, network byte order</span></a>
<a class="sourceLine" id="cb75-52" title="52">    their_addr.sin_addr = *((<span class="kw">struct</span> in_addr *)he-&gt;h_addr);</a>
<a class="sourceLine" id="cb75-53" title="53">    memset(their_addr.sin_zero, &#39;\<span class="dv">0</span>&#39;, <span class="kw">sizeof</span> their_addr.sin_zero);</a>
<a class="sourceLine" id="cb75-54" title="54"></a>
<a class="sourceLine" id="cb75-55" title="55">    <span class="cf">if</span> ((numbytes=sendto(sockfd, argv[<span class="dv">2</span>], strlen(argv[<span class="dv">2</span>]), <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb75-56" title="56">             (<span class="kw">struct</span> sockaddr *)&amp;their_addr, <span class="kw">sizeof</span> their_addr)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb75-57" title="57">        perror(<span class="st">&quot;sendto&quot;</span>);</a>
<a class="sourceLine" id="cb75-58" title="58">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb75-59" title="59">    }</a>
<a class="sourceLine" id="cb75-60" title="60"></a>
<a class="sourceLine" id="cb75-61" title="61">    printf(<span class="st">&quot;sent %d bytes to %s</span><span class="sc">\n</span><span class="st">&quot;</span>, numbytes,</a>
<a class="sourceLine" id="cb75-62" title="62">        inet_ntoa(their_addr.sin_addr));</a>
<a class="sourceLine" id="cb75-63" title="63"></a>
<a class="sourceLine" id="cb75-64" title="64">    close(sockfd);</a>
<a class="sourceLine" id="cb75-65" title="65"></a>
<a class="sourceLine" id="cb75-66" title="66">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb75-67" title="67">}</a></code></pre></div><p>What’s different between this and a “normal” UDP client/server situation? Nothing! (With the exception of the client being allowed to send broadcast packets in this case.) As such, go ahead and run the old UDP <a href="#datagram"><code>listener</code></a> program in one window, and <code>broadcaster</code> in another. You should be now be able to do all those sends that failed, above.</p><pre><code>$ broadcaster 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ broadcaster 192.168.1.255 foo
sent 3 bytes to 192.168.1.255
$ broadcaster 255.255.255.255 foo
sent 3 bytes to 255.255.255.255</code></pre><p>And you should see <code>listener</code> responding that it got the packets. (If <code>listener</code> doesn’t respond, it could be because it’s bound to an IPv6 address. Try changing the <code>AF_INET6</code> in <code>listener.c</code> to <code>AF_INET</code> to force IPv4.)</p><p>Well, that’s kind of exciting. But now fire up <code>listener</code> on another machine next to you on the same network so that you have two copies going, one on each machine, and run <code>broadcaster</code> again with your broadcast address… Hey! Both <code>listener</code>s get the packet even though you only called <code>sendto()</code> once! Cool!</p><p>If the <code>listener</code> gets data you send directly to it, but not data on the broadcast address, it could be that you have a  firewall on your local machine that is blocking the packets. (Yes,  Pat and  Bapper, thank you for realizing before I did that this is why my sample code wasn’t working. I told you I’d mention you in the guide, and here you are. So <em>nyah</em>.)</p><p>Again, be careful with broadcast packets. Since every machine on the LAN will be forced to deal with the packet whether it <code>recvfrom()</code>s it or not, it can present quite a load to the entire computing network. They are definitely to be used sparingly and appropriately.</p><h1 id="common-questions"><span class="header-section-number">8</span> Common Questions</h1><p><strong>Where can I get those header files?</strong></p><p> If you don’t have them on your system already, you probably don’t need them. Check the manual for your particular platform. If you’re building for  Windows, you only need to <code>#include &lt;winsock.h&gt;</code>.</p><p><strong>What do I do when <code>bind()</code> reports  “Address already in use”?</strong></p><p>You have to use  <code>setsockopt()</code> with the  <code>SO_REUSEADDR</code> option on the listening socket. Check out the  <a href="#bind">section on <code>bind()</code></a> and the  <a href="#select">section on <code>select()</code></a> for an example.</p><p><strong>How do I get a list of open sockets on the system?</strong></p><p>Use the  <code>netstat</code>. Check the <code>man</code> page for full details, but you should get some good output just typing:</p><pre><code>$ netstat</code></pre><p>The only trick is determining which socket is associated with which program. <code>:-)</code></p><p><strong>How can I view the routing table?</strong></p><p>Run the  <code>route</code> command (in <code>/sbin</code> on most Linuxes) or the command  <code>netstat -r</code>. Or the command  <code>ip route</code>.</p><p><strong>How can I run the client and server programs if I only have one computer? Don’t I need a network to write network programs?</strong></p><p>Fortunately for you, virtually all machines implement a  loopback network “device” that sits in the kernel and pretends to be a network card. (This is the interface listed as “<code>lo</code>” in the routing table.)</p><p>Pretend you’re logged into a machine named  “<code>goat</code>”. Run the client in one window and the server in another. Or start the server in the background (“<code>server &amp;</code>”) and run the client in the same window. The upshot of the loopback device is that you can either <code>client goat</code> or  <code>client localhost</code> (since “<code>localhost</code>” is likely defined in your <code>/etc/hosts</code> file) and you’ll have the client talking to the server without a network!</p><p>In short, no changes are necessary to any of the code to make it run on a single non-networked machine! Huzzah!</p><p><strong>How can I tell if the remote side has closed connection?</strong></p><p>You can tell because <code>recv()</code> will return <code>0</code>.</p><p><strong>How do I implement a  “ping” utility? What is  ICMP? Where can I find out more about  raw sockets and <code>SOCK_RAW</code>?</strong></p><p></p><p>All your raw sockets questions will be answered in <a href="#books">W. Richard Stevens’ UNIX Network Programming books</a>. Also, look in the <code>ping/</code> subdirectory in Stevens’ UNIX Network Programming source code, <a href="http://www.unpbook.com/src.html">available online</a><a href="#fn43" class="footnote-ref" id="fnref43"><sup>43</sup></a>.</p><p><strong>How do I change or shorten the timeout on a call to <code>connect()</code>?</strong></p><p>Instead of giving you exactly the same answer that W. Richard Stevens would give you, I’ll just refer you to <a href="http://www.unpbook.com/src.html"><code>lib/connect_nonb.c</code> in the UNIX Network Programming source code</a><a href="#fn44" class="footnote-ref" id="fnref44"><sup>44</sup></a>.</p><p>The gist of it is that you make a socket descriptor with <code>socket()</code>, <a href="#blocking">set it to non-blocking</a>, call <code>connect()</code>, and if all goes well <code>connect()</code> will return <code>-1</code> immediately and <code>errno</code> will be set to <code>EINPROGRESS</code>. Then you call <a href="#select"><code>select()</code></a> with whatever timeout you want, passing the socket descriptor in both the read and write sets. If it doesn’t timeout, it means the <code>connect()</code> call completed. At this point, you’ll have to use <code>getsockopt()</code> with the <code>SO_ERROR</code> option to get the return value from the <code>connect()</code> call, which should be zero if there was no error.</p><p>Finally, you’ll probably want to set the socket back to be blocking again before you start transferring data over it.</p><p>Notice that this has the added benefit of allowing your program to do something else while it’s connecting, too. You could, for example, set the timeout to something low, like 500 ms, and update an indicator onscreen each timeout, then call <code>select()</code> again. When you’ve called <code>select()</code> and timed-out, say, 20 times, you’ll know it’s time to give up on the connection.</p><p>Like I said, check out Stevens’ source for a perfectly excellent example.</p><p><strong>How do I build for Windows?</strong></p><p>First, delete Windows and install Linux or BSD. <code>};-)</code>. No, actually, just see the <a href="#windows">section on building for Windows</a> in the introduction.</p><p><strong>How do I build for Solaris/SunOS? I keep getting linker errors when I try to compile!</strong></p><p>The linker errors happen because Sun boxes don’t automatically compile in the socket libraries. See the <a href="#solaris">section on building for Solaris/SunOS</a> in the introduction for an example of how to do this.</p><p><strong>Why does <code>select()</code> keep falling out on a signal?</strong></p><p>Signals tend to cause blocked system calls to return <code>-1</code> with <code>errno</code> set to <code>EINTR</code>. When you set up a signal handler with  <code>sigaction()</code>, you can set the flag  <code>SA_RESTART</code>, which is supposed to restart the system call after it was interrupted.</p><p>Naturally, this doesn’t always work.</p><p>My favorite solution to this involves a  <code>goto</code> statement. You know this irritates your professors to no end, so go for it!</p><div class="sourceCode" id="cb78"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb78-1" title="1">select_restart:</a>
<a class="sourceLine" id="cb78-2" title="2"><span class="cf">if</span> ((err = select(fdmax+<span class="dv">1</span>, &amp;readfds, NULL, NULL, NULL)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb78-3" title="3">    <span class="cf">if</span> (errno == EINTR) {</a>
<a class="sourceLine" id="cb78-4" title="4">        <span class="co">// some signal just interrupted us, so restart</span></a>
<a class="sourceLine" id="cb78-5" title="5">        <span class="cf">goto</span> select_restart;</a>
<a class="sourceLine" id="cb78-6" title="6">    }</a>
<a class="sourceLine" id="cb78-7" title="7">    <span class="co">// handle the real error here:</span></a>
<a class="sourceLine" id="cb78-8" title="8">    perror(<span class="st">&quot;select&quot;</span>);</a>
<a class="sourceLine" id="cb78-9" title="9">} </a></code></pre></div><p>Sure, you don’t <em>need</em> to use <code>goto</code> in this case; you can use other structures to control it. But I think the <code>goto</code> statement is actually cleaner.</p><p><strong>How can I implement a timeout on a call to <code>recv()</code>?</strong></p><p> Use  <a href="#select"><code>select()</code></a>! It allows you to specify a timeout parameter for socket descriptors that you’re looking to read from. Or, you could wrap the entire functionality in a single function, like this:</p><div class="sourceCode" id="cb79"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb79-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb79-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/time.h&gt;</span></a>
<a class="sourceLine" id="cb79-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb79-4" title="4"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb79-5" title="5"></a>
<a class="sourceLine" id="cb79-6" title="6"><span class="dt">int</span> recvtimeout(<span class="dt">int</span> s, <span class="dt">char</span> *buf, <span class="dt">int</span> len, <span class="dt">int</span> timeout)</a>
<a class="sourceLine" id="cb79-7" title="7">{</a>
<a class="sourceLine" id="cb79-8" title="8">    fd_set fds;</a>
<a class="sourceLine" id="cb79-9" title="9">    <span class="dt">int</span> n;</a>
<a class="sourceLine" id="cb79-10" title="10">    <span class="kw">struct</span> timeval tv;</a>
<a class="sourceLine" id="cb79-11" title="11"></a>
<a class="sourceLine" id="cb79-12" title="12">    <span class="co">// set up the file descriptor set</span></a>
<a class="sourceLine" id="cb79-13" title="13">    FD_ZERO(&amp;fds);</a>
<a class="sourceLine" id="cb79-14" title="14">    FD_SET(s, &amp;fds);</a>
<a class="sourceLine" id="cb79-15" title="15"></a>
<a class="sourceLine" id="cb79-16" title="16">    <span class="co">// set up the struct timeval for the timeout</span></a>
<a class="sourceLine" id="cb79-17" title="17">    tv.tv_sec = timeout;</a>
<a class="sourceLine" id="cb79-18" title="18">    tv.tv_usec = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb79-19" title="19"></a>
<a class="sourceLine" id="cb79-20" title="20">    <span class="co">// wait until timeout or data received</span></a>
<a class="sourceLine" id="cb79-21" title="21">    n = select(s+<span class="dv">1</span>, &amp;fds, NULL, NULL, &amp;tv);</a>
<a class="sourceLine" id="cb79-22" title="22">    <span class="cf">if</span> (n == <span class="dv">0</span>) <span class="cf">return</span> <span class="dv">-2</span>; <span class="co">// timeout!</span></a>
<a class="sourceLine" id="cb79-23" title="23">    <span class="cf">if</span> (n == <span class="dv">-1</span>) <span class="cf">return</span> <span class="dv">-1</span>; <span class="co">// error</span></a>
<a class="sourceLine" id="cb79-24" title="24"></a>
<a class="sourceLine" id="cb79-25" title="25">    <span class="co">// data must be here, so do a normal recv()</span></a>
<a class="sourceLine" id="cb79-26" title="26">    <span class="cf">return</span> recv(s, buf, len, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb79-27" title="27">}</a>
<a class="sourceLine" id="cb79-28" title="28">.</a>
<a class="sourceLine" id="cb79-29" title="29">.</a>
<a class="sourceLine" id="cb79-30" title="30">.</a>
<a class="sourceLine" id="cb79-31" title="31"><span class="co">// Sample call to recvtimeout():</span></a>
<a class="sourceLine" id="cb79-32" title="32">n = recvtimeout(s, buf, <span class="kw">sizeof</span> buf, <span class="dv">10</span>); <span class="co">// 10 second timeout</span></a>
<a class="sourceLine" id="cb79-33" title="33"></a>
<a class="sourceLine" id="cb79-34" title="34"><span class="cf">if</span> (n == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb79-35" title="35">    <span class="co">// error occurred</span></a>
<a class="sourceLine" id="cb79-36" title="36">    perror(<span class="st">&quot;recvtimeout&quot;</span>);</a>
<a class="sourceLine" id="cb79-37" title="37">}</a>
<a class="sourceLine" id="cb79-38" title="38"><span class="cf">else</span> <span class="cf">if</span> (n == <span class="dv">-2</span>) {</a>
<a class="sourceLine" id="cb79-39" title="39">    <span class="co">// timeout occurred</span></a>
<a class="sourceLine" id="cb79-40" title="40">} <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb79-41" title="41">    <span class="co">// got some data in buf</span></a>
<a class="sourceLine" id="cb79-42" title="42">}</a>
<a class="sourceLine" id="cb79-43" title="43">.</a>
<a class="sourceLine" id="cb79-44" title="44">.</a>
<a class="sourceLine" id="cb79-45" title="45">. </a></code></pre></div><p>Notice that  <code>recvtimeout()</code> returns <code>-2</code> in case of a timeout. Why not return <code>0</code>? Well, if you recall, a return value of <code>0</code> on a call to <code>recv()</code> means that the remote side closed the connection. So that return value is already spoken for, and <code>-1</code> means “error”, so I chose <code>-2</code> as my timeout indicator.</p><p><strong>How do I  encrypt or compress the data before sending it through the socket?</strong></p><p>One easy way to do encryption is to use  SSL (secure sockets layer), but that’s beyond the scope of this guide.  (Check out the <a href="https://www.openssl.org/">OpenSSL project</a><a href="#fn45" class="footnote-ref" id="fnref45"><sup>45</sup></a> for more info.)</p><p>But assuming you want to plug in or implement your own  compressor or encryption system, it’s just a matter of thinking of your data as running through a sequence of steps between both ends. Each step changes the data in some way.</p><ol type="1"><li>server reads data from file (or wherever)</li><li>server encrypts/compresses data (you add this part)</li><li>server <code>send()</code>s encrypted data</li></ol><p>Now the other way around:</p><ol type="1"><li>client <code>recv()</code>s encrypted data</li><li>client decrypts/decompresses data (you add this part)</li><li>client writes data to file (or wherever)</li></ol><p>If you’re going to compress and encrypt, just remember to compress first. <code>:-)</code></p><p>Just as long as the client properly undoes what the server does, the data will be fine in the end no matter how many intermediate steps you add.</p><p>So all you need to do to use my code is to find the place between where the data is read and the data is sent (using <code>send()</code>) over the network, and stick some code in there that does the encryption.</p><p><strong>What is this “<code>PF_INET</code>” I keep seeing? Is it related to <code>AF_INET</code>?</strong></p><p> </p><p>Yes, yes it is. See <a href="#socket">the section on <code>socket()</code></a> for details.</p><p><strong>How can I write a server that accepts shell commands from a client and executes them?</strong></p><p>For simplicity, lets say the client <code>connect()</code>s, <code>send()</code>s, and <code>close()</code>s the connection (that is, there are no subsequent system calls without the client connecting again).</p><p>The process the client follows is this:</p><ol type="1"><li><code>connect()</code> to server</li><li><code>send(&quot;/sbin/ls &gt; /tmp/client.out&quot;)</code></li><li><code>close()</code> the connection</li></ol><p>Meanwhile, the server is handling the data and executing it:</p><ol type="1"><li><code>accept()</code> the connection from the client</li><li><code>recv(str)</code> the command string</li><li><code>close()</code> the connection</li><li><code>system(str)</code> to run the command</li></ol><p> <em>Beware!</em> Having the server execute what the client says is like giving remote shell access and people can do things to your account when they connect to the server. For instance, in the above example, what if the client sends “<code>rm -rf ~</code>”? It deletes everything in your account, that’s what!</p><p>So you get wise, and you prevent the client from using any except for a couple utilities that you know are safe, like the <code>foobar</code> utility:</p><div class="sourceCode" id="cb80"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb80-1" title="1"><span class="cf">if</span> (!strncmp(str, <span class="st">&quot;foobar&quot;</span>, <span class="dv">6</span>)) {</a>
<a class="sourceLine" id="cb80-2" title="2">    sprintf(sysstr, <span class="st">&quot;%s &gt; /tmp/server.out&quot;</span>, str);</a>
<a class="sourceLine" id="cb80-3" title="3">    system(sysstr);</a>
<a class="sourceLine" id="cb80-4" title="4">} </a></code></pre></div><p>But you’re still unsafe, unfortunately: what if the client enters “<code>foobar; rm -rf ~</code>”? The safest thing to do is to write a little routine that puts an escape (“<code>\</code>”) character in front of all non-alphanumeric characters (including spaces, if appropriate) in the arguments for the command.</p><p>As you can see, security is a pretty big issue when the server starts executing things the client sends.</p><p><strong>I’m sending a slew of data, but when I <code>recv()</code>, it only receives 536 bytes or 1460 bytes at a time. But if I run it on my local machine, it receives all the data at the same time. What’s going on?</strong></p><p>You’re hitting the  MTU—the maximum size the physical medium can handle. On the local machine, you’re using the loopback device which can handle 8K or more no problem. But on Ethernet, which can only handle 1500 bytes with a header, you hit that limit. Over a modem, with 576 MTU (again, with header), you hit the even lower limit.</p><p>You have to make sure all the data is being sent, first of all. (See the <a href="#sendall"><code>sendall()</code></a> function implementation for details.) Once you’re sure of that, then you need to call <code>recv()</code> in a loop until all your data is read.</p><p>Read the section <a href="#sonofdataencap">Son of Data Encapsulation</a> for details on receiving complete packets of data using multiple calls to <code>recv()</code>.</p><p><strong>I’m on a Windows box and I don’t have the <code>fork()</code> system call or any kind of <code>struct sigaction</code>. What to do?</strong></p><p> If they’re anywhere, they’ll be in POSIX libraries that may have shipped with your compiler. Since I don’t have a Windows box, I really can’t tell you the answer, but I seem to remember that Microsoft has a POSIX compatibility layer and that’s where <code>fork()</code> would be. (And maybe even <code>sigaction</code>.)</p><p>Search the help that came with VC++ for “fork” or “POSIX” and see if it gives you any clues.</p><p>If that doesn’t work at all, ditch the <code>fork()</code>/<code>sigaction</code> stuff and replace it with the Win32 equivalent:  <code>CreateProcess()</code>. I don’t know how to use <code>CreateProcess()</code>—it takes a bazillion arguments, but it should be covered in the docs that came with VC++.</p><p><strong> I’m behind a firewall—how do I let people outside the firewall know my IP address so they can connect to my machine?</strong></p><p>Unfortunately, the purpose of a firewall is to prevent people outside the firewall from connecting to machines inside the firewall, so allowing them to do so is basically considered a breach of security.</p><p>This isn’t to say that all is lost. For one thing, you can still often <code>connect()</code> through the firewall if it’s doing some kind of masquerading or NAT or something like that. Just design your programs so that you’re always the one initiating the connection, and you’ll be fine.</p><p> If that’s not satisfactory, you can ask your sysadmins to poke a hole in the firewall so that people can connect to you. The firewall can forward to you either through it’s NAT software, or through a proxy or something like that.</p><p>Be aware that a hole in the firewall is nothing to be taken lightly. You have to make sure you don’t give bad people access to the internal network; if you’re a beginner, it’s a lot harder to make software secure than you might imagine.</p><p>Don’t make your sysadmin mad at me. <code>;-)</code></p><p><strong>  How do I write a packet sniffer? How do I put my Ethernet interface into promiscuous mode?</strong></p><p>For those not in the know, when a network card is in “promiscuous mode”, it will forward ALL packets to the operating system, not just those that were addressed to this particular machine. (We’re talking Ethernet-layer addresses here, not IP addresses–but since ethernet is lower-layer than IP, all IP addresses are effectively forwarded as well. See the section <a href="#lowlevel">Low Level Nonsense and Network Theory</a> for more info.)</p><p>This is the basis for how a packet sniffer works. It puts the interface into promiscuous mode, then the OS gets every single packet that goes by on the wire. You’ll have a socket of some type that you can read this data from.</p><p>Unfortunately, the answer to the question varies depending on the platform, but if you Google for, for instance, “windows promiscuous  ioctl” you’ll probably get somewhere. For Linux, there’s what looks like a <a href="https://stackoverflow.com/questions/21323023/">useful Stack Overflow thread</a><a href="#fn46" class="footnote-ref" id="fnref46"><sup>46</sup></a>, as well.</p><p><strong>How can I set a custom  timeout value for a TCP or UDP socket?</strong></p><p>It depends on your system. You might search the net for  <code>SO_RCVTIMEO</code> and  <code>SO_SNDTIMEO</code> (for use with  <code>setsockopt()</code>) to see if your system supports such functionality.</p><p>The Linux man page suggests using <code>alarm()</code> or <code>setitimer()</code> as a substitute.</p><p><strong>How can I tell which ports are available to use? Is there a list of “official” port numbers?</strong></p><p>Usually this isn’t an issue. If you’re writing, say, a web server, then it’s a good idea to use the well-known port 80 for your software. If you’re writing just your own specialized server, then choose a port at random (but greater than 1023) and give it a try.</p><p>If the port is already in use, you’ll get an “Address already in use” error when you try to <code>bind()</code>. Choose another port. (It’s a good idea to allow the user of your software to specify an alternate port either with a config file or a command line switch.)</p><p>There is a <a href="https://www.iana.org/assignments/port-numbers">list of official port numbers</a><a href="#fn47" class="footnote-ref" id="fnref47"><sup>47</sup></a> maintained by the Internet Assigned Numbers Authority (IANA). Just because something (over 1023) is in that list doesn’t mean you can’t use the port. For instance, Id Software’s DOOM uses the same port as “mdqs”, whatever that is. All that matters is that no one else <em>on the same machine</em> is using that port when you want to use it.</p><h1 id="man-pages"><span class="header-section-number">9</span> Man Pages</h1><p></p><p>In the Unix world, there are a lot of manuals. They have little sections that describe individual functions that you have at your disposal.</p><p>Of course, <code>manual</code> would be too much of a thing to type. I mean, no one in the Unix world, including myself, likes to type that much. Indeed I could go on and on at great length about how much I prefer to be terse but instead I shall be brief and not bore you with long-winded diatribes about how utterly amazingly brief I prefer to be in virtually all circumstances in their entirety.</p><p><em>[Applause]</em></p><p>Thank you. What I am getting at is that these pages are called “man pages” in the Unix world, and I have included my own personal truncated variant here for your reading enjoyment. The thing is, many of these functions are way more general purpose than I’m letting on, but I’m only going to present the parts that are relevant for Internet Sockets Programming.</p><p>But wait! That’s not all that’s wrong with my man pages:</p><ul><li>They are incomplete and only show the basics from the guide.</li><li>There are many more man pages than this in the real world.</li><li>They are different than the ones on your system.</li><li>The header files might be different for certain functions on your system.</li><li>The function parameters might be different for certain functions on your system.</li></ul><p>If you want the real information, check your local Unix man pages by typing <code>man whatever</code>, where “whatever” is something that you’re incredibly interested in, such as “<code>accept</code>”. (I’m sure Microsoft Visual Studio has something similar in their help section. But “man” is better because it is one byte more concise than “help”. Unix wins again!)</p><p>So, if these are so flawed, why even include them at all in the Guide? Well, there are a few reasons, but the best are that (a) these versions are geared specifically toward network programming and are easier to digest than the real ones, and (b) these versions contain examples!</p><p>Oh! And speaking of the examples, I don’t tend to put in all the error checking because it really increases the length of the code. But you should absolutely do error checking pretty much any time you make any of the system calls unless you’re totally 100% sure it’s not going to fail, and you should probably do it even then!</p><p></p><h2 id="acceptman"><span class="header-section-number">9.1</span> <code>accept()</code></h2><p></p><p>Accept an incoming connection on a listening socket</p><h3 id="synopsis" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb81"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb81-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb81-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb81-3" title="3"></a>
<a class="sourceLine" id="cb81-4" title="4"><span class="dt">int</span> accept(<span class="dt">int</span> s, <span class="kw">struct</span> sockaddr *addr, socklen_t *addrlen);</a></code></pre></div><h3 id="description" class="unnumbered unlisted">Description</h3><p>Once you’ve gone through the trouble of getting a <code>SOCK_STREAM</code> socket and setting it up for incoming connections with <code>listen()</code>, then you call <code>accept()</code> to actually get yourself a new socket descriptor to use for subsequent communication with the newly connected client.</p><p>The old socket that you are using for listening is still there, and will be used for further <code>accept()</code> calls as they come in.</p><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th>Parameter</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>s</code></td><td>The <code>listen()</code>ing socket descriptor.</td></tr><tr class="even"><td><code>addr</code></td><td>This is filled in with the address of the site that’s connecting to you.</td></tr><tr class="odd"><td><code>addrlen</code></td><td>This is filled in with the <code>sizeof()</code> the structure returned in the <code>addr</code> parameter. You can safely ignore it if you assume you’re getting a <code>struct sockaddr_in</code> back, which you know you are, because that’s the type you passed in for <code>addr</code>.</td></tr></tbody></table><p><code>accept()</code> will normally block, and you can use <code>select()</code> to peek on the listening socket descriptor ahead of time to see if it’s “ready to read”. If so, then there’s a new connection waiting to be <code>accept()</code>ed! Yay! Alternatively, you could set the  <code>O_NONBLOCK</code> flag on the listening socket using  <code>fcntl()</code>, and then it will never block, choosing instead to return <code>-1</code> with <code>errno</code> set to <code>EWOULDBLOCK</code>.</p><p>The socket descriptor returned by <code>accept()</code> is a bona fide socket descriptor, open and connected to the remote host. You have to <code>close()</code> it when you’re done with it.</p><h3 id="return-value" class="unnumbered unlisted">Return Value</h3><p><code>accept()</code> returns the newly connected socket descriptor, or <code>-1</code> on error, with <code>errno</code> set appropriately.</p><h3 id="example" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb82"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb82-1" title="1"><span class="kw">struct</span> sockaddr_storage their_addr;</a>
<a class="sourceLine" id="cb82-2" title="2">socklen_t addr_size;</a>
<a class="sourceLine" id="cb82-3" title="3"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb82-4" title="4"><span class="dt">int</span> sockfd, new_fd;</a>
<a class="sourceLine" id="cb82-5" title="5"></a>
<a class="sourceLine" id="cb82-6" title="6"><span class="co">// first, load up address structs with getaddrinfo():</span></a>
<a class="sourceLine" id="cb82-7" title="7"></a>
<a class="sourceLine" id="cb82-8" title="8">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb82-9" title="9">hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></a>
<a class="sourceLine" id="cb82-10" title="10">hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb82-11" title="11">hints.ai_flags = AI_PASSIVE;     <span class="co">// fill in my IP for me</span></a>
<a class="sourceLine" id="cb82-12" title="12"></a>
<a class="sourceLine" id="cb82-13" title="13">getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb82-14" title="14"></a>
<a class="sourceLine" id="cb82-15" title="15"><span class="co">// make a socket, bind it, and listen on it:</span></a>
<a class="sourceLine" id="cb82-16" title="16"></a>
<a class="sourceLine" id="cb82-17" title="17">sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb82-18" title="18">bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a>
<a class="sourceLine" id="cb82-19" title="19">listen(sockfd, BACKLOG);</a>
<a class="sourceLine" id="cb82-20" title="20"></a>
<a class="sourceLine" id="cb82-21" title="21"><span class="co">// now accept an incoming connection:</span></a>
<a class="sourceLine" id="cb82-22" title="22"></a>
<a class="sourceLine" id="cb82-23" title="23">addr_size = <span class="kw">sizeof</span> their_addr;</a>
<a class="sourceLine" id="cb82-24" title="24">new_fd = accept(sockfd, (<span class="kw">struct</span> sockaddr *)&amp;their_addr, &amp;addr_size);</a>
<a class="sourceLine" id="cb82-25" title="25"></a>
<a class="sourceLine" id="cb82-26" title="26"><span class="co">// ready to communicate on socket descriptor new_fd!</span></a></code></pre></div><h3 id="see-also" class="unnumbered unlisted">See Also</h3><p><a href="#socketman"><code>socket()</code></a>, <a href="#getaddrinfoman"><code>getaddrinfo()</code></a>, <a href="#listenman"><code>listen()</code></a>, <a href="#structsockaddrman"><code>struct sockaddr_in</code></a></p><h2 id="bindman"><span class="header-section-number">9.2</span> <code>bind()</code></h2><p></p><p>Associate a socket with an IP address and port number</p><h3 id="synopsis-1" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb83"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb83-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb83-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb83-3" title="3"></a>
<a class="sourceLine" id="cb83-4" title="4"><span class="dt">int</span> bind(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *my_addr, socklen_t addrlen);</a></code></pre></div><h3 id="description-1" class="unnumbered unlisted">Description</h3><p>When a remote machine wants to connect to your server program, it needs two pieces of information: the IP address and the port number. The <code>bind()</code> call allows you to do just that.</p><p>First, you call <code>getaddrinfo()</code> to load up a <code>struct sockaddr</code> with the destination address and port information. Then you call <code>socket()</code> to get a socket descriptor, and then you pass the socket and address into <code>bind()</code>, and the IP address and port are magically (using actual magic) bound to the socket!</p><p>If you don’t know your IP address, or you know you only have one IP address on the machine, or you don’t care which of the machine’s IP addresses is used, you can simply pass the <code>AI_PASSIVE</code> flag in the <code>hints</code> parameter to <code>getaddrinfo()</code>. What this does is fill in the IP address part of the <code>struct sockaddr</code> with a special value that tells <code>bind()</code> that it should automatically fill in this host’s IP address.</p><p>What what? What special value is loaded into the <code>struct sockaddr</code>’s IP address to cause it to auto-fill the address with the current host? I’ll tell you, but keep in mind this is only if you’re filling out the <code>struct sockaddr</code> by hand; if not, use the results from <code>getaddrinfo()</code>, as per above. In IPv4, the <code>sin_addr.s_addr</code> field of the <code>struct sockaddr_in</code> structure is set to <code>INADDR_ANY</code>. In IPv6, the <code>sin6_addr</code> field of the <code>struct sockaddr_in6</code> structure is assigned into from the global variable <code>in6addr_any</code>. Or, if you’re declaring a new <code>struct in6_addr</code>, you can initialize it to <code>IN6ADDR_ANY_INIT</code>.</p><p>Lastly, the <code>addrlen</code> parameter should be set to <code>sizeof my_addr</code>.</p><h3 id="return-value-1" class="unnumbered unlisted">Return Value</h3><p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p><h3 id="example-1" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb84"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb84-1" title="1"><span class="co">// modern way of doing things with getaddrinfo()</span></a>
<a class="sourceLine" id="cb84-2" title="2"></a>
<a class="sourceLine" id="cb84-3" title="3"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb84-4" title="4"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb84-5" title="5"></a>
<a class="sourceLine" id="cb84-6" title="6"><span class="co">// first, load up address structs with getaddrinfo():</span></a>
<a class="sourceLine" id="cb84-7" title="7"></a>
<a class="sourceLine" id="cb84-8" title="8">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb84-9" title="9">hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></a>
<a class="sourceLine" id="cb84-10" title="10">hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb84-11" title="11">hints.ai_flags = AI_PASSIVE;     <span class="co">// fill in my IP for me</span></a>
<a class="sourceLine" id="cb84-12" title="12"></a>
<a class="sourceLine" id="cb84-13" title="13">getaddrinfo(NULL, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb84-14" title="14"></a>
<a class="sourceLine" id="cb84-15" title="15"><span class="co">// make a socket:</span></a>
<a class="sourceLine" id="cb84-16" title="16"><span class="co">// (you should actually walk the &quot;res&quot; linked list and error-check!)</span></a>
<a class="sourceLine" id="cb84-17" title="17"></a>
<a class="sourceLine" id="cb84-18" title="18">sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb84-19" title="19"></a>
<a class="sourceLine" id="cb84-20" title="20"><span class="co">// bind it to the port we passed in to getaddrinfo():</span></a>
<a class="sourceLine" id="cb84-21" title="21"></a>
<a class="sourceLine" id="cb84-22" title="22">bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a></code></pre></div><div class="sourceCode" id="cb85"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb85-1" title="1"><span class="co">// example of packing a struct by hand, IPv4</span></a>
<a class="sourceLine" id="cb85-2" title="2"></a>
<a class="sourceLine" id="cb85-3" title="3"><span class="kw">struct</span> sockaddr_in myaddr;</a>
<a class="sourceLine" id="cb85-4" title="4"><span class="dt">int</span> s;</a>
<a class="sourceLine" id="cb85-5" title="5"></a>
<a class="sourceLine" id="cb85-6" title="6">myaddr.sin_family = AF_INET;</a>
<a class="sourceLine" id="cb85-7" title="7">myaddr.sin_port = htons(<span class="dv">3490</span>);</a>
<a class="sourceLine" id="cb85-8" title="8"></a>
<a class="sourceLine" id="cb85-9" title="9"><span class="co">// you can specify an IP address:</span></a>
<a class="sourceLine" id="cb85-10" title="10">inet_pton(AF_INET, <span class="st">&quot;63.161.169.137&quot;</span>, &amp;(myaddr.sin_addr));</a>
<a class="sourceLine" id="cb85-11" title="11"></a>
<a class="sourceLine" id="cb85-12" title="12"><span class="co">// or you can let it automatically select one:</span></a>
<a class="sourceLine" id="cb85-13" title="13">myaddr.sin_addr.s_addr = INADDR_ANY;</a>
<a class="sourceLine" id="cb85-14" title="14"></a>
<a class="sourceLine" id="cb85-15" title="15">s = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb85-16" title="16">bind(s, (<span class="kw">struct</span> sockaddr*)&amp;myaddr, <span class="kw">sizeof</span> myaddr);</a></code></pre></div><h3 id="see-also-1" class="unnumbered unlisted">See Also</h3><p><a href="#getaddrinfoman"><code>getaddrinfo()</code></a>, <a href="#socketman"><code>socket()</code></a>, <a href="#structsockaddrman"><code>struct sockaddr_in</code></a>, <a href="#structsockaddrman"><code>struct in_addr</code></a></p><h2 id="connectman"><span class="header-section-number">9.3</span> <code>connect()</code></h2><p></p><p>Connect a socket to a server</p><h3 id="synopsis-2" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb86"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb86-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb86-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb86-3" title="3"></a>
<a class="sourceLine" id="cb86-4" title="4"><span class="dt">int</span> connect(<span class="dt">int</span> sockfd, <span class="dt">const</span> <span class="kw">struct</span> sockaddr *serv_addr,</a>
<a class="sourceLine" id="cb86-5" title="5">            socklen_t addrlen);</a></code></pre></div><h3 id="description-2" class="unnumbered unlisted">Description</h3><p>Once you’ve built a socket descriptor with the <code>socket()</code> call, you can <code>connect()</code> that socket to a remote server using the well-named <code>connect()</code> system call. All you need to do is pass it the socket descriptor and the address of the server you’re interested in getting to know better. (Oh, and the length of the address, which is commonly passed to functions like this.)</p><p>Usually this information comes along as the result of a call to <code>getaddrinfo()</code>, but you can fill out your own <code>struct sockaddr</code> if you want to.</p><p>If you haven’t yet called <code>bind()</code> on the socket descriptor, it is automatically bound to your IP address and a random local port. This is usually just fine with you if you’re not a server, since you really don’t care what your local port is; you only care what the remote port is so you can put it in the <code>serv_addr</code> parameter. You <em>can</em> call <code>bind()</code> if you really want your client socket to be on a specific IP address and port, but this is pretty rare.</p><p>Once the socket is <code>connect()</code>ed, you’re free to <code>send()</code> and <code>recv()</code> data on it to your heart’s content.</p><p> Special note: if you <code>connect()</code> a <code>SOCK_DGRAM</code> UDP socket to a remote host, you can use <code>send()</code> and <code>recv()</code> as well as <code>sendto()</code> and <code>recvfrom()</code>. If you want.</p><h3 id="return-value-2" class="unnumbered unlisted">Return Value</h3><p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p><h3 id="example-2" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb87"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb87-1" title="1"><span class="co">// connect to www.example.com port 80 (http)</span></a>
<a class="sourceLine" id="cb87-2" title="2"></a>
<a class="sourceLine" id="cb87-3" title="3"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb87-4" title="4"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb87-5" title="5"></a>
<a class="sourceLine" id="cb87-6" title="6"><span class="co">// first, load up address structs with getaddrinfo():</span></a>
<a class="sourceLine" id="cb87-7" title="7"></a>
<a class="sourceLine" id="cb87-8" title="8">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb87-9" title="9">hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></a>
<a class="sourceLine" id="cb87-10" title="10">hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb87-11" title="11"></a>
<a class="sourceLine" id="cb87-12" title="12"><span class="co">// we could put &quot;80&quot; instead on &quot;http&quot; on the next line:</span></a>
<a class="sourceLine" id="cb87-13" title="13">getaddrinfo(<span class="st">&quot;www.example.com&quot;</span>, <span class="st">&quot;http&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb87-14" title="14"></a>
<a class="sourceLine" id="cb87-15" title="15"><span class="co">// make a socket:</span></a>
<a class="sourceLine" id="cb87-16" title="16"></a>
<a class="sourceLine" id="cb87-17" title="17">sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb87-18" title="18"></a>
<a class="sourceLine" id="cb87-19" title="19"><span class="co">// connect it to the address and port we passed in to getaddrinfo():</span></a>
<a class="sourceLine" id="cb87-20" title="20"></a>
<a class="sourceLine" id="cb87-21" title="21">connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a></code></pre></div><h3 id="see-also-2" class="unnumbered unlisted">See Also</h3><p><a href="#socketman"><code>socket()</code></a>, <a href="#bindman"><code>bind()</code></a></p><h2 id="closeman"><span class="header-section-number">9.4</span> <code>close()</code></h2><p></p><p>Close a socket descriptor</p><h3 id="synopsis-3" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb88"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb88-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb88-2" title="2"></a>
<a class="sourceLine" id="cb88-3" title="3"><span class="dt">int</span> close(<span class="dt">int</span> s);</a></code></pre></div><h3 id="description-3" class="unnumbered unlisted">Description</h3><p>After you’ve finished using the socket for whatever demented scheme you have concocted and you don’t want to <code>send()</code> or <code>recv()</code> or, indeed, do <em>anything else</em> at all with the socket, you can <code>close()</code> it, and it’ll be freed up, never to be used again.</p><p>The remote side can tell if this happens one of two ways. One: if the remote side calls <code>recv()</code>, it will return <code>0</code>. Two: if the remote side calls <code>send()</code>, it’ll receive a signal  <code>SIGPIPE</code> and send() will return <code>-1</code> and <code>errno</code> will be set to  <code>EPIPE</code>.</p><p> <strong>Windows users</strong>: the function you need to use is called  <code>closesocket()</code>, not <code>close()</code>. If you try to use <code>close()</code> on a socket descriptor, it’s possible Windows will get angry… And you wouldn’t like it when it’s angry.</p><h3 id="return-value-3" class="unnumbered unlisted">Return Value</h3><p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p><h3 id="example-3" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb89"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb89-1" title="1">s = socket(PF_INET, SOCK_DGRAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb89-2" title="2">.</a>
<a class="sourceLine" id="cb89-3" title="3">.</a>
<a class="sourceLine" id="cb89-4" title="4">.</a>
<a class="sourceLine" id="cb89-5" title="5"><span class="co">// a whole lotta stuff...*BRRRONNNN!*</span></a>
<a class="sourceLine" id="cb89-6" title="6">.</a>
<a class="sourceLine" id="cb89-7" title="7">.</a>
<a class="sourceLine" id="cb89-8" title="8">.</a>
<a class="sourceLine" id="cb89-9" title="9">close(s);  <span class="co">// not much to it, really.</span></a></code></pre></div><h3 id="see-also-3" class="unnumbered unlisted">See Also</h3><p><a href="#socketman"><code>socket()</code></a>, <a href="#shutdownman"><code>shutdown()</code></a></p><h2 id="getaddrinfoman"><span class="header-section-number">9.5</span> <code>getaddrinfo()</code>, <code>freeaddrinfo()</code>, <code>gai_strerror()</code></h2><p>  </p><p>Get information about a host name and/or service and load up a <code>struct sockaddr</code> with the result.</p><h3 id="synopsis-4" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb90"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb90-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb90-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb90-3" title="3"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb90-4" title="4"></a>
<a class="sourceLine" id="cb90-5" title="5"><span class="dt">int</span> getaddrinfo(<span class="dt">const</span> <span class="dt">char</span> *nodename, <span class="dt">const</span> <span class="dt">char</span> *servname,</a>
<a class="sourceLine" id="cb90-6" title="6">                <span class="dt">const</span> <span class="kw">struct</span> addrinfo *hints, <span class="kw">struct</span> addrinfo **res);</a>
<a class="sourceLine" id="cb90-7" title="7"></a>
<a class="sourceLine" id="cb90-8" title="8"><span class="dt">void</span> freeaddrinfo(<span class="kw">struct</span> addrinfo *ai);</a>
<a class="sourceLine" id="cb90-9" title="9"></a>
<a class="sourceLine" id="cb90-10" title="10"><span class="dt">const</span> <span class="dt">char</span> *gai_strerror(<span class="dt">int</span> ecode);</a>
<a class="sourceLine" id="cb90-11" title="11"></a>
<a class="sourceLine" id="cb90-12" title="12"><span class="kw">struct</span> addrinfo {</a>
<a class="sourceLine" id="cb90-13" title="13">  <span class="dt">int</span>     ai_flags;          <span class="co">// AI_PASSIVE, AI_CANONNAME, ...</span></a>
<a class="sourceLine" id="cb90-14" title="14">  <span class="dt">int</span>     ai_family;         <span class="co">// AF_xxx</span></a>
<a class="sourceLine" id="cb90-15" title="15">  <span class="dt">int</span>     ai_socktype;       <span class="co">// SOCK_xxx</span></a>
<a class="sourceLine" id="cb90-16" title="16">  <span class="dt">int</span>     ai_protocol;       <span class="co">// 0 (auto) or IPPROTO_TCP, IPPROTO_UDP </span></a>
<a class="sourceLine" id="cb90-17" title="17"></a>
<a class="sourceLine" id="cb90-18" title="18">  socklen_t  ai_addrlen;     <span class="co">// length of ai_addr</span></a>
<a class="sourceLine" id="cb90-19" title="19">  <span class="dt">char</span>   *ai_canonname;      <span class="co">// canonical name for nodename</span></a>
<a class="sourceLine" id="cb90-20" title="20">  <span class="kw">struct</span> sockaddr  *ai_addr; <span class="co">// binary address</span></a>
<a class="sourceLine" id="cb90-21" title="21">  <span class="kw">struct</span> addrinfo  *ai_next; <span class="co">// next structure in linked list</span></a>
<a class="sourceLine" id="cb90-22" title="22">};</a></code></pre></div><h3 id="description-4" class="unnumbered unlisted">Description</h3><p><code>getaddrinfo()</code> is an excellent function that will return information on a particular host name (such as its IP address) and load up a <code>struct sockaddr</code> for you, taking care of the gritty details (like if it’s IPv4 or IPv6). It replaces the old functions <code>gethostbyname()</code> and <code>getservbyname()</code>.The description, below, contains a lot of information that might be a little daunting, but actual usage is pretty simple. It might be worth it to check out the examples first.</p><p>The host name that you’re interested in goes in the <code>nodename</code> parameter. The address can be either a host name, like “www.example.com”, or an IPv4 or IPv6 address (passed as a string). This parameter can also be <code>NULL</code> if you’re using the <code>AI_PASSIVE</code> flag (see below).</p><p>The <code>servname</code> parameter is basically the port number. It can be a port number (passed as a string, like “80”), or it can be a service name, like “http” or “tftp” or “smtp” or “pop”, etc. Well-known service names can be found in the <a href="https://www.iana.org/assignments/port-numbers">IANA Port List</a><a href="#fn48" class="footnote-ref" id="fnref48"><sup>48</sup></a> or in your <code>/etc/services</code> file.</p><p>Lastly, for input parameters, we have <code>hints</code>. This is really where you get to define what the <code>getaddrinfo()</code> function is going to do. Zero the whole structure before use with <code>memset()</code>. Let’s take a look at the fields you need to set up before use.</p><p>The <code>ai_flags</code> can be set to a variety of things, but here are a couple important ones. (Multiple flags can be specified by bitwise-ORing them together with the <code>|</code> operator). Check your man page for the complete list of flags.</p><p><code>AI_CANONNAME</code> causes the <code>ai_canonname</code> of the result to the filled out with the host’s canonical (real) name. <code>AI_PASSIVE</code> causes the result’s IP address to be filled out with <code>INADDR_ANY</code> (IPv4) or <code>in6addr_any</code> (IPv6); this causes a subsequent call to <code>bind()</code> to auto-fill the IP address of the <code>struct sockaddr</code> with the address of the current host. That’s excellent for setting up a server when you don’t want to hardcode the address.</p><p>If you do use the <code>AI_PASSIVE</code>, flag, then you can pass <code>NULL</code> in the <code>nodename</code> (since <code>bind()</code> will fill it in for you later).</p><p>Continuing on with the input parameters, you’ll likely want to set <code>ai_family</code> to <code>AF_UNSPEC</code> which tells <code>getaddrinfo()</code> to look for both IPv4 and IPv6 addresses. You can also restrict yourself to one or the other with <code>AF_INET</code> or <code>AF_INET6</code>.</p><p>Next, the <code>socktype</code> field should be set to <code>SOCK_STREAM</code> or <code>SOCK_DGRAM</code>, depending on which type of socket you want.</p><p>Finally, just leave <code>ai_protocol</code> at <code>0</code> to automatically choose your protocol type.</p><p>Now, after you get all that stuff in there, you can <em>finally</em> make the call to <code>getaddrinfo()</code>!</p><p>Of course, this is where the fun begins. The <code>res</code> will now point to a linked list of <code>struct addrinfo</code>s, and you can go through this list to get all the addresses that match what you passed in with the hints.</p><p>Now, it’s possible to get some addresses that don’t work for one reason or another, so what the Linux man page does is loops through the list doing a call to <code>socket()</code> and <code>connect()</code> (or <code>bind()</code> if you’re setting up a server with the <code>AI_PASSIVE</code> flag) until it succeeds.</p><p>Finally, when you’re done with the linked list, you need to call <code>freeaddrinfo()</code> to free up the memory (or it will be leaked, and Some People will get upset).</p><h3 id="return-value-4" class="unnumbered unlisted">Return Value</h3><p>Returns zero on success, or nonzero on error. If it returns nonzero, you can use the function <code>gai_strerror()</code> to get a printable version of the error code in the return value.</p><h3 id="example-4" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb91"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb91-1" title="1"><span class="co">// code for a client connecting to a server</span></a>
<a class="sourceLine" id="cb91-2" title="2"><span class="co">// namely a stream socket to www.example.com on port 80 (http)</span></a>
<a class="sourceLine" id="cb91-3" title="3"><span class="co">// either IPv4 or IPv6</span></a>
<a class="sourceLine" id="cb91-4" title="4"></a>
<a class="sourceLine" id="cb91-5" title="5"><span class="dt">int</span> sockfd;  </a>
<a class="sourceLine" id="cb91-6" title="6"><span class="kw">struct</span> addrinfo hints, *servinfo, *p;</a>
<a class="sourceLine" id="cb91-7" title="7"><span class="dt">int</span> rv;</a>
<a class="sourceLine" id="cb91-8" title="8"></a>
<a class="sourceLine" id="cb91-9" title="9">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb91-10" title="10">hints.ai_family = AF_UNSPEC; <span class="co">// use AF_INET6 to force IPv6</span></a>
<a class="sourceLine" id="cb91-11" title="11">hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb91-12" title="12"></a>
<a class="sourceLine" id="cb91-13" title="13"><span class="cf">if</span> ((rv = getaddrinfo(<span class="st">&quot;www.example.com&quot;</span>, <span class="st">&quot;http&quot;</span>, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb91-14" title="14">    fprintf(stderr, <span class="st">&quot;getaddrinfo: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(rv));</a>
<a class="sourceLine" id="cb91-15" title="15">    exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb91-16" title="16">}</a>
<a class="sourceLine" id="cb91-17" title="17"></a>
<a class="sourceLine" id="cb91-18" title="18"><span class="co">// loop through all the results and connect to the first we can</span></a>
<a class="sourceLine" id="cb91-19" title="19"><span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb91-20" title="20">    <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</a>
<a class="sourceLine" id="cb91-21" title="21">            p-&gt;ai_protocol)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb91-22" title="22">        perror(<span class="st">&quot;socket&quot;</span>);</a>
<a class="sourceLine" id="cb91-23" title="23">        <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb91-24" title="24">    }</a>
<a class="sourceLine" id="cb91-25" title="25"></a>
<a class="sourceLine" id="cb91-26" title="26">    <span class="cf">if</span> (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb91-27" title="27">        perror(<span class="st">&quot;connect&quot;</span>);</a>
<a class="sourceLine" id="cb91-28" title="28">        close(sockfd);</a>
<a class="sourceLine" id="cb91-29" title="29">        <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb91-30" title="30">    }</a>
<a class="sourceLine" id="cb91-31" title="31"></a>
<a class="sourceLine" id="cb91-32" title="32">    <span class="cf">break</span>; <span class="co">// if we get here, we must have connected successfully</span></a>
<a class="sourceLine" id="cb91-33" title="33">}</a>
<a class="sourceLine" id="cb91-34" title="34"></a>
<a class="sourceLine" id="cb91-35" title="35"><span class="cf">if</span> (p == NULL) {</a>
<a class="sourceLine" id="cb91-36" title="36">    <span class="co">// looped off the end of the list with no connection</span></a>
<a class="sourceLine" id="cb91-37" title="37">    fprintf(stderr, <span class="st">&quot;failed to connect</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb91-38" title="38">    exit(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb91-39" title="39">}</a>
<a class="sourceLine" id="cb91-40" title="40"></a>
<a class="sourceLine" id="cb91-41" title="41">freeaddrinfo(servinfo); <span class="co">// all done with this structure</span></a></code></pre></div><div class="sourceCode" id="cb92"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb92-1" title="1"><span class="co">// code for a server waiting for connections</span></a>
<a class="sourceLine" id="cb92-2" title="2"><span class="co">// namely a stream socket on port 3490, on this host&#39;s IP</span></a>
<a class="sourceLine" id="cb92-3" title="3"><span class="co">// either IPv4 or IPv6.</span></a>
<a class="sourceLine" id="cb92-4" title="4"></a>
<a class="sourceLine" id="cb92-5" title="5"><span class="dt">int</span> sockfd;  </a>
<a class="sourceLine" id="cb92-6" title="6"><span class="kw">struct</span> addrinfo hints, *servinfo, *p;</a>
<a class="sourceLine" id="cb92-7" title="7"><span class="dt">int</span> rv;</a>
<a class="sourceLine" id="cb92-8" title="8"></a>
<a class="sourceLine" id="cb92-9" title="9">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb92-10" title="10">hints.ai_family = AF_UNSPEC; <span class="co">// use AF_INET6 to force IPv6</span></a>
<a class="sourceLine" id="cb92-11" title="11">hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb92-12" title="12">hints.ai_flags = AI_PASSIVE; <span class="co">// use my IP address</span></a>
<a class="sourceLine" id="cb92-13" title="13"></a>
<a class="sourceLine" id="cb92-14" title="14"><span class="cf">if</span> ((rv = getaddrinfo(NULL, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb92-15" title="15">    fprintf(stderr, <span class="st">&quot;getaddrinfo: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, gai_strerror(rv));</a>
<a class="sourceLine" id="cb92-16" title="16">    exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb92-17" title="17">}</a>
<a class="sourceLine" id="cb92-18" title="18"></a>
<a class="sourceLine" id="cb92-19" title="19"><span class="co">// loop through all the results and bind to the first we can</span></a>
<a class="sourceLine" id="cb92-20" title="20"><span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</a>
<a class="sourceLine" id="cb92-21" title="21">    <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</a>
<a class="sourceLine" id="cb92-22" title="22">            p-&gt;ai_protocol)) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb92-23" title="23">        perror(<span class="st">&quot;socket&quot;</span>);</a>
<a class="sourceLine" id="cb92-24" title="24">        <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb92-25" title="25">    }</a>
<a class="sourceLine" id="cb92-26" title="26"></a>
<a class="sourceLine" id="cb92-27" title="27">    <span class="cf">if</span> (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb92-28" title="28">        close(sockfd);</a>
<a class="sourceLine" id="cb92-29" title="29">        perror(<span class="st">&quot;bind&quot;</span>);</a>
<a class="sourceLine" id="cb92-30" title="30">        <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb92-31" title="31">    }</a>
<a class="sourceLine" id="cb92-32" title="32"></a>
<a class="sourceLine" id="cb92-33" title="33">    <span class="cf">break</span>; <span class="co">// if we get here, we must have connected successfully</span></a>
<a class="sourceLine" id="cb92-34" title="34">}</a>
<a class="sourceLine" id="cb92-35" title="35"></a>
<a class="sourceLine" id="cb92-36" title="36"><span class="cf">if</span> (p == NULL) {</a>
<a class="sourceLine" id="cb92-37" title="37">    <span class="co">// looped off the end of the list with no successful bind</span></a>
<a class="sourceLine" id="cb92-38" title="38">    fprintf(stderr, <span class="st">&quot;failed to bind socket</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb92-39" title="39">    exit(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb92-40" title="40">}</a>
<a class="sourceLine" id="cb92-41" title="41"></a>
<a class="sourceLine" id="cb92-42" title="42">freeaddrinfo(servinfo); <span class="co">// all done with this structure</span></a></code></pre></div><h3 id="see-also-4" class="unnumbered unlisted">See Also</h3><p><a href="#gethostbynameman"><code>gethostbyname()</code></a>, <a href="#getnameinfoman"><code>getnameinfo()</code></a></p><h2 id="gethostnameman"><span class="header-section-number">9.6</span> <code>gethostname()</code></h2><p></p><p>Returns the name of the system</p><h3 id="synopsis-5" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb93"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb93-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/unistd.h&gt;</span></a>
<a class="sourceLine" id="cb93-2" title="2"></a>
<a class="sourceLine" id="cb93-3" title="3"><span class="dt">int</span> gethostname(<span class="dt">char</span> *name, <span class="dt">size_t</span> len);</a></code></pre></div><h3 id="description-5" class="unnumbered unlisted">Description</h3><p>Your system has a name. They all do. This is a slightly more Unixy thing than the rest of the networky stuff we’ve been talking about, but it still has its uses.</p><p>For instance, you can get your host name, and then call  <code>gethostbyname()</code> to find out your IP address.</p><p>The parameter <code>name</code> should point to a buffer that will hold the host name, and <code>len</code> is the size of that buffer in bytes. <code>gethostname()</code> won’t overwrite the end of the buffer (it might return an error, or it might just stop writing), and it will <code>NUL</code>-terminate the string if there’s room for it in the buffer.</p><h3 id="return-value-5" class="unnumbered unlisted">Return Value</h3><p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p><h3 id="example-5" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb94"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb94-1" title="1"><span class="dt">char</span> hostname[<span class="dv">128</span>];</a>
<a class="sourceLine" id="cb94-2" title="2"></a>
<a class="sourceLine" id="cb94-3" title="3">gethostname(hostname, <span class="kw">sizeof</span> hostname);</a>
<a class="sourceLine" id="cb94-4" title="4">printf(<span class="st">&quot;My hostname: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, hostname);</a></code></pre></div><h3 id="see-also-5" class="unnumbered unlisted">See Also</h3><p><a href="#gethostbynameman"><code>gethostbyname()</code></a></p><h2 id="gethostbynameman"><span class="header-section-number">9.7</span> <code>gethostbyname()</code>, <code>gethostbyaddr()</code></h2><p> </p><p>Get an IP address for a hostname, or vice-versa</p><h3 id="synopsis-6" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb95"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb95-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb95-2" title="2"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb95-3" title="3"></a>
<a class="sourceLine" id="cb95-4" title="4"><span class="kw">struct</span> hostent *gethostbyname(<span class="dt">const</span> <span class="dt">char</span> *name); <span class="co">// </span><span class="al">DEPRECATED</span><span class="co">!</span></a>
<a class="sourceLine" id="cb95-5" title="5"><span class="kw">struct</span> hostent *gethostbyaddr(<span class="dt">const</span> <span class="dt">char</span> *addr, <span class="dt">int</span> len, <span class="dt">int</span> type);</a></code></pre></div><h3 id="description-6" class="unnumbered unlisted">Description</h3><p><em>PLEASE NOTE: these two functions are superseded by <code>getaddrinfo()</code> and <code>getnameinfo()</code>!</em> In particular, <code>gethostbyname()</code> doesn’t work well with IPv6.</p><p>These functions map back and forth between host names and IP addresses. For instance, if you have “www.example.com”, you can use <code>gethostbyname()</code> to get its IP address and store it in a <code>struct in_addr</code>.</p><p>Conversely, if you have a <code>struct in_addr</code> or a <code>struct in6_addr</code>, you can use <code>gethostbyaddr()</code> to get the hostname back. <code>gethostbyaddr()</code> <em>is</em> IPv6 compatible, but you should use the newer shinier <code>getnameinfo()</code> instead.</p><p>(If you have a string containing an IP address in dots-and-numbers format that you want to look up the hostname of, you’d be better off using <code>getaddrinfo()</code> with the <code>AI_CANONNAME</code> flag.)</p><p><code>gethostbyname()</code> takes a string like “www.yahoo.com”, and returns a <code>struct hostent</code> which contains tons of information, including the IP address. (Other information is the official host name, a list of aliases, the address type, the length of the addresses, and the list of addresses—it’s a general-purpose structure that’s pretty easy to use for our specific purposes once you see how.)</p><p><code>gethostbyaddr()</code> takes a <code>struct in_addr</code> or <code>struct in6_addr</code> and brings you up a corresponding host name (if there is one), so it’s sort of the reverse of <code>gethostbyname()</code>. As for parameters, even though <code>addr</code> is a <code>char*</code>, you actually want to pass in a pointer to a <code>struct in_addr</code>. <code>len</code> should be <code>sizeof(struct in_addr)</code>, and <code>type</code> should be <code>AF_INET</code>.</p><p>So what is this  <code>struct hostent</code> that gets returned? It has a number of fields that contain information about the host in question.</p><table><colgroup><col style="width: 30%" /><col style="width: 69%" /></colgroup><thead><tr class="header"><th>Field</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>char *h_name</code></td><td>The real canonical host name.</td></tr><tr class="even"><td><code>char **h_aliases</code></td><td>A list of aliases that can be accessed with arrays—the last element is <code>NULL</code></td></tr><tr class="odd"><td><code>int h_addrtype</code></td><td>The result’s address type, which really should be <code>AF_INET</code> for our purposes.</td></tr><tr class="even"><td><code>int length</code></td><td>The length of the addresses in bytes, which is 4 for IP (version 4) addresses.</td></tr><tr class="odd"><td><code>char **h_addr_list</code></td><td>A list of IP addresses for this host. Although this is a <code>char**</code>, it’s really an array of <code>struct in_addr*</code>s in disguise. The last array element is <code>NULL</code>.</td></tr><tr class="even"><td><code>h_addr</code></td><td>A commonly defined alias for <code>h_addr_list[0]</code>. If you just want any old IP address for this host (yeah, they can have more than one) just use this field.</td></tr></tbody></table><h3 id="return-value-6" class="unnumbered unlisted">Return Value</h3><p>Returns a pointer to a resultant <code>struct hostent</code> on success, or <code>NULL</code> on error.</p><p>Instead of the normal <code>perror()</code> and all that stuff you’d normally use for error reporting, these functions have parallel results in the variable <code>h_errno</code>, which can be printed using the functions  <code>herror()</code> or  <code>hstrerror()</code>. These work just like the classic <code>errno</code>, <code>perror()</code>, and <code>strerror()</code> functions you’re used to.</p><h3 id="example-6" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb96"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb96-1" title="1"><span class="co">// THIS IS A </span><span class="al">DEPRECATED</span><span class="co"> METHOD OF GETTING HOST NAMES</span></a>
<a class="sourceLine" id="cb96-2" title="2"><span class="co">// use getaddrinfo() instead!</span></a>
<a class="sourceLine" id="cb96-3" title="3"></a>
<a class="sourceLine" id="cb96-4" title="4"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb96-5" title="5"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb96-6" title="6"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb96-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb96-8" title="8"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb96-9" title="9"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb96-10" title="10"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb96-11" title="11"></a>
<a class="sourceLine" id="cb96-12" title="12"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb96-13" title="13">{</a>
<a class="sourceLine" id="cb96-14" title="14">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb96-15" title="15">    <span class="kw">struct</span> hostent *he;</a>
<a class="sourceLine" id="cb96-16" title="16">    <span class="kw">struct</span> in_addr **addr_list;</a>
<a class="sourceLine" id="cb96-17" title="17"></a>
<a class="sourceLine" id="cb96-18" title="18">    <span class="cf">if</span> (argc != <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb96-19" title="19">        fprintf(stderr,<span class="st">&quot;usage: ghbn hostname</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb96-20" title="20">        <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb96-21" title="21">    }</a>
<a class="sourceLine" id="cb96-22" title="22"></a>
<a class="sourceLine" id="cb96-23" title="23">    <span class="cf">if</span> ((he = gethostbyname(argv[<span class="dv">1</span>])) == NULL) {  <span class="co">// get the host info</span></a>
<a class="sourceLine" id="cb96-24" title="24">        herror(<span class="st">&quot;gethostbyname&quot;</span>);</a>
<a class="sourceLine" id="cb96-25" title="25">        <span class="cf">return</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb96-26" title="26">    }</a>
<a class="sourceLine" id="cb96-27" title="27"></a>
<a class="sourceLine" id="cb96-28" title="28">    <span class="co">// print information about this host:</span></a>
<a class="sourceLine" id="cb96-29" title="29">    printf(<span class="st">&quot;Official name is: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, he-&gt;h_name);</a>
<a class="sourceLine" id="cb96-30" title="30">    printf(<span class="st">&quot;    IP addresses: &quot;</span>);</a>
<a class="sourceLine" id="cb96-31" title="31">    addr_list = (<span class="kw">struct</span> in_addr **)he-&gt;h_addr_list;</a>
<a class="sourceLine" id="cb96-32" title="32">    <span class="cf">for</span>(i = <span class="dv">0</span>; addr_list[i] != NULL; i++) {</a>
<a class="sourceLine" id="cb96-33" title="33">        printf(<span class="st">&quot;%s &quot;</span>, inet_ntoa(*addr_list[i]));</a>
<a class="sourceLine" id="cb96-34" title="34">    }</a>
<a class="sourceLine" id="cb96-35" title="35">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb96-36" title="36"></a>
<a class="sourceLine" id="cb96-37" title="37">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb96-38" title="38">}</a></code></pre></div><div class="sourceCode" id="cb97"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb97-1" title="1"><span class="co">// THIS HAS BEEN SUPERSEDED</span></a>
<a class="sourceLine" id="cb97-2" title="2"><span class="co">// use getnameinfo() instead!</span></a>
<a class="sourceLine" id="cb97-3" title="3"></a>
<a class="sourceLine" id="cb97-4" title="4"><span class="kw">struct</span> hostent *he;</a>
<a class="sourceLine" id="cb97-5" title="5"><span class="kw">struct</span> in_addr ipv4addr;</a>
<a class="sourceLine" id="cb97-6" title="6"><span class="kw">struct</span> in6_addr ipv6addr;</a>
<a class="sourceLine" id="cb97-7" title="7"></a>
<a class="sourceLine" id="cb97-8" title="8">inet_pton(AF_INET, <span class="st">&quot;192.0.2.34&quot;</span>, &amp;ipv4addr);</a>
<a class="sourceLine" id="cb97-9" title="9">he = gethostbyaddr(&amp;ipv4addr, <span class="kw">sizeof</span> ipv4addr, AF_INET);</a>
<a class="sourceLine" id="cb97-10" title="10">printf(<span class="st">&quot;Host name: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, he-&gt;h_name);</a>
<a class="sourceLine" id="cb97-11" title="11"></a>
<a class="sourceLine" id="cb97-12" title="12">inet_pton(AF_INET6, <span class="st">&quot;2001:db8:63b3:1::beef&quot;</span>, &amp;ipv6addr);</a>
<a class="sourceLine" id="cb97-13" title="13">he = gethostbyaddr(&amp;ipv6addr, <span class="kw">sizeof</span> ipv6addr, AF_INET6);</a>
<a class="sourceLine" id="cb97-14" title="14">printf(<span class="st">&quot;Host name: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, he-&gt;h_name);</a></code></pre></div><h3 id="see-also-6" class="unnumbered unlisted">See Also</h3><p><a href="#getaddrinfoman"><code>getaddrinfo()</code></a>, <a href="#getnameinfoman"><code>getnameinfo()</code></a>, <a href="#gethostnameman"><code>gethostname()</code></a>, <a href="#errnoman"><code>errno</code></a>, <a href="#perrorman"><code>perror()</code></a>, <a href="#perrorman"><code>strerror()</code></a>, <a href="#structsockaddrman"><code>struct in_addr</code></a></p><h2 id="getnameinfoman"><span class="header-section-number">9.8</span> <code>getnameinfo()</code></h2><p></p><p>Look up the host name and service name information for a given <code>struct sockaddr</code>.</p><h3 id="synopsis-7" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb98"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb98-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb98-2" title="2"><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb98-3" title="3"></a>
<a class="sourceLine" id="cb98-4" title="4"><span class="dt">int</span> getnameinfo(<span class="dt">const</span> <span class="kw">struct</span> sockaddr *sa, socklen_t salen,</a>
<a class="sourceLine" id="cb98-5" title="5">                <span class="dt">char</span> *host, <span class="dt">size_t</span> hostlen,</a>
<a class="sourceLine" id="cb98-6" title="6">                <span class="dt">char</span> *serv, <span class="dt">size_t</span> servlen, <span class="dt">int</span> flags);</a></code></pre></div><h3 id="description-7" class="unnumbered unlisted">Description</h3><p>This function is the opposite of <code>getaddrinfo()</code>, that is, this function takes an already loaded <code>struct sockaddr</code> and does a name and service name lookup on it. It replaces the old <code>gethostbyaddr()</code> and <code>getservbyport()</code> functions.</p><p>You have to pass in a pointer to a <code>struct sockaddr</code> (which in actuality is probably a <code>struct sockaddr_in</code> or <code>struct sockaddr_in6</code> that you’ve cast) in the <code>sa</code> parameter, and the length of that <code>struct</code> in the <code>salen</code>.</p><p>The resultant host name and service name will be written to the area pointed to by the <code>host</code> and <code>serv</code> parameters. Of course, you have to specify the max lengths of these buffers in <code>hostlen</code> and <code>servlen</code>.</p><p>Finally, there are several flags you can pass, but here a a couple good ones. <code>NI_NOFQDN</code> will cause the <code>host</code> to only contain the host name, not the whole domain name. <code>NI_NAMEREQD</code> will cause the function to fail if the name cannot be found with a DNS lookup (if you don’t specify this flag and the name can’t be found, <code>getnameinfo()</code> will put a string version of the IP address in <code>host</code> instead).</p><p>As always, check your local man pages for the full scoop.</p><h3 id="return-value-7" class="unnumbered unlisted">Return Value</h3><p>Returns zero on success, or non-zero on error. If the return value is non-zero, it can be passed to <code>gai_strerror()</code> to get a human-readable string. See <code>getaddrinfo</code> for more information.</p><h3 id="example-7" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb99"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb99-1" title="1"><span class="kw">struct</span> sockaddr_in6 sa; <span class="co">// could be IPv4 if you want</span></a>
<a class="sourceLine" id="cb99-2" title="2"><span class="dt">char</span> host[<span class="dv">1024</span>];</a>
<a class="sourceLine" id="cb99-3" title="3"><span class="dt">char</span> service[<span class="dv">20</span>];</a>
<a class="sourceLine" id="cb99-4" title="4"></a>
<a class="sourceLine" id="cb99-5" title="5"><span class="co">// pretend sa is full of good information about the host and port...</span></a>
<a class="sourceLine" id="cb99-6" title="6"></a>
<a class="sourceLine" id="cb99-7" title="7">getnameinfo(&amp;sa, <span class="kw">sizeof</span> sa, host, <span class="kw">sizeof</span> host, service, <span class="kw">sizeof</span> service, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb99-8" title="8"></a>
<a class="sourceLine" id="cb99-9" title="9">printf(<span class="st">&quot;   host: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, host);    <span class="co">// e.g. &quot;www.example.com&quot;</span></a>
<a class="sourceLine" id="cb99-10" title="10">printf(<span class="st">&quot;service: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, service); <span class="co">// e.g. &quot;http&quot;</span></a></code></pre></div><h3 id="see-also-7" class="unnumbered unlisted">See Also</h3><p><a href="#getaddrinfoman"><code>getaddrinfo()</code></a>, <a href="#gethostbynameman"><code>gethostbyaddr()</code></a></p><h2 id="getpeernameman"><span class="header-section-number">9.9</span> <code>getpeername()</code></h2><p></p><p>Return address info about the remote side of the connection</p><h3 id="synopsis-8" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb100"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb100-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb100-2" title="2"></a>
<a class="sourceLine" id="cb100-3" title="3"><span class="dt">int</span> getpeername(<span class="dt">int</span> s, <span class="kw">struct</span> sockaddr *addr, socklen_t *len);</a></code></pre></div><h3 id="description-8" class="unnumbered unlisted">Description</h3><p>Once you have either <code>accept()</code>ed a remote connection, or <code>connect()</code>ed to a server, you now have what is known as a <em>peer</em>. Your peer is simply the computer you’re connected to, identified by an IP address and a port. So…</p><p><code>getpeername()</code> simply returns a <code>struct sockaddr_in</code> filled with information about the machine you’re connected to.</p><p>Why is it called a “name”? Well, there are a lot of different kinds of sockets, not just Internet Sockets like we’re using in this guide, and so “name” was a nice generic term that covered all cases. In our case, though, the peer’s “name” is it’s IP address and port.</p><p>Although the function returns the size of the resultant address in <code>len</code>, you must preload <code>len</code> with the size of <code>addr</code>.</p><h3 id="return-value-8" class="unnumbered unlisted">Return Value</h3><p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p><h3 id="example-8" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb101"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb101-1" title="1"><span class="co">// assume s is a connected socket</span></a>
<a class="sourceLine" id="cb101-2" title="2"></a>
<a class="sourceLine" id="cb101-3" title="3">socklen_t len;</a>
<a class="sourceLine" id="cb101-4" title="4"><span class="kw">struct</span> sockaddr_storage addr;</a>
<a class="sourceLine" id="cb101-5" title="5"><span class="dt">char</span> ipstr[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb101-6" title="6"><span class="dt">int</span> port;</a>
<a class="sourceLine" id="cb101-7" title="7"></a>
<a class="sourceLine" id="cb101-8" title="8">len = <span class="kw">sizeof</span> addr;</a>
<a class="sourceLine" id="cb101-9" title="9">getpeername(s, (<span class="kw">struct</span> sockaddr*)&amp;addr, &amp;len);</a>
<a class="sourceLine" id="cb101-10" title="10"></a>
<a class="sourceLine" id="cb101-11" title="11"><span class="co">// deal with both IPv4 and IPv6:</span></a>
<a class="sourceLine" id="cb101-12" title="12"><span class="cf">if</span> (addr.ss_family == AF_INET) {</a>
<a class="sourceLine" id="cb101-13" title="13">    <span class="kw">struct</span> sockaddr_in *s = (<span class="kw">struct</span> sockaddr_in *)&amp;addr;</a>
<a class="sourceLine" id="cb101-14" title="14">    port = ntohs(s-&gt;sin_port);</a>
<a class="sourceLine" id="cb101-15" title="15">    inet_ntop(AF_INET, &amp;s-&gt;sin_addr, ipstr, <span class="kw">sizeof</span> ipstr);</a>
<a class="sourceLine" id="cb101-16" title="16">} <span class="cf">else</span> { <span class="co">// AF_INET6</span></a>
<a class="sourceLine" id="cb101-17" title="17">    <span class="kw">struct</span> sockaddr_in6 *s = (<span class="kw">struct</span> sockaddr_in6 *)&amp;addr;</a>
<a class="sourceLine" id="cb101-18" title="18">    port = ntohs(s-&gt;sin6_port);</a>
<a class="sourceLine" id="cb101-19" title="19">    inet_ntop(AF_INET6, &amp;s-&gt;sin6_addr, ipstr, <span class="kw">sizeof</span> ipstr);</a>
<a class="sourceLine" id="cb101-20" title="20">}</a>
<a class="sourceLine" id="cb101-21" title="21"></a>
<a class="sourceLine" id="cb101-22" title="22">printf(<span class="st">&quot;Peer IP address: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, ipstr);</a>
<a class="sourceLine" id="cb101-23" title="23">printf(<span class="st">&quot;Peer port      : %d</span><span class="sc">\n</span><span class="st">&quot;</span>, port);</a></code></pre></div><h3 id="see-also-8" class="unnumbered unlisted">See Also</h3><p><a href="#gethostnameman"><code>gethostname()</code></a>, <a href="#gethostbynameman"><code>gethostbyname()</code></a>, <a href="#gethostbynameman"><code>gethostbyaddr()</code></a></p><h2 id="errnoman"><span class="header-section-number">9.10</span> <code>errno</code></h2><p></p><p>Holds the error code for the last system call</p><h3 id="synopsis-9" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb102"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb102-1" title="1"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb102-2" title="2"></a>
<a class="sourceLine" id="cb102-3" title="3"><span class="dt">int</span> errno;</a></code></pre></div><h3 id="description-9" class="unnumbered unlisted">Description</h3><p>This is the variable that holds error information for a lot of system calls. If you’ll recall, things like <code>socket()</code> and <code>listen()</code> return <code>-1</code> on error, and they set the exact value of <code>errno</code> to let you know specifically which error occurred.</p><p>The header file <code>errno.h</code> lists a bunch of constant symbolic names for errors, such as <code>EADDRINUSE</code>, <code>EPIPE</code>, <code>ECONNREFUSED</code>, etc. Your local man pages will tell you what codes can be returned as an error, and you can use these at run time to handle different errors in different ways.</p><p>Or, more commonly, you can call  <code>perror()</code> or  <code>strerror()</code> to get a human-readable version of the error.</p><p>One thing to note, for you multithreading enthusiasts, is that on most systems <code>errno</code> is defined in a threadsafe manner. (That is, it’s not actually a global variable, but it behaves just like a global variable would in a single-threaded environment.)</p><h3 id="return-value-9" class="unnumbered unlisted">Return Value</h3><p>The value of the variable is the latest error to have transpired, which might be the code for “success” if the last action succeeded.</p><h3 id="example-9" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb103"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb103-1" title="1">s = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb103-2" title="2"><span class="cf">if</span> (s == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb103-3" title="3">    perror(<span class="st">&quot;socket&quot;</span>); <span class="co">// or use strerror()</span></a>
<a class="sourceLine" id="cb103-4" title="4">}</a>
<a class="sourceLine" id="cb103-5" title="5"></a>
<a class="sourceLine" id="cb103-6" title="6">tryagain:</a>
<a class="sourceLine" id="cb103-7" title="7"><span class="cf">if</span> (select(n, &amp;readfds, NULL, NULL) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb103-8" title="8">    <span class="co">// an error has occurred!!</span></a>
<a class="sourceLine" id="cb103-9" title="9"></a>
<a class="sourceLine" id="cb103-10" title="10">    <span class="co">// if we were only interrupted, just restart the select() call:</span></a>
<a class="sourceLine" id="cb103-11" title="11">    <span class="cf">if</span> (errno == EINTR) <span class="cf">goto</span> tryagain;  <span class="co">// AAAA! goto!!!</span></a>
<a class="sourceLine" id="cb103-12" title="12"></a>
<a class="sourceLine" id="cb103-13" title="13">    <span class="co">// otherwise it&#39;s a more serious error:</span></a>
<a class="sourceLine" id="cb103-14" title="14">    perror(<span class="st">&quot;select&quot;</span>);</a>
<a class="sourceLine" id="cb103-15" title="15">    exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb103-16" title="16">}</a></code></pre></div><h3 id="see-also-9" class="unnumbered unlisted">See Also</h3><p><a href="#perrorman"><code>perror()</code></a>, <a href="#perrorman"><code>strerror()</code></a></p><h2 id="fcntlman"><span class="header-section-number">9.11</span> <code>fcntl()</code></h2><p></p><p>Control socket descriptors</p><h3 id="synopsis-10" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb104"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb104-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/unistd.h&gt;</span></a>
<a class="sourceLine" id="cb104-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb104-3" title="3"></a>
<a class="sourceLine" id="cb104-4" title="4"><span class="dt">int</span> fcntl(<span class="dt">int</span> s, <span class="dt">int</span> cmd, <span class="dt">long</span> arg);</a></code></pre></div><h3 id="description-10" class="unnumbered unlisted">Description</h3><p>This function is typically used to do file locking and other file-oriented stuff, but it also has a couple socket-related functions that you might see or use from time to time.</p><p>Parameter <code>s</code> is the socket descriptor you wish to operate on, <code>cmd</code> should be set to  <code>F_SETFL</code>, and <code>arg</code> can be one of the following commands. (Like I said, there’s more to <code>fcntl()</code> than I’m letting on here, but I’m trying to stay socket-oriented.)</p><table><colgroup><col style="width: 18%" /><col style="width: 81%" /></colgroup><thead><tr class="header"><th><code>cmd</code></th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>O_NONBLOCK</code></td><td>Set the socket to be non-blocking. See the section on <a href="#blocking">blocking</a> for more details.</td></tr><tr class="even"><td><code>O_ASYNC</code></td><td>Set the socket to do asynchronous I/O. When data is ready to be <code>recv()</code>’d on the socket, the signal  <code>SIGIO</code> will be raised. This is rare to see, and beyond the scope of the guide. And I think it’s only available on certain systems.</td></tr></tbody></table><h3 id="return-value-10" class="unnumbered unlisted">Return Value</h3><p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p><p>Different uses of the <code>fcntl()</code> system call actually have different return values, but I haven’t covered them here because they’re not socket-related. See your local <code>fcntl()</code> man page for more information.</p><h3 id="example-10" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb105"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb105-1" title="1"><span class="dt">int</span> s = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb105-2" title="2"></a>
<a class="sourceLine" id="cb105-3" title="3">fcntl(s, F_SETFL, O_NONBLOCK);  <span class="co">// set to non-blocking</span></a>
<a class="sourceLine" id="cb105-4" title="4">fcntl(s, F_SETFL, O_ASYNC);     <span class="co">// set to asynchronous I/O</span></a></code></pre></div><h3 id="see-also-10" class="unnumbered unlisted">See Also</h3><p><a href="#blocking">Blocking</a>, <a href="#sendman"><code>send()</code></a></p><h2 id="htonsman"><span class="header-section-number">9.12</span> <code>htons()</code>, <code>htonl()</code>, <code>ntohs()</code>, <code>ntohl()</code></h2><p>   </p><p>Convert multi-byte integer types from host byte order to network byte order</p><h3 id="synopsis-11" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb106"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb106-1" title="1"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb106-2" title="2"></a>
<a class="sourceLine" id="cb106-3" title="3"><span class="dt">uint32_t</span> htonl(<span class="dt">uint32_t</span> hostlong);</a>
<a class="sourceLine" id="cb106-4" title="4"><span class="dt">uint16_t</span> htons(<span class="dt">uint16_t</span> hostshort);</a>
<a class="sourceLine" id="cb106-5" title="5"><span class="dt">uint32_t</span> ntohl(<span class="dt">uint32_t</span> netlong);</a>
<a class="sourceLine" id="cb106-6" title="6"><span class="dt">uint16_t</span> ntohs(<span class="dt">uint16_t</span> netshort);</a></code></pre></div><h3 id="description-11" class="unnumbered unlisted">Description</h3><p>Just to make you really unhappy, different computers use different byte orderings internally for their multibyte integers (i.e. any integer that’s larger than a <code>char</code>). The upshot of this is that if you <code>send()</code> a two-byte <code>short int</code> from an Intel box to a Mac (before they became Intel boxes, too, I mean), what one computer thinks is the number <code>1</code>, the other will think is the number <code>256</code>, and vice-versa.</p><p> The way to get around this problem is for everyone to put aside their differences and agree that Motorola and IBM had it right, and Intel did it the weird way, and so we all convert our byte orderings to “big-endian” before sending them out. Since Intel is a “little-endian” machine, it’s far more politically correct to call our preferred byte ordering “Network Byte Order”. So these functions convert from your native byte order to network byte order and back again.</p><p>(This means on Intel these functions swap all the bytes around, and on PowerPC they do nothing because the bytes are already in Network Byte Order. But you should always use them in your code anyway, since someone might want to build it on an Intel machine and still have things work properly.)</p><p>Note that the types involved are 32-bit (4 byte, probably <code>int</code>) and 16-bit (2 byte, very likely <code>short</code>) numbers. 64-bit machines might have a <code>htonll()</code> for 64-bit <code>int</code>s, but I’ve not seen it. You’ll just have to write your own.</p><p>Anyway, the way these functions work is that you first decide if you’re converting <em>from</em> host (your machine’s) byte order or from network byte order. If “host”, the the first letter of the function you’re going to call is “h”. Otherwise it’s “n” for “network”. The middle of the function name is always “to” because you’re converting from one “to” another, and the penultimate letter shows what you’re converting <em>to</em>. The last letter is the size of the data, “s” for short, or “l” for long. Thus:</p><table><thead><tr class="header"><th>Function</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>htons()</code></td><td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>s</code>hort</td></tr><tr class="even"><td><code>htonl()</code></td><td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>l</code>ong</td></tr><tr class="odd"><td><code>ntohs()</code></td><td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>s</code>hort</td></tr><tr class="even"><td><code>ntohl()</code></td><td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>l</code>ong</td></tr></tbody></table><h3 id="return-value-11" class="unnumbered unlisted">Return Value</h3><p>Each function returns the converted value.</p><h3 id="example-11" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb107"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb107-1" title="1"><span class="dt">uint32_t</span> some_long = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb107-2" title="2"><span class="dt">uint16_t</span> some_short = <span class="dv">20</span>;</a>
<a class="sourceLine" id="cb107-3" title="3"></a>
<a class="sourceLine" id="cb107-4" title="4"><span class="dt">uint32_t</span> network_byte_order;</a>
<a class="sourceLine" id="cb107-5" title="5"></a>
<a class="sourceLine" id="cb107-6" title="6"><span class="co">// convert and send</span></a>
<a class="sourceLine" id="cb107-7" title="7">network_byte_order = htonl(some_long);</a>
<a class="sourceLine" id="cb107-8" title="8">send(s, &amp;network_byte_order, <span class="kw">sizeof</span>(<span class="dt">uint32_t</span>), <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb107-9" title="9"></a>
<a class="sourceLine" id="cb107-10" title="10">some_short == ntohs(htons(some_short)); <span class="co">// this expression is true</span></a></code></pre></div><h2 id="inet_ntoaman"><span class="header-section-number">9.13</span> <code>inet_ntoa()</code>, <code>inet_aton()</code>, <code>inet_addr</code></h2><p>  </p><p>Convert IP addresses from a dots-and-number string to a <code>struct in_addr</code> and back</p><h3 id="synopsis-12" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb108"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb108-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb108-2" title="2"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb108-3" title="3"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb108-4" title="4"></a>
<a class="sourceLine" id="cb108-5" title="5"><span class="co">// ALL THESE ARE </span><span class="al">DEPRECATED</span><span class="co">! Use inet_pton()  or inet_ntop() instead!!</span></a>
<a class="sourceLine" id="cb108-6" title="6"></a>
<a class="sourceLine" id="cb108-7" title="7"><span class="dt">char</span> *inet_ntoa(<span class="kw">struct</span> in_addr in);</a>
<a class="sourceLine" id="cb108-8" title="8"><span class="dt">int</span> inet_aton(<span class="dt">const</span> <span class="dt">char</span> *cp, <span class="kw">struct</span> in_addr *inp);</a>
<a class="sourceLine" id="cb108-9" title="9">in_addr_t inet_addr(<span class="dt">const</span> <span class="dt">char</span> *cp);</a></code></pre></div><h3 id="description-12" class="unnumbered unlisted">Description</h3><p><em>These functions are deprecated because they don’t handle IPv6! Use (<code>inet_ntop()</code>)[#inet_ntopman] or (<code>inet_pton()</code>)[#inet_ntopman] instead! They are included here because they can still be found in the wild.</em></p><p>All of these functions convert from a <code>struct in_addr</code> (part of your <code>struct sockaddr_in</code>, most likely) to a string in dots-and-numbers format (e.g. “192.168.5.10”) and vice-versa. If you have an IP address passed on the command line or something, this is the easiest way to get a <code>struct in_addr</code> to <code>connect()</code> to, or whatever. If you need more power, try some of the DNS functions like <code>gethostbyname()</code> or attempt a <em>coup d’État</em> in your local country.</p><p>The function <code>inet_ntoa()</code> converts a network address in a <code>struct in_addr</code> to a dots-and-numbers format string. The “n” in “ntoa” stands for network, and the “a” stands for ASCII for historical reasons (so it’s “Network To ASCII”—the “toa” suffix has an analogous friend in the C library called <code>atoi()</code> which converts an ASCII string to an integer).</p><p>The function <code>inet_aton()</code> is the opposite, converting from a dots-and-numbers string into a <code>in_addr_t</code> (which is the type of the field <code>s_addr</code> in your <code>struct in_addr</code>).</p><p>Finally, the function <code>inet_addr()</code> is an older function that does basically the same thing as <code>inet_aton()</code>. It’s theoretically deprecated, but you’ll see it a lot and the police won’t come get you if you use it.</p><h3 id="return-value-12" class="unnumbered unlisted">Return Value</h3><p><code>inet_aton()</code> returns non-zero if the address is a valid one, and it returns zero if the address is invalid.</p><p><code>inet_ntoa()</code> returns the dots-and-numbers string in a static buffer that is overwritten with each call to the function.</p><p><code>inet_addr()</code> returns the address as an <code>in_addr_t</code>, or <code>-1</code> if there’s an error. (That is the same result as if you tried to convert the string  “<code>255.255.255.255</code>”, which is a valid IP address. This is why <code>inet_aton()</code> is better.)</p><h3 id="example-12" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb109"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb109-1" title="1"><span class="kw">struct</span> sockaddr_in antelope;</a>
<a class="sourceLine" id="cb109-2" title="2"><span class="dt">char</span> *some_addr;</a>
<a class="sourceLine" id="cb109-3" title="3"></a>
<a class="sourceLine" id="cb109-4" title="4">inet_aton(<span class="st">&quot;10.0.0.1&quot;</span>, &amp;antelope.sin_addr); <span class="co">// store IP in antelope</span></a>
<a class="sourceLine" id="cb109-5" title="5"></a>
<a class="sourceLine" id="cb109-6" title="6">some_addr = inet_ntoa(antelope.sin_addr); <span class="co">// return the IP</span></a>
<a class="sourceLine" id="cb109-7" title="7">printf(<span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span>, some_addr); <span class="co">// prints &quot;10.0.0.1&quot;</span></a>
<a class="sourceLine" id="cb109-8" title="8"></a>
<a class="sourceLine" id="cb109-9" title="9"><span class="co">// and this call is the same as the inet_aton() call, above:</span></a>
<a class="sourceLine" id="cb109-10" title="10">antelope.sin_addr.s_addr = inet_addr(<span class="st">&quot;10.0.0.1&quot;</span>);</a></code></pre></div><h3 id="see-also-11" class="unnumbered unlisted">See Also</h3><p><a href="#inet_ntopman"><code>inet_ntop()</code></a>, <a href="#inet_ntopman"><code>inet_pton()</code></a>, <a href="#gethostbynameman"><code>gethostbyname()</code></a>, <a href="#gethostbynameman"><code>gethostbyaddr()</code></a></p><h2 id="inet_ntopman"><span class="header-section-number">9.14</span> <code>inet_ntop()</code>, <code>inet_pton()</code></h2><p> </p><p>Convert IP addresses to human-readable form and back.</p><h3 id="synopsis-13" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb110"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb110-1" title="1"><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb110-2" title="2"></a>
<a class="sourceLine" id="cb110-3" title="3"><span class="dt">const</span> <span class="dt">char</span> *inet_ntop(<span class="dt">int</span> af, <span class="dt">const</span> <span class="dt">void</span> *src,</a>
<a class="sourceLine" id="cb110-4" title="4">                      <span class="dt">char</span> *dst, socklen_t size);</a>
<a class="sourceLine" id="cb110-5" title="5"></a>
<a class="sourceLine" id="cb110-6" title="6"><span class="dt">int</span> inet_pton(<span class="dt">int</span> af, <span class="dt">const</span> <span class="dt">char</span> *src, <span class="dt">void</span> *dst);</a></code></pre></div><h3 id="description-13" class="unnumbered unlisted">Description</h3><p>These functions are for dealing with human-readable IP addresses and converting them to their binary representation for use with various functions and system calls. The “n” stands for “network”, and “p” for “presentation”. Or “text presentation”. But you can think of it as “printable”. “ntop” is “network to printable”. See?</p><p>Sometimes you don’t want to look at a pile of binary numbers when looking at an IP address. You want it in a nice printable form, like <code>192.0.2.180</code>, or <code>2001:db8:8714:3a90::12</code>. In that case, <code>inet_ntop()</code> is for you.</p><p><code>inet_ntop()</code> takes the address family in the <code>af</code> parameter (either <code>AF_INET</code> or <code>AF_INET6</code>). The <code>src</code> parameter should be a pointer to either a <code>struct in_addr</code> or <code>struct in6_addr</code> containing the address you wish to convert to a string. Finally <code>dst</code> and <code>size</code> are the pointer to the destination string and the maximum length of that string.</p><p>What should the maximum length of the <code>dst</code> string be? What is the maximum length for IPv4 and IPv6 addresses? Fortunately there are a couple of macros to help you out. The maximum lengths are: <code>INET_ADDRSTRLEN</code> and <code>INET6_ADDRSTRLEN</code>.</p><p>Other times, you might have a string containing an IP address in readable form, and you want to pack it into a <code>struct sockaddr_in</code> or a <code>struct sockaddr_in6</code>. In that case, the opposite function <code>inet_pton()</code> is what you’re after.</p><p><code>inet_pton()</code> also takes an address family (either <code>AF_INET</code> or <code>AF_INET6</code>) in the <code>af</code> parameter. The <code>src</code> parameter is a pointer to a string containing the IP address in printable form. Lastly the <code>dst</code> parameter points to where the result should be stored, which is probably a <code>struct in_addr</code> or <code>struct in6_addr</code>.</p><p>These functions don’t do DNS lookups—you’ll need <code>getaddrinfo()</code> for that.</p><h3 id="return-value-13" class="unnumbered unlisted">Return Value</h3><p><code>inet_ntop()</code> returns the <code>dst</code> parameter on success, or <code>NULL</code> on failure (and <code>errno</code> is set).</p><p><code>inet_pton()</code> returns <code>1</code> on success. It returns <code>-1</code> if there was an error (<code>errno</code> is set), or <code>0</code> if the input isn’t a valid IP address.</p><h3 id="example-13" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb111"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb111-1" title="1"><span class="co">// IPv4 demo of inet_ntop() and inet_pton()</span></a>
<a class="sourceLine" id="cb111-2" title="2"></a>
<a class="sourceLine" id="cb111-3" title="3"><span class="kw">struct</span> sockaddr_in sa;</a>
<a class="sourceLine" id="cb111-4" title="4"><span class="dt">char</span> str[INET_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb111-5" title="5"></a>
<a class="sourceLine" id="cb111-6" title="6"><span class="co">// store this IP address in sa:</span></a>
<a class="sourceLine" id="cb111-7" title="7">inet_pton(AF_INET, <span class="st">&quot;192.0.2.33&quot;</span>, &amp;(sa.sin_addr));</a>
<a class="sourceLine" id="cb111-8" title="8"></a>
<a class="sourceLine" id="cb111-9" title="9"><span class="co">// now get it back and print it</span></a>
<a class="sourceLine" id="cb111-10" title="10">inet_ntop(AF_INET, &amp;(sa.sin_addr), str, INET_ADDRSTRLEN);</a>
<a class="sourceLine" id="cb111-11" title="11"></a>
<a class="sourceLine" id="cb111-12" title="12">printf(<span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span>, str); <span class="co">// prints &quot;192.0.2.33&quot;</span></a></code></pre></div><div class="sourceCode" id="cb112"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb112-1" title="1"><span class="co">// IPv6 demo of inet_ntop() and inet_pton()</span></a>
<a class="sourceLine" id="cb112-2" title="2"><span class="co">// (basically the same except with a bunch of 6s thrown around)</span></a>
<a class="sourceLine" id="cb112-3" title="3"></a>
<a class="sourceLine" id="cb112-4" title="4"><span class="kw">struct</span> sockaddr_in6 sa;</a>
<a class="sourceLine" id="cb112-5" title="5"><span class="dt">char</span> str[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb112-6" title="6"></a>
<a class="sourceLine" id="cb112-7" title="7"><span class="co">// store this IP address in sa:</span></a>
<a class="sourceLine" id="cb112-8" title="8">inet_pton(AF_INET6, <span class="st">&quot;2001:db8:8714:3a90::12&quot;</span>, &amp;(sa.sin6_addr));</a>
<a class="sourceLine" id="cb112-9" title="9"></a>
<a class="sourceLine" id="cb112-10" title="10"><span class="co">// now get it back and print it</span></a>
<a class="sourceLine" id="cb112-11" title="11">inet_ntop(AF_INET6, &amp;(sa.sin6_addr), str, INET6_ADDRSTRLEN);</a>
<a class="sourceLine" id="cb112-12" title="12"></a>
<a class="sourceLine" id="cb112-13" title="13">printf(<span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span>, str); <span class="co">// prints &quot;2001:db8:8714:3a90::12&quot;</span></a></code></pre></div><div class="sourceCode" id="cb113"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb113-1" title="1"><span class="co">// Helper function you can use:</span></a>
<a class="sourceLine" id="cb113-2" title="2"></a>
<a class="sourceLine" id="cb113-3" title="3"><span class="co">//Convert a struct sockaddr address to a string, IPv4 and IPv6:</span></a>
<a class="sourceLine" id="cb113-4" title="4"></a>
<a class="sourceLine" id="cb113-5" title="5"><span class="dt">char</span> *get_ip_str(<span class="dt">const</span> <span class="kw">struct</span> sockaddr *sa, <span class="dt">char</span> *s, <span class="dt">size_t</span> maxlen)</a>
<a class="sourceLine" id="cb113-6" title="6">{</a>
<a class="sourceLine" id="cb113-7" title="7">    <span class="cf">switch</span>(sa-&gt;sa_family) {</a>
<a class="sourceLine" id="cb113-8" title="8">        <span class="cf">case</span> AF_INET:</a>
<a class="sourceLine" id="cb113-9" title="9">            inet_ntop(AF_INET, &amp;(((<span class="kw">struct</span> sockaddr_in *)sa)-&gt;sin_addr),</a>
<a class="sourceLine" id="cb113-10" title="10">                    s, maxlen);</a>
<a class="sourceLine" id="cb113-11" title="11">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb113-12" title="12"></a>
<a class="sourceLine" id="cb113-13" title="13">        <span class="cf">case</span> AF_INET6:</a>
<a class="sourceLine" id="cb113-14" title="14">            inet_ntop(AF_INET6, &amp;(((<span class="kw">struct</span> sockaddr_in6 *)sa)-&gt;sin6_addr),</a>
<a class="sourceLine" id="cb113-15" title="15">                    s, maxlen);</a>
<a class="sourceLine" id="cb113-16" title="16">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb113-17" title="17"></a>
<a class="sourceLine" id="cb113-18" title="18">        <span class="cf">default</span>:</a>
<a class="sourceLine" id="cb113-19" title="19">            strncpy(s, <span class="st">&quot;Unknown AF&quot;</span>, maxlen);</a>
<a class="sourceLine" id="cb113-20" title="20">            <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb113-21" title="21">    }</a>
<a class="sourceLine" id="cb113-22" title="22"></a>
<a class="sourceLine" id="cb113-23" title="23">    <span class="cf">return</span> s;</a>
<a class="sourceLine" id="cb113-24" title="24">}</a></code></pre></div><h3 id="see-also-12" class="unnumbered unlisted">See Also</h3><p><a href="#getaddrinfoman"><code>getaddrinfo()</code></a></p><h2 id="listenman"><span class="header-section-number">9.15</span> <code>listen()</code></h2><p></p><p>Tell a socket to listen for incoming connections</p><h3 id="synopsis-14" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb114"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb114-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb114-2" title="2"></a>
<a class="sourceLine" id="cb114-3" title="3"><span class="dt">int</span> listen(<span class="dt">int</span> s, <span class="dt">int</span> backlog);</a></code></pre></div><h3 id="description-14" class="unnumbered unlisted">Description</h3><p>You can take your socket descriptor (made with the <code>socket()</code> system call) and tell it to listen for incoming connections. This is what differentiates the servers from the clients, guys.</p><p>The <code>backlog</code> parameter can mean a couple different things depending on the system you on, but loosely it is how many pending connections you can have before the kernel starts rejecting new ones. So as the new connections come in, you should be quick to <code>accept()</code> them so that the backlog doesn’t fill. Try setting it to 10 or so, and if your clients start getting “Connection refused” under heavy load, set it higher.</p><p>Before calling <code>listen()</code>, your server should call <code>bind()</code> to attach itself to a specific port number. That port number (on the server’s IP address) will be the one that clients connect to.</p><h3 id="return-value-14" class="unnumbered unlisted">Return Value</h3><p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p><h3 id="example-14" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb115"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb115-1" title="1"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb115-2" title="2"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb115-3" title="3"></a>
<a class="sourceLine" id="cb115-4" title="4"><span class="co">// first, load up address structs with getaddrinfo():</span></a>
<a class="sourceLine" id="cb115-5" title="5"></a>
<a class="sourceLine" id="cb115-6" title="6">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb115-7" title="7">hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></a>
<a class="sourceLine" id="cb115-8" title="8">hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb115-9" title="9">hints.ai_flags = AI_PASSIVE;     <span class="co">// fill in my IP for me</span></a>
<a class="sourceLine" id="cb115-10" title="10"></a>
<a class="sourceLine" id="cb115-11" title="11">getaddrinfo(NULL, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb115-12" title="12"></a>
<a class="sourceLine" id="cb115-13" title="13"><span class="co">// make a socket:</span></a>
<a class="sourceLine" id="cb115-14" title="14"></a>
<a class="sourceLine" id="cb115-15" title="15">sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb115-16" title="16"></a>
<a class="sourceLine" id="cb115-17" title="17"><span class="co">// bind it to the port we passed in to getaddrinfo():</span></a>
<a class="sourceLine" id="cb115-18" title="18"></a>
<a class="sourceLine" id="cb115-19" title="19">bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a>
<a class="sourceLine" id="cb115-20" title="20"></a>
<a class="sourceLine" id="cb115-21" title="21">listen(sockfd, <span class="dv">10</span>); <span class="co">// set s up to be a server (listening) socket</span></a>
<a class="sourceLine" id="cb115-22" title="22"></a>
<a class="sourceLine" id="cb115-23" title="23"><span class="co">// then have an accept() loop down here somewhere</span></a></code></pre></div><h3 id="see-also-13" class="unnumbered unlisted">See Also</h3><p><a href="#acceptman"><code>accept()</code></a>, <a href="#bindman"><code>bind()</code></a>, <a href="#socketman"><code>socket()</code></a></p><h2 id="perrorman"><span class="header-section-number">9.16</span> <code>perror()</code>, <code>strerror()</code></h2><p> </p><p>Print an error as a human-readable string</p><h3 id="synopsis-15" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb116"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb116-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb116-2" title="2"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span><span class="pp">   </span><span class="co">// for strerror()</span></a>
<a class="sourceLine" id="cb116-3" title="3"></a>
<a class="sourceLine" id="cb116-4" title="4"><span class="dt">void</span> perror(<span class="dt">const</span> <span class="dt">char</span> *s);</a>
<a class="sourceLine" id="cb116-5" title="5"><span class="dt">char</span> *strerror(<span class="dt">int</span> errnum);</a></code></pre></div><h3 id="description-15" class="unnumbered unlisted">Description</h3><p>Since so many functions return <code>-1</code> on error and set the value of the variable  <code>errno</code> to be some number, it would sure be nice if you could easily print that in a form that made sense to you.</p><p>Mercifully, <code>perror()</code> does that. If you want more description to be printed before the error, you can point the parameter <code>s</code> to it (or you can leave <code>s</code> as <code>NULL</code> and nothing additional will be printed).</p><p>In a nutshell, this function takes <code>errno</code> values, like <code>ECONNRESET</code>, and prints them nicely, like “Connection reset by peer.”</p><p>The function <code>strerror()</code> is very similar to <code>perror()</code>, except it returns a pointer to the error message string for a given value (you usually pass in the variable <code>errno</code>).</p><h3 id="return-value-15" class="unnumbered unlisted">Return Value</h3><p><code>strerror()</code> returns a pointer to the error message string.</p><h3 id="example-15" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb117"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb117-1" title="1"><span class="dt">int</span> s;</a>
<a class="sourceLine" id="cb117-2" title="2"></a>
<a class="sourceLine" id="cb117-3" title="3">s = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb117-4" title="4"></a>
<a class="sourceLine" id="cb117-5" title="5"><span class="cf">if</span> (s == <span class="dv">-1</span>) { <span class="co">// some error has occurred</span></a>
<a class="sourceLine" id="cb117-6" title="6">    <span class="co">// prints &quot;socket error: &quot; + the error message:</span></a>
<a class="sourceLine" id="cb117-7" title="7">    perror(<span class="st">&quot;socket error&quot;</span>);</a>
<a class="sourceLine" id="cb117-8" title="8">}</a>
<a class="sourceLine" id="cb117-9" title="9"></a>
<a class="sourceLine" id="cb117-10" title="10"><span class="co">// similarly:</span></a>
<a class="sourceLine" id="cb117-11" title="11"><span class="cf">if</span> (listen(s, <span class="dv">10</span>) == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb117-12" title="12">    <span class="co">// this prints &quot;an error: &quot; + the error message from errno:</span></a>
<a class="sourceLine" id="cb117-13" title="13">    printf(<span class="st">&quot;an error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, strerror(errno));</a>
<a class="sourceLine" id="cb117-14" title="14">}</a></code></pre></div><h3 id="see-also-14" class="unnumbered unlisted">See Also</h3><p><a href="#errnoman"><code>errno</code></a></p><h2 id="pollman"><span class="header-section-number">9.17</span> <code>poll()</code></h2><p></p><p>Test for events on multiple sockets simultaneously</p><h3 id="synopsis-16" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb118"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb118-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/poll.h&gt;</span></a>
<a class="sourceLine" id="cb118-2" title="2"></a>
<a class="sourceLine" id="cb118-3" title="3"><span class="dt">int</span> poll(<span class="kw">struct</span> pollfd *ufds, <span class="dt">unsigned</span> <span class="dt">int</span> nfds, <span class="dt">int</span> timeout);</a></code></pre></div><h3 id="description-16" class="unnumbered unlisted">Description</h3><p>This function is very similar to <code>select()</code> in that they both watch sets of file descriptors for events, such as incoming data ready to <code>recv()</code>, socket ready to <code>send()</code> data to, out-of-band data ready to <code>recv()</code>, errors, etc.</p><p>The basic idea is that you pass an array of <code>nfds</code> <code>struct pollfd</code>s in <code>ufds</code>, along with a timeout in milliseconds (1000 milliseconds in a second). The <code>timeout</code> can be negative if you want to wait forever. If no event happens on any of the socket descriptors by the timeout, <code>poll()</code> will return.</p><p>Each element in the array of <code>struct pollfd</code>s represents one socket descriptor, and contains the following fields:</p><p></p><div class="sourceCode" id="cb119"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb119-1" title="1"><span class="kw">struct</span> pollfd {</a>
<a class="sourceLine" id="cb119-2" title="2">    <span class="dt">int</span> fd;         <span class="co">// the socket descriptor</span></a>
<a class="sourceLine" id="cb119-3" title="3">    <span class="dt">short</span> events;   <span class="co">// bitmap of events we&#39;re interested in</span></a>
<a class="sourceLine" id="cb119-4" title="4">    <span class="dt">short</span> revents;  <span class="co">// when poll() returns, bitmap of events that occurred</span></a>
<a class="sourceLine" id="cb119-5" title="5">};</a></code></pre></div><p>Before calling <code>poll()</code>, load <code>fd</code> with the socket descriptor (if you set <code>fd</code> to a negative number, this <code>struct pollfd</code> is ignored and its <code>revents</code> field is set to zero) and then construct the <code>events</code> field by bitwise-ORing the following macros:</p><table><thead><tr class="header"><th>Macro</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>POLLIN</code></td><td>Alert me when data is ready to <code>recv()</code> on this socket.</td></tr><tr class="even"><td><code>POLLOUT</code></td><td>Alert me when I can <code>send()</code> data to this socket without blocking.</td></tr><tr class="odd"><td><code>POLLPRI</code></td><td>Alert me when out-of-band data is ready to <code>recv()</code> on this socket.</td></tr></tbody></table><p>Once the <code>poll()</code> call returns, the <code>revents</code> field will be constructed as a bitwise-OR of the above fields, telling you which descriptors actually have had that event occur. Additionally, these other fields might be present:</p><table><colgroup><col style="width: 16%" /><col style="width: 83%" /></colgroup><thead><tr class="header"><th>Macro</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>POLLERR</code></td><td>An error has occurred on this socket.</td></tr><tr class="even"><td><code>POLLHUP</code></td><td>The remote side of the connection hung up.</td></tr><tr class="odd"><td><code>POLLNVAL</code></td><td>Something was wrong with the socket descriptor <code>fd</code>—maybe it’s uninitialized?</td></tr></tbody></table><h3 id="return-value-16" class="unnumbered unlisted">Return Value</h3><p>Returns the number of elements in the <code>ufds</code> array that have had event occur on them; this can be zero if the timeout occurred. Also returns <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p><h3 id="example-16" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb120"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb120-1" title="1"><span class="dt">int</span> s1, s2;</a>
<a class="sourceLine" id="cb120-2" title="2"><span class="dt">int</span> rv;</a>
<a class="sourceLine" id="cb120-3" title="3"><span class="dt">char</span> buf1[<span class="dv">256</span>], buf2[<span class="dv">256</span>];</a>
<a class="sourceLine" id="cb120-4" title="4"><span class="kw">struct</span> pollfd ufds[<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb120-5" title="5"></a>
<a class="sourceLine" id="cb120-6" title="6">s1 = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb120-7" title="7">s2 = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb120-8" title="8"></a>
<a class="sourceLine" id="cb120-9" title="9"><span class="co">// pretend we&#39;ve connected both to a server at this point</span></a>
<a class="sourceLine" id="cb120-10" title="10"><span class="co">//connect(s1, ...)...</span></a>
<a class="sourceLine" id="cb120-11" title="11"><span class="co">//connect(s2, ...)...</span></a>
<a class="sourceLine" id="cb120-12" title="12"></a>
<a class="sourceLine" id="cb120-13" title="13"><span class="co">// set up the array of file descriptors.</span></a>
<a class="sourceLine" id="cb120-14" title="14"><span class="co">//</span></a>
<a class="sourceLine" id="cb120-15" title="15"><span class="co">// in this example, we want to know when there&#39;s normal or out-of-band</span></a>
<a class="sourceLine" id="cb120-16" title="16"><span class="co">// data ready to be recv()&#39;d...</span></a>
<a class="sourceLine" id="cb120-17" title="17"></a>
<a class="sourceLine" id="cb120-18" title="18">ufds[<span class="dv">0</span>].fd = s1;</a>
<a class="sourceLine" id="cb120-19" title="19">ufds[<span class="dv">0</span>].events = POLLIN | POLLPRI; <span class="co">// check for normal or out-of-band</span></a>
<a class="sourceLine" id="cb120-20" title="20"></a>
<a class="sourceLine" id="cb120-21" title="21">ufds[<span class="dv">1</span>].fd = s2;</a>
<a class="sourceLine" id="cb120-22" title="22">ufds[<span class="dv">1</span>].events = POLLIN; <span class="co">// check for just normal data</span></a>
<a class="sourceLine" id="cb120-23" title="23"></a>
<a class="sourceLine" id="cb120-24" title="24"><span class="co">// wait for events on the sockets, 3.5 second timeout</span></a>
<a class="sourceLine" id="cb120-25" title="25">rv = poll(ufds, <span class="dv">2</span>, <span class="dv">3500</span>);</a>
<a class="sourceLine" id="cb120-26" title="26"></a>
<a class="sourceLine" id="cb120-27" title="27"><span class="cf">if</span> (rv == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb120-28" title="28">    perror(<span class="st">&quot;poll&quot;</span>); <span class="co">// error occurred in poll()</span></a>
<a class="sourceLine" id="cb120-29" title="29">} <span class="cf">else</span> <span class="cf">if</span> (rv == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb120-30" title="30">    printf(<span class="st">&quot;Timeout occurred! No data after 3.5 seconds.</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb120-31" title="31">} <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb120-32" title="32">    <span class="co">// check for events on s1:</span></a>
<a class="sourceLine" id="cb120-33" title="33">    <span class="cf">if</span> (ufds[<span class="dv">0</span>].revents &amp; POLLIN) {</a>
<a class="sourceLine" id="cb120-34" title="34">        recv(s1, buf1, <span class="kw">sizeof</span> buf1, <span class="dv">0</span>); <span class="co">// receive normal data</span></a>
<a class="sourceLine" id="cb120-35" title="35">    }</a>
<a class="sourceLine" id="cb120-36" title="36">    <span class="cf">if</span> (ufds[<span class="dv">0</span>].revents &amp; POLLPRI) {</a>
<a class="sourceLine" id="cb120-37" title="37">        recv(s1, buf1, <span class="kw">sizeof</span> buf1, MSG_OOB); <span class="co">// out-of-band data</span></a>
<a class="sourceLine" id="cb120-38" title="38">    }</a>
<a class="sourceLine" id="cb120-39" title="39"></a>
<a class="sourceLine" id="cb120-40" title="40">    <span class="co">// check for events on s2:</span></a>
<a class="sourceLine" id="cb120-41" title="41">    <span class="cf">if</span> (ufds[<span class="dv">1</span>].revents &amp; POLLIN) {</a>
<a class="sourceLine" id="cb120-42" title="42">        recv(s1, buf2, <span class="kw">sizeof</span> buf2, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb120-43" title="43">    }</a>
<a class="sourceLine" id="cb120-44" title="44">}</a></code></pre></div><h3 id="see-also-15" class="unnumbered unlisted">See Also</h3><p><a href="#selectman"><code>select()</code></a></p><h2 id="recvman"><span class="header-section-number">9.18</span> <code>recv()</code>, <code>recvfrom()</code></h2><p> </p><p>Receive data on a socket</p><h3 id="synopsis-17" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb121"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb121-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb121-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb121-3" title="3"></a>
<a class="sourceLine" id="cb121-4" title="4"><span class="dt">ssize_t</span> recv(<span class="dt">int</span> s, <span class="dt">void</span> *buf, <span class="dt">size_t</span> len, <span class="dt">int</span> flags);</a>
<a class="sourceLine" id="cb121-5" title="5"><span class="dt">ssize_t</span> recvfrom(<span class="dt">int</span> s, <span class="dt">void</span> *buf, <span class="dt">size_t</span> len, <span class="dt">int</span> flags,</a>
<a class="sourceLine" id="cb121-6" title="6">                 <span class="kw">struct</span> sockaddr *from, socklen_t *fromlen);</a></code></pre></div><h3 id="description-17" class="unnumbered unlisted">Description</h3><p>Once you have a socket up and connected, you can read incoming data from the remote side using the <code>recv()</code> (for TCP  <code>SOCK_STREAM</code> sockets) and <code>recvfrom()</code> (for UDP  <code>SOCK_DGRAM</code> sockets).</p><p>Both functions take the socket descriptor <code>s</code>, a pointer to the buffer <code>buf</code>, the size (in bytes) of the buffer <code>len</code>, and a set of <code>flags</code> that control how the functions work.</p><p>Additionally, the <code>recvfrom()</code> takes a  <code>struct sockaddr*</code>, <code>from</code> that will tell you where the data came from, and will fill in <code>fromlen</code> with the size of <code>struct sockaddr</code>. (You must also initialize <code>fromlen</code> to be the size of <code>from</code> or <code>struct sockaddr</code>.)</p><p>So what wondrous flags can you pass into this function? Here are some of them, but you should check your local man pages for more information and what is actually supported on your system. You bitwise-or these together, or just set <code>flags</code> to <code>0</code> if you want it to be a regular vanilla <code>recv()</code>.</p><table><colgroup><col style="width: 20%" /><col style="width: 79%" /></colgroup><thead><tr class="header"><th>Macro</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>MSG_OOB</code></td><td>Receive Out of Band data. This is how to get data that has been sent to you with the <code>MSG_OOB</code> flag in <code>send()</code>. As the receiving side, you will have had signal  <code>SIGURG</code> raised telling you there is urgent data. In your handler for that signal, you could call <code>recv()</code> with this <code>MSG_OOB</code> flag.</td></tr><tr class="even"><td><code>MSG_PEEK</code></td><td>If you want to call <code>recv()</code> “just for pretend”, you can call it with this flag. This will tell you what’s waiting in the buffer for when you call <code>recv()</code> “for real” (i.e. <em>without</em> the <code>MSG_PEEK</code> flag. It’s like a sneak preview into the next <code>recv()</code> call.</td></tr><tr class="odd"><td><code>MSG_WAITALL</code></td><td>Tell <code>recv()</code> to not return until all the data you specified in the <code>len</code> parameter. It will ignore your wishes in extreme circumstances, however, like if a signal interrupts the call or if some error occurs or if the remote side closes the connection, etc. Don’t be mad with it.</td></tr></tbody></table><p>When you call <code>recv()</code>, it will block until there is some data to read. If you want to not block, set the socket to non-blocking or check with <code>select()</code> or <code>poll()</code> to see if there is incoming data before calling <code>recv()</code> or <code>recvfrom()</code>.</p><h3 id="return-value-17" class="unnumbered unlisted">Return Value</h3><p>Returns the number of bytes actually received (which might be less than you requested in the <code>len</code> parameter), or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p><p>If the remote side has closed the connection, <code>recv()</code> will return <code>0</code>. This is the normal method for determining if the remote side has closed the connection. Normality is good, rebel!</p><h3 id="example-17" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb122"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb122-1" title="1"><span class="co">// stream sockets and recv()</span></a>
<a class="sourceLine" id="cb122-2" title="2"></a>
<a class="sourceLine" id="cb122-3" title="3"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb122-4" title="4"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb122-5" title="5"><span class="dt">char</span> buf[<span class="dv">512</span>];</a>
<a class="sourceLine" id="cb122-6" title="6"><span class="dt">int</span> byte_count;</a>
<a class="sourceLine" id="cb122-7" title="7"></a>
<a class="sourceLine" id="cb122-8" title="8"><span class="co">// get host info, make socket, and connect it</span></a>
<a class="sourceLine" id="cb122-9" title="9">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb122-10" title="10">hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></a>
<a class="sourceLine" id="cb122-11" title="11">hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb122-12" title="12">getaddrinfo(<span class="st">&quot;www.example.com&quot;</span>, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb122-13" title="13">sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb122-14" title="14">connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a>
<a class="sourceLine" id="cb122-15" title="15"></a>
<a class="sourceLine" id="cb122-16" title="16"><span class="co">// all right! now that we&#39;re connected, we can receive some data!</span></a>
<a class="sourceLine" id="cb122-17" title="17">byte_count = recv(sockfd, buf, <span class="kw">sizeof</span> buf, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb122-18" title="18">printf(<span class="st">&quot;recv()&#39;d %d bytes of data in buf</span><span class="sc">\n</span><span class="st">&quot;</span>, byte_count);</a></code></pre></div><div class="sourceCode" id="cb123"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb123-1" title="1"><span class="co">// datagram sockets and recvfrom()</span></a>
<a class="sourceLine" id="cb123-2" title="2"></a>
<a class="sourceLine" id="cb123-3" title="3"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb123-4" title="4"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb123-5" title="5"><span class="dt">int</span> byte_count;</a>
<a class="sourceLine" id="cb123-6" title="6">socklen_t fromlen;</a>
<a class="sourceLine" id="cb123-7" title="7"><span class="kw">struct</span> sockaddr_storage addr;</a>
<a class="sourceLine" id="cb123-8" title="8"><span class="dt">char</span> buf[<span class="dv">512</span>];</a>
<a class="sourceLine" id="cb123-9" title="9"><span class="dt">char</span> ipstr[INET6_ADDRSTRLEN];</a>
<a class="sourceLine" id="cb123-10" title="10"></a>
<a class="sourceLine" id="cb123-11" title="11"><span class="co">// get host info, make socket, bind it to port 4950</span></a>
<a class="sourceLine" id="cb123-12" title="12">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb123-13" title="13">hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></a>
<a class="sourceLine" id="cb123-14" title="14">hints.ai_socktype = SOCK_DGRAM;</a>
<a class="sourceLine" id="cb123-15" title="15">hints.ai_flags = AI_PASSIVE;</a>
<a class="sourceLine" id="cb123-16" title="16">getaddrinfo(NULL, <span class="st">&quot;4950&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb123-17" title="17">sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb123-18" title="18">bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a>
<a class="sourceLine" id="cb123-19" title="19"></a>
<a class="sourceLine" id="cb123-20" title="20"><span class="co">// no need to accept(), just recvfrom():</span></a>
<a class="sourceLine" id="cb123-21" title="21"></a>
<a class="sourceLine" id="cb123-22" title="22">fromlen = <span class="kw">sizeof</span> addr;</a>
<a class="sourceLine" id="cb123-23" title="23">byte_count = recvfrom(sockfd, buf, <span class="kw">sizeof</span> buf, <span class="dv">0</span>, &amp;addr, &amp;fromlen);</a>
<a class="sourceLine" id="cb123-24" title="24"></a>
<a class="sourceLine" id="cb123-25" title="25">printf(<span class="st">&quot;recv()&#39;d %d bytes of data in buf</span><span class="sc">\n</span><span class="st">&quot;</span>, byte_count);</a>
<a class="sourceLine" id="cb123-26" title="26">printf(<span class="st">&quot;from IP address %s</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb123-27" title="27">    inet_ntop(addr.ss_family,</a>
<a class="sourceLine" id="cb123-28" title="28">        addr.ss_family == AF_INET?</a>
<a class="sourceLine" id="cb123-29" title="29">            ((<span class="kw">struct</span> sockadd_in *)&amp;addr)-&gt;sin_addr:</a>
<a class="sourceLine" id="cb123-30" title="30">            ((<span class="kw">struct</span> sockadd_in6 *)&amp;addr)-&gt;sin6_addr,</a>
<a class="sourceLine" id="cb123-31" title="31">        ipstr, <span class="kw">sizeof</span> ipstr);</a></code></pre></div><h3 id="see-also-16" class="unnumbered unlisted">See Also</h3><p><a href="#sendman"><code>send()</code></a>, <a href="#sendman"><code>sendto()</code></a>, <a href="#selectman"><code>select()</code></a>, <a href="#pollman"><code>poll()</code></a>, <a href="#blocking">Blocking</a></p><h2 id="selectman"><span class="header-section-number">9.19</span> <code>select()</code></h2><p></p><p>Check if sockets descriptors are ready to read/write</p><h3 id="synopsis-18" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb124"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb124-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/select.h&gt;</span></a>
<a class="sourceLine" id="cb124-2" title="2"></a>
<a class="sourceLine" id="cb124-3" title="3"><span class="dt">int</span> select(<span class="dt">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,</a>
<a class="sourceLine" id="cb124-4" title="4">           <span class="kw">struct</span> timeval *timeout);</a>
<a class="sourceLine" id="cb124-5" title="5"></a>
<a class="sourceLine" id="cb124-6" title="6">FD_SET(<span class="dt">int</span> fd, fd_set *set);</a>
<a class="sourceLine" id="cb124-7" title="7">FD_CLR(<span class="dt">int</span> fd, fd_set *set);</a>
<a class="sourceLine" id="cb124-8" title="8">FD_ISSET(<span class="dt">int</span> fd, fd_set *set);</a>
<a class="sourceLine" id="cb124-9" title="9">FD_ZERO(fd_set *set);</a></code></pre></div><h3 id="description-18" class="unnumbered unlisted">Description</h3><p>The <code>select()</code> function gives you a way to simultaneously check multiple sockets to see if they have data waiting to be <code>recv()</code>d, or if you can <code>send()</code> data to them without blocking, or if some exception has occurred.</p><p>You populate your sets of socket descriptors using the macros, like <code>FD_SET()</code>, above. Once you have the set, you pass it into the function as one of the following parameters: <code>readfds</code> if you want to know when any of the sockets in the set is ready to <code>recv()</code> data, <code>writefds</code> if any of the sockets is ready to <code>send()</code> data to, and/or <code>exceptfds</code> if you need to know when an exception (error) occurs on any of the sockets. Any or all of these parameters can be <code>NULL</code> if you’re not interested in those types of events. After <code>select()</code> returns, the values in the sets will be changed to show which are ready for reading or writing, and which have exceptions.</p><p>The first parameter, <code>n</code> is the highest-numbered socket descriptor (they’re just <code>int</code>s, remember?) plus one.</p><p>Lastly, the  <code>struct timeval</code>, <code>timeout</code>, at the end—this lets you tell <code>select()</code> how long to check these sets for. It’ll return after the timeout, or when an event occurs, whichever is first. The <code>struct timeval</code> has two fields: <code>tv_sec</code> is the number of seconds, to which is added <code>tv_usec</code>, the number of microseconds (1,000,000 microseconds in a second).</p><p>The helper macros do the following:</p><table><thead><tr class="header"><th>Macro</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>FD_SET(int fd, fd_set *set);</code></td><td>Add <code>fd</code> to the <code>set</code>.</td></tr><tr class="even"><td><code>FD_CLR(int fd, fd_set *set);</code></td><td>Remove <code>fd</code> from the <code>set</code>.</td></tr><tr class="odd"><td><code>FD_ISSET(int fd, fd_set *set);</code></td><td>Return true if <code>fd</code> is in the <code>set</code>.</td></tr><tr class="even"><td><code>FD_ZERO(fd_set *set);</code></td><td>Clear all entries from the <code>set</code>.</td></tr></tbody></table><p>Note for Linux users: Linux’s <code>select()</code> can return “ready-to-read” and then not actually be ready to read, thus causing the subsequent <code>read()</code> call to block. You can work around this bug by setting  <code>O_NONBLOCK</code> flag on the receiving socket so it errors with <code>EWOULDBLOCK</code>, then ignoring this error if it occurs. See the <a href="#fcntlman"><code>fcntl()</code> man page</a> for more info on setting a socket to non-blocking.</p><h3 id="return-value-18" class="unnumbered unlisted">Return Value</h3><p>Returns the number of descriptors in the set on success, <code>0</code> if the timeout was reached, or <code>-1</code> on error (and <code>errno</code> will be set accordingly). Also, the sets are modified to show which sockets are ready.</p><h3 id="example-18" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb125"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb125-1" title="1"><span class="dt">int</span> s1, s2, n;</a>
<a class="sourceLine" id="cb125-2" title="2">fd_set readfds;</a>
<a class="sourceLine" id="cb125-3" title="3"><span class="kw">struct</span> timeval tv;</a>
<a class="sourceLine" id="cb125-4" title="4"><span class="dt">char</span> buf1[<span class="dv">256</span>], buf2[<span class="dv">256</span>];</a>
<a class="sourceLine" id="cb125-5" title="5"></a>
<a class="sourceLine" id="cb125-6" title="6"><span class="co">// pretend we&#39;ve connected both to a server at this point</span></a>
<a class="sourceLine" id="cb125-7" title="7"><span class="co">//s1 = socket(...);</span></a>
<a class="sourceLine" id="cb125-8" title="8"><span class="co">//s2 = socket(...);</span></a>
<a class="sourceLine" id="cb125-9" title="9"><span class="co">//connect(s1, ...)...</span></a>
<a class="sourceLine" id="cb125-10" title="10"><span class="co">//connect(s2, ...)...</span></a>
<a class="sourceLine" id="cb125-11" title="11"></a>
<a class="sourceLine" id="cb125-12" title="12"><span class="co">// clear the set ahead of time</span></a>
<a class="sourceLine" id="cb125-13" title="13">FD_ZERO(&amp;readfds);</a>
<a class="sourceLine" id="cb125-14" title="14"></a>
<a class="sourceLine" id="cb125-15" title="15"><span class="co">// add our descriptors to the set</span></a>
<a class="sourceLine" id="cb125-16" title="16">FD_SET(s1, &amp;readfds);</a>
<a class="sourceLine" id="cb125-17" title="17">FD_SET(s2, &amp;readfds);</a>
<a class="sourceLine" id="cb125-18" title="18"></a>
<a class="sourceLine" id="cb125-19" title="19"><span class="co">// since we got s2 second, it&#39;s the &quot;greater&quot;, so we use that for</span></a>
<a class="sourceLine" id="cb125-20" title="20"><span class="co">// the n param in select()</span></a>
<a class="sourceLine" id="cb125-21" title="21">n = s2 + <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb125-22" title="22"></a>
<a class="sourceLine" id="cb125-23" title="23"><span class="co">// wait until either socket has data ready to be recv()d (timeout 10.5 secs)</span></a>
<a class="sourceLine" id="cb125-24" title="24">tv.tv_sec = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb125-25" title="25">tv.tv_usec = <span class="dv">500000</span>;</a>
<a class="sourceLine" id="cb125-26" title="26">rv = select(n, &amp;readfds, NULL, NULL, &amp;tv);</a>
<a class="sourceLine" id="cb125-27" title="27"></a>
<a class="sourceLine" id="cb125-28" title="28"><span class="cf">if</span> (rv == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb125-29" title="29">    perror(<span class="st">&quot;select&quot;</span>); <span class="co">// error occurred in select()</span></a>
<a class="sourceLine" id="cb125-30" title="30">} <span class="cf">else</span> <span class="cf">if</span> (rv == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb125-31" title="31">    printf(<span class="st">&quot;Timeout occurred! No data after 10.5 seconds.</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb125-32" title="32">} <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb125-33" title="33">    <span class="co">// one or both of the descriptors have data</span></a>
<a class="sourceLine" id="cb125-34" title="34">    <span class="cf">if</span> (FD_ISSET(s1, &amp;readfds)) {</a>
<a class="sourceLine" id="cb125-35" title="35">        recv(s1, buf1, <span class="kw">sizeof</span> buf1, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb125-36" title="36">    }</a>
<a class="sourceLine" id="cb125-37" title="37">    <span class="cf">if</span> (FD_ISSET(s2, &amp;readfds)) {</a>
<a class="sourceLine" id="cb125-38" title="38">        recv(s2, buf2, <span class="kw">sizeof</span> buf2, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb125-39" title="39">    }</a>
<a class="sourceLine" id="cb125-40" title="40">}</a></code></pre></div><h3 id="see-also-17" class="unnumbered unlisted">See Also</h3><p><a href="#pollman"><code>poll()</code></a></p><h2 id="setsockoptman"><span class="header-section-number">9.20</span> <code>setsockopt()</code>, <code>getsockopt()</code></h2><p> </p><p>Set various options for a socket</p><h3 id="synopsis-19" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb126"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb126-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb126-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb126-3" title="3"></a>
<a class="sourceLine" id="cb126-4" title="4"><span class="dt">int</span> getsockopt(<span class="dt">int</span> s, <span class="dt">int</span> level, <span class="dt">int</span> optname, <span class="dt">void</span> *optval,</a>
<a class="sourceLine" id="cb126-5" title="5">               socklen_t *optlen);</a>
<a class="sourceLine" id="cb126-6" title="6"><span class="dt">int</span> setsockopt(<span class="dt">int</span> s, <span class="dt">int</span> level, <span class="dt">int</span> optname, <span class="dt">const</span> <span class="dt">void</span> *optval,</a>
<a class="sourceLine" id="cb126-7" title="7">               socklen_t optlen);</a></code></pre></div><h3 id="description-19" class="unnumbered unlisted">Description</h3><p>Sockets are fairly configurable beasts. In fact, they are so configurable, I’m not even going to cover it all here. It’s probably system-dependent anyway. But I will talk about the basics.</p><p>Obviously, these functions get and set certain options on a socket. On a Linux box, all the socket information is in the man page for socket in section 7. (Type: “<code>man 7 socket</code>” to get all these goodies.)</p><p>As for parameters, <code>s</code> is the socket you’re talking about, level should be set to  <code>SOL_SOCKET</code>. Then you set the <code>optname</code> to the name you’re interested in. Again, see your man page for all the options, but here are some of the most fun ones:</p><table><colgroup><col style="width: 26%" /><col style="width: 73%" /></colgroup><thead><tr class="header"><th><code>optname</code></th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>SO_BINDTODEVICE</code></td><td>Bind this socket to a symbolic device name like <code>eth0</code> instead of using <code>bind()</code> to bind it to an IP address. Type the command <code>ifconfig</code> under Unix to see the device names.</td></tr><tr class="even"><td><code>SO_REUSEADDR</code></td><td>Allows other sockets to <code>bind()</code> to this port, unless there is an active listening socket bound to the port already. This enables you to get around those “Address already in use” error messages when you try to restart your server after a crash.</td></tr><tr class="odd"><td><code>SOCK_DGRAM</code></td><td>Allows UDP datagram (<code>SOCK_DGRAM</code>) sockets to send and receive packets sent to and from the broadcast address. Does nothing—<em>NOTHING!!</em>—to TCP stream sockets! Hahaha!</td></tr></tbody></table><p>As for the parameter <code>optval</code>, it’s usually a pointer to an <code>int</code> indicating the value in question. For booleans, zero is false, and non-zero is true. And that’s an absolute fact, unless it’s different on your system. If there is no parameter to be passed, <code>optval</code> can be <code>NULL</code>.</p><p>The final parameter, <code>optlen</code>, should be set to the length of <code>optval</code>, probably <code>sizeof(int)</code>, but varies depending on the option. Note that in the case of <code>getsockopt()</code>, this is a pointer to a <code>socklen_t</code>, and it specifies the maximum size object that will be stored in <code>optval</code> (to prevent buffer overflows). And <code>getsockopt()</code> will modify the value of <code>optlen</code> to reflect the number of bytes actually set.</p><p><strong>Warning</strong>: on some systems (notably   Sun and  Windows), the option can be a <code>char</code> instead of an <code>int</code>, and is set to, for example, a character value of <code>'1'</code> instead of an <code>int</code> value of <code>1</code>. Again, check your own man pages for more info with “<code>man setsockopt</code>” and “<code>man 7 socket</code>”!</p><h3 id="return-value-19" class="unnumbered unlisted">Return Value</h3><p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p><h3 id="example-19" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb127"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb127-1" title="1"><span class="dt">int</span> optval;</a>
<a class="sourceLine" id="cb127-2" title="2"><span class="dt">int</span> optlen;</a>
<a class="sourceLine" id="cb127-3" title="3"><span class="dt">char</span> *optval2;</a>
<a class="sourceLine" id="cb127-4" title="4"></a>
<a class="sourceLine" id="cb127-5" title="5"><span class="co">// set SO_REUSEADDR on a socket to true (1):</span></a>
<a class="sourceLine" id="cb127-6" title="6">optval = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb127-7" title="7">setsockopt(s1, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="kw">sizeof</span> optval);</a>
<a class="sourceLine" id="cb127-8" title="8"></a>
<a class="sourceLine" id="cb127-9" title="9"><span class="co">// bind a socket to a device name (might not work on all systems):</span></a>
<a class="sourceLine" id="cb127-10" title="10">optval2 = <span class="st">&quot;eth1&quot;</span>; <span class="co">// 4 bytes long, so 4, below:</span></a>
<a class="sourceLine" id="cb127-11" title="11">setsockopt(s2, SOL_SOCKET, SO_BINDTODEVICE, optval2, <span class="dv">4</span>);</a>
<a class="sourceLine" id="cb127-12" title="12"></a>
<a class="sourceLine" id="cb127-13" title="13"><span class="co">// see if the SO_BROADCAST flag is set:</span></a>
<a class="sourceLine" id="cb127-14" title="14">getsockopt(s3, SOL_SOCKET, SO_BROADCAST, &amp;optval, &amp;optlen);</a>
<a class="sourceLine" id="cb127-15" title="15"><span class="cf">if</span> (optval != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb127-16" title="16">    print(<span class="st">&quot;SO_BROADCAST enabled on s3!</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb127-17" title="17">}</a></code></pre></div><h3 id="see-also-18" class="unnumbered unlisted">See Also</h3><p><a href="#fcntlman"><code>fcntl()</code></a></p><h2 id="sendman"><span class="header-section-number">9.21</span> <code>send()</code>, <code>sendto()</code></h2><p> </p><p>Send data out over a socket</p><h3 id="synopsis-20" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb128"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb128-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb128-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb128-3" title="3"></a>
<a class="sourceLine" id="cb128-4" title="4"><span class="dt">ssize_t</span> send(<span class="dt">int</span> s, <span class="dt">const</span> <span class="dt">void</span> *buf, <span class="dt">size_t</span> len, <span class="dt">int</span> flags);</a>
<a class="sourceLine" id="cb128-5" title="5"><span class="dt">ssize_t</span> sendto(<span class="dt">int</span> s, <span class="dt">const</span> <span class="dt">void</span> *buf, <span class="dt">size_t</span> len,</a>
<a class="sourceLine" id="cb128-6" title="6">               <span class="dt">int</span> flags, <span class="dt">const</span> <span class="kw">struct</span> sockaddr *to,</a>
<a class="sourceLine" id="cb128-7" title="7">               socklen_t tolen);</a></code></pre></div><h3 id="description-20" class="unnumbered unlisted">Description</h3><p>These functions send data to a socket. Generally speaking, <code>send()</code> is used for TCP <code>SOCK_STREAM</code> connected sockets, and <code>sendto()</code> is used for UDP <code>SOCK_DGRAM</code> unconnected datagram sockets. With the unconnected sockets, you must specify the destination of a packet each time you send one, and that’s why the last parameters of <code>sendto()</code> define where the packet is going.</p><p>With both <code>send()</code> and <code>sendto()</code>, the parameter <code>s</code> is the socket, <code>buf</code> is a pointer to the data you want to send, <code>len</code> is the number of bytes you want to send, and <code>flags</code> allows you to specify more information about how the data is to be sent. Set <code>flags</code> to zero if you want it to be “normal” data. Here are some of the commonly used flags, but check your local <code>send()</code> man pages for more details:</p><table><colgroup><col style="width: 23%" /><col style="width: 76%" /></colgroup><thead><tr class="header"><th>Macro</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>MSG_OOB</code></td><td>Send as  “out of band” data. TCP supports this, and it’s a way to tell the receiving system that this data has a higher priority than the normal data. The receiver will receive the signal  <code>SIGURG</code> and it can then receive this data without first receiving all the rest of the normal data in the queue.</td></tr><tr class="even"><td><code>MSG_DONTROUTE</code></td><td>Don’t send this data over a router, just keep it local.</td></tr><tr class="odd"><td><code>MSG_DONTWAIT</code></td><td>If <code>send()</code> would block because outbound traffic is clogged, have it return  <code>EAGAIN</code>. This is like a “enable  non-blocking just for this send.” See the section on <a href="#blocking">blocking</a> for more details.</td></tr><tr class="even"><td><code>MSG_NOSIGNAL</code></td><td>If you <code>send()</code> to a remote host which is no longer <code>recv()</code>ing, you’ll typically get the signal  <code>SIGPIPE</code>. Adding this flag prevents that signal from being raised.</td></tr></tbody></table><h3 id="return-value-20" class="unnumbered unlisted">Return Value</h3><p>Returns the number of bytes actually sent, or <code>-1</code> on error (and <code>errno</code> will be set accordingly). Note that the number of bytes actually sent might be less than the number you asked it to send! See the section on <a href="#sendall">handling partial <code>send()</code>s</a> for a helper function to get around this.</p><p>Also, if the socket has been closed by either side, the process calling <code>send()</code> will get the signal <code>SIGPIPE</code>. (Unless <code>send()</code> was called with the <code>MSG_NOSIGNAL</code> flag.)</p><h3 id="example-20" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb129"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb129-1" title="1"><span class="dt">int</span> spatula_count = <span class="dv">3490</span>;</a>
<a class="sourceLine" id="cb129-2" title="2"><span class="dt">char</span> *secret_message = <span class="st">&quot;The Cheese is in The Toaster&quot;</span>;</a>
<a class="sourceLine" id="cb129-3" title="3"></a>
<a class="sourceLine" id="cb129-4" title="4"><span class="dt">int</span> stream_socket, dgram_socket;</a>
<a class="sourceLine" id="cb129-5" title="5"><span class="kw">struct</span> sockaddr_in dest;</a>
<a class="sourceLine" id="cb129-6" title="6"><span class="dt">int</span> temp;</a>
<a class="sourceLine" id="cb129-7" title="7"></a>
<a class="sourceLine" id="cb129-8" title="8"><span class="co">// first with TCP stream sockets:</span></a>
<a class="sourceLine" id="cb129-9" title="9"></a>
<a class="sourceLine" id="cb129-10" title="10"><span class="co">// assume sockets are made and connected</span></a>
<a class="sourceLine" id="cb129-11" title="11"><span class="co">//stream_socket = socket(...</span></a>
<a class="sourceLine" id="cb129-12" title="12"><span class="co">//connect(stream_socket, ...</span></a>
<a class="sourceLine" id="cb129-13" title="13"></a>
<a class="sourceLine" id="cb129-14" title="14"><span class="co">// convert to network byte order</span></a>
<a class="sourceLine" id="cb129-15" title="15">temp = htonl(spatula_count);</a>
<a class="sourceLine" id="cb129-16" title="16"><span class="co">// send data normally:</span></a>
<a class="sourceLine" id="cb129-17" title="17">send(stream_socket, &amp;temp, <span class="kw">sizeof</span> temp, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb129-18" title="18"></a>
<a class="sourceLine" id="cb129-19" title="19"><span class="co">// send secret message out of band:</span></a>
<a class="sourceLine" id="cb129-20" title="20">send(stream_socket, secret_message, strlen(secret_message)+<span class="dv">1</span>, MSG_OOB);</a>
<a class="sourceLine" id="cb129-21" title="21"></a>
<a class="sourceLine" id="cb129-22" title="22"><span class="co">// now with UDP datagram sockets:</span></a>
<a class="sourceLine" id="cb129-23" title="23"><span class="co">//getaddrinfo(...</span></a>
<a class="sourceLine" id="cb129-24" title="24"><span class="co">//dest = ... // assume &quot;dest&quot; holds the address of the destination</span></a>
<a class="sourceLine" id="cb129-25" title="25"><span class="co">//dgram_socket = socket(...</span></a>
<a class="sourceLine" id="cb129-26" title="26"></a>
<a class="sourceLine" id="cb129-27" title="27"><span class="co">// send secret message normally:</span></a>
<a class="sourceLine" id="cb129-28" title="28">sendto(dgram_socket, secret_message, strlen(secret_message)+<span class="dv">1</span>, <span class="dv">0</span>, </a>
<a class="sourceLine" id="cb129-29" title="29">       (<span class="kw">struct</span> sockaddr*)&amp;dest, <span class="kw">sizeof</span> dest);</a></code></pre></div><h3 id="see-also-19" class="unnumbered unlisted">See Also</h3><p><a href="#recvman"><code>recv()</code></a>, <a href="#recvman"><code>recvfrom()</code></a></p><h2 id="shutdownman"><span class="header-section-number">9.22</span> <code>shutdown()</code></h2><p></p><p>Stop further sends and receives on a socket</p><h3 id="synopsis-21" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb130"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb130-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb130-2" title="2"></a>
<a class="sourceLine" id="cb130-3" title="3"><span class="dt">int</span> shutdown(<span class="dt">int</span> s, <span class="dt">int</span> how);</a></code></pre></div><h3 id="description-21" class="unnumbered unlisted">Description</h3><p>That’s it! I’ve had it! No more <code>send()</code>s are allowed on this socket, but I still want to <code>recv()</code> data on it! Or vice-versa! How can I do this?</p><p>When you <code>close()</code> a socket descriptor, it closes both sides of the socket for reading and writing, and frees the socket descriptor. If you just want to close one side or the other, you can use this <code>shutdown()</code> call.</p><p>As for parameters, <code>s</code> is obviously the socket you want to perform this action on, and what action that is can be specified with the <code>how</code> parameter. <code>how</code> can be <code>SHUT_RD</code> to prevent further <code>recv()</code>s, <code>SHUT_WR</code> to prohibit further <code>send()</code>s, or <code>SHUT_RDWR</code> to do both.</p><p>Note that <code>shutdown()</code> doesn’t free up the socket descriptor, so you still have to eventually <code>close()</code> the socket even if it has been fully shut down.</p><p>This is a rarely used system call.</p><h3 id="return-value-21" class="unnumbered unlisted">Return Value</h3><p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p><h3 id="example-21" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb131"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb131-1" title="1"><span class="dt">int</span> s = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb131-2" title="2"></a>
<a class="sourceLine" id="cb131-3" title="3"><span class="co">// ...do some send()s and stuff in here...</span></a>
<a class="sourceLine" id="cb131-4" title="4"></a>
<a class="sourceLine" id="cb131-5" title="5"><span class="co">// and now that we&#39;re done, don&#39;t allow any more sends()s:</span></a>
<a class="sourceLine" id="cb131-6" title="6">shutdown(s, SHUT_WR);</a></code></pre></div><h3 id="see-also-20" class="unnumbered unlisted">See Also</h3><p><a href="#closeman"><code>close()</code></a></p><h2 id="socketman"><span class="header-section-number">9.23</span> <code>socket()</code></h2><p></p><p>Allocate a socket descriptor</p><h3 id="synopsis-22" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb132"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb132-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb132-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb132-3" title="3"></a>
<a class="sourceLine" id="cb132-4" title="4"><span class="dt">int</span> socket(<span class="dt">int</span> domain, <span class="dt">int</span> type, <span class="dt">int</span> protocol);</a></code></pre></div><h3 id="description-22" class="unnumbered unlisted">Description</h3><p>Returns a new socket descriptor that you can use to do sockety things with. This is generally the first call in the whopping process of writing a socket program, and you can use the result for subsequent calls to <code>listen()</code>, <code>bind()</code>, <code>accept()</code>, or a variety of other functions.</p><p>In usual usage, you get the values for these parameters from a call to <code>getaddrinfo()</code>, as shown in the example below. But you can fill them in by hand if you really want to.</p><table><colgroup><col style="width: 16%" /><col style="width: 83%" /></colgroup><thead><tr class="header"><th>Parameter</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>domain</code></td><td><code>domain</code> describes what kind of socket you’re interested in. This can, believe me, be a wide variety of things, but since this is a socket guide, it’s going to be  <code>PF_INET</code> for IPv4, and <code>PF_INET6</code> for IPv6.</td></tr><tr class="even"><td><code>type</code></td><td>Also, the <code>type</code> parameter can be a number of things, but you’ll probably be setting it to either  <code>SOCK_STREAM</code> for reliable TCP sockets (<code>send()</code>, <code>recv()</code>) or  <code>SOCK_DGRAM</code> for unreliable fast UDP sockets (<code>sendto()</code>, <code>recvfrom()</code>). (Another interesting socket type is  <code>SOCK_RAW</code> which can be used to construct packets by hand. It’s pretty cool.)</td></tr><tr class="odd"><td><code>protocol</code></td><td>Finally, the <code>protocol</code> parameter tells which protocol to use with a certain socket type. Like I’ve already said, for instance, <code>SOCK_STREAM</code> uses TCP. Fortunately for you, when using <code>SOCK_STREAM</code> or <code>SOCK_DGRAM</code>, you can just set the protocol to 0, and it’ll use the proper protocol automatically. Otherwise, you can use  <code>getprotobyname()</code> to look up the proper protocol number.</td></tr></tbody></table><h3 id="return-value-22" class="unnumbered unlisted">Return Value</h3><p>The new socket descriptor to be used in subsequent calls, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p><h3 id="example-22" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb133"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb133-1" title="1"><span class="kw">struct</span> addrinfo hints, *res;</a>
<a class="sourceLine" id="cb133-2" title="2"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb133-3" title="3"></a>
<a class="sourceLine" id="cb133-4" title="4"><span class="co">// first, load up address structs with getaddrinfo():</span></a>
<a class="sourceLine" id="cb133-5" title="5"></a>
<a class="sourceLine" id="cb133-6" title="6">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</a>
<a class="sourceLine" id="cb133-7" title="7">hints.ai_family = AF_UNSPEC;     <span class="co">// AF_INET, AF_INET6, or AF_UNSPEC</span></a>
<a class="sourceLine" id="cb133-8" title="8">hints.ai_socktype = SOCK_STREAM; <span class="co">// SOCK_STREAM or SOCK_DGRAM</span></a>
<a class="sourceLine" id="cb133-9" title="9"></a>
<a class="sourceLine" id="cb133-10" title="10">getaddrinfo(<span class="st">&quot;www.example.com&quot;</span>, <span class="st">&quot;3490&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb133-11" title="11"></a>
<a class="sourceLine" id="cb133-12" title="12"><span class="co">// make a socket using the information gleaned from getaddrinfo():</span></a>
<a class="sourceLine" id="cb133-13" title="13">sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a></code></pre></div><h3 id="see-also-21" class="unnumbered unlisted">See Also</h3><p><a href="#acceptman"><code>accept()</code></a>, <a href="#bindman"><code>bind()</code></a>, <a href="#getaddrinfoman"><code>getaddrinfo()</code></a>, <a href="#listenman"><code>listen()</code></a></p><h2 id="structsockaddrman"><span class="header-section-number">9.24</span> <code>struct sockaddr</code> and pals</h2><p>     </p><p>Structures for handling internet addresses</p><h3 id="synopsis-23" class="unnumbered unlisted">Synopsis</h3><div class="sourceCode" id="cb134"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb134-1" title="1"><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></a>
<a class="sourceLine" id="cb134-2" title="2"></a>
<a class="sourceLine" id="cb134-3" title="3"><span class="co">// All pointers to socket address structures are often cast to pointers</span></a>
<a class="sourceLine" id="cb134-4" title="4"><span class="co">// to this type before use in various functions and system calls:</span></a>
<a class="sourceLine" id="cb134-5" title="5"></a>
<a class="sourceLine" id="cb134-6" title="6"><span class="kw">struct</span> sockaddr {</a>
<a class="sourceLine" id="cb134-7" title="7">    <span class="dt">unsigned</span> <span class="dt">short</span>    sa_family;    <span class="co">// address family, AF_xxx</span></a>
<a class="sourceLine" id="cb134-8" title="8">    <span class="dt">char</span>              sa_data[<span class="dv">14</span>];  <span class="co">// 14 bytes of protocol address</span></a>
<a class="sourceLine" id="cb134-9" title="9">};</a>
<a class="sourceLine" id="cb134-10" title="10"></a>
<a class="sourceLine" id="cb134-11" title="11"></a>
<a class="sourceLine" id="cb134-12" title="12"><span class="co">// IPv4 AF_INET sockets:</span></a>
<a class="sourceLine" id="cb134-13" title="13"></a>
<a class="sourceLine" id="cb134-14" title="14"><span class="kw">struct</span> sockaddr_in {</a>
<a class="sourceLine" id="cb134-15" title="15">    <span class="dt">short</span>            sin_family;   <span class="co">// e.g. AF_INET, AF_INET6</span></a>
<a class="sourceLine" id="cb134-16" title="16">    <span class="dt">unsigned</span> <span class="dt">short</span>   sin_port;     <span class="co">// e.g. htons(3490)</span></a>
<a class="sourceLine" id="cb134-17" title="17">    <span class="kw">struct</span> in_addr   sin_addr;     <span class="co">// see struct in_addr, below</span></a>
<a class="sourceLine" id="cb134-18" title="18">    <span class="dt">char</span>             sin_zero[<span class="dv">8</span>];  <span class="co">// zero this if you want to</span></a>
<a class="sourceLine" id="cb134-19" title="19">};</a>
<a class="sourceLine" id="cb134-20" title="20"></a>
<a class="sourceLine" id="cb134-21" title="21"><span class="kw">struct</span> in_addr {</a>
<a class="sourceLine" id="cb134-22" title="22">    <span class="dt">unsigned</span> <span class="dt">long</span> s_addr;          <span class="co">// load with inet_pton()</span></a>
<a class="sourceLine" id="cb134-23" title="23">};</a>
<a class="sourceLine" id="cb134-24" title="24"></a>
<a class="sourceLine" id="cb134-25" title="25"></a>
<a class="sourceLine" id="cb134-26" title="26"><span class="co">// IPv6 AF_INET6 sockets:</span></a>
<a class="sourceLine" id="cb134-27" title="27"></a>
<a class="sourceLine" id="cb134-28" title="28"><span class="kw">struct</span> sockaddr_in6 {</a>
<a class="sourceLine" id="cb134-29" title="29">    u_int16_t       sin6_family;   <span class="co">// address family, AF_INET6</span></a>
<a class="sourceLine" id="cb134-30" title="30">    u_int16_t       sin6_port;     <span class="co">// port number, Network Byte Order</span></a>
<a class="sourceLine" id="cb134-31" title="31">    u_int32_t       sin6_flowinfo; <span class="co">// IPv6 flow information</span></a>
<a class="sourceLine" id="cb134-32" title="32">    <span class="kw">struct</span> in6_addr sin6_addr;     <span class="co">// IPv6 address</span></a>
<a class="sourceLine" id="cb134-33" title="33">    u_int32_t       sin6_scope_id; <span class="co">// Scope ID</span></a>
<a class="sourceLine" id="cb134-34" title="34">};</a>
<a class="sourceLine" id="cb134-35" title="35"></a>
<a class="sourceLine" id="cb134-36" title="36"><span class="kw">struct</span> in6_addr {</a>
<a class="sourceLine" id="cb134-37" title="37">    <span class="dt">unsigned</span> <span class="dt">char</span>   s6_addr[<span class="dv">16</span>];   <span class="co">// load with inet_pton()</span></a>
<a class="sourceLine" id="cb134-38" title="38">};</a>
<a class="sourceLine" id="cb134-39" title="39"></a>
<a class="sourceLine" id="cb134-40" title="40"></a>
<a class="sourceLine" id="cb134-41" title="41"><span class="co">// General socket address holding structure, big enough to hold either</span></a>
<a class="sourceLine" id="cb134-42" title="42"><span class="co">// struct sockaddr_in or struct sockaddr_in6 data:</span></a>
<a class="sourceLine" id="cb134-43" title="43"></a>
<a class="sourceLine" id="cb134-44" title="44"><span class="kw">struct</span> sockaddr_storage {</a>
<a class="sourceLine" id="cb134-45" title="45">    sa_family_t  ss_family;     <span class="co">// address family</span></a>
<a class="sourceLine" id="cb134-46" title="46"></a>
<a class="sourceLine" id="cb134-47" title="47">    <span class="co">// all this is padding, implementation specific, ignore it:</span></a>
<a class="sourceLine" id="cb134-48" title="48">    <span class="dt">char</span>      __ss_pad1[_SS_PAD1SIZE];</a>
<a class="sourceLine" id="cb134-49" title="49">    <span class="dt">int64_t</span>   __ss_align;</a>
<a class="sourceLine" id="cb134-50" title="50">    <span class="dt">char</span>      __ss_pad2[_SS_PAD2SIZE];</a>
<a class="sourceLine" id="cb134-51" title="51">};</a></code></pre></div><h3 id="description-23" class="unnumbered unlisted">Description</h3><p>These are the basic structures for all syscalls and functions that deal with internet addresses. Often you’ll use <code>getaddrinfo()</code> to fill these structures out, and then will read them when you have to.</p><p>In memory, the <code>struct sockaddr_in</code> and <code>struct sockaddr_in6</code> share the same beginning structure as <code>struct sockaddr</code>, and you can freely cast the pointer of one type to the other without any harm, except the possible end of the universe.</p><p>Just kidding on that end-of-the-universe thing…if the universe does end when you cast a <code>struct sockaddr_in*</code> to a <code>struct sockaddr*</code>, I promise you it’s pure coincidence and you shouldn’t even worry about it.</p><p>So, with that in mind, remember that whenever a function says it takes a <code>struct sockaddr*</code> you can cast your <code>struct sockaddr_in*</code>, <code>struct sockaddr_in6*</code>, or <code>struct sockadd_storage*</code> to that type with ease and safety.</p><p><code>struct sockaddr_in</code> is the structure used with IPv4 addresses (e.g. “192.0.2.10”). It holds an address family (<code>AF_INET</code>), a port in <code>sin_port</code>, and an IPv4 address in <code>sin_addr</code>.</p><p>There’s also this <code>sin_zero</code> field in <code>struct sockaddr_in</code> which some people claim must be set to zero. Other people don’t claim anything about it (the Linux documentation doesn’t even mention it at all), and setting it to zero doesn’t seem to be actually necessary. So, if you feel like it, set it to zero using <code>memset()</code>.</p><p>Now, that <code>struct in_addr</code> is a weird beast on different systems. Sometimes it’s a crazy <code>union</code> with all kinds of <code>#define</code>s and other nonsense. But what you should do is only use the <code>s_addr</code> field in this structure, because many systems only implement that one.</p><p><code>struct sockadd_in6</code> and <code>struct in6_addr</code> are very similar, except they’re used for IPv6.</p><p><code>struct sockaddr_storage</code> is a struct you can pass to <code>accept()</code> or <code>recvfrom()</code> when you’re trying to write IP version-agnostic code and you don’t know if the new address is going to be IPv4 or IPv6. The <code>struct sockaddr_storage</code> structure is large enough to hold both types, unlike the original small <code>struct sockaddr</code>.</p><h3 id="example-23" class="unnumbered unlisted">Example</h3><div class="sourceCode" id="cb135"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb135-1" title="1"><span class="co">// IPv4:</span></a>
<a class="sourceLine" id="cb135-2" title="2"></a>
<a class="sourceLine" id="cb135-3" title="3"><span class="kw">struct</span> sockaddr_in ip4addr;</a>
<a class="sourceLine" id="cb135-4" title="4"><span class="dt">int</span> s;</a>
<a class="sourceLine" id="cb135-5" title="5"></a>
<a class="sourceLine" id="cb135-6" title="6">ip4addr.sin_family = AF_INET;</a>
<a class="sourceLine" id="cb135-7" title="7">ip4addr.sin_port = htons(<span class="dv">3490</span>);</a>
<a class="sourceLine" id="cb135-8" title="8">inet_pton(AF_INET, <span class="st">&quot;10.0.0.1&quot;</span>, &amp;ip4addr.sin_addr);</a>
<a class="sourceLine" id="cb135-9" title="9"></a>
<a class="sourceLine" id="cb135-10" title="10">s = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb135-11" title="11">bind(s, (<span class="kw">struct</span> sockaddr*)&amp;ip4addr, <span class="kw">sizeof</span> ip4addr);</a></code></pre></div><div class="sourceCode" id="cb136"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><a class="sourceLine" id="cb136-1" title="1"><span class="co">// IPv6:</span></a>
<a class="sourceLine" id="cb136-2" title="2"></a>
<a class="sourceLine" id="cb136-3" title="3"><span class="kw">struct</span> sockaddr_in6 ip6addr;</a>
<a class="sourceLine" id="cb136-4" title="4"><span class="dt">int</span> s;</a>
<a class="sourceLine" id="cb136-5" title="5"></a>
<a class="sourceLine" id="cb136-6" title="6">ip6addr.sin6_family = AF_INET6;</a>
<a class="sourceLine" id="cb136-7" title="7">ip6addr.sin6_port = htons(<span class="dv">4950</span>);</a>
<a class="sourceLine" id="cb136-8" title="8">inet_pton(AF_INET6, <span class="st">&quot;2001:db8:8714:3a90::12&quot;</span>, &amp;ip6addr.sin6_addr);</a>
<a class="sourceLine" id="cb136-9" title="9"></a>
<a class="sourceLine" id="cb136-10" title="10">s = socket(PF_INET6, SOCK_STREAM, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb136-11" title="11">bind(s, (<span class="kw">struct</span> sockaddr*)&amp;ip6addr, <span class="kw">sizeof</span> ip6addr);</a></code></pre></div><h3 id="see-also-22" class="unnumbered unlisted">See Also</h3><p><a href="#acceptman"><code>accept()</code></a>, <a href="#bindman"><code>bind()</code></a>, <a href="#connectman"><code>connect()</code></a>, <a href="#inet_ntoaman"><code>inet_aton()</code></a>, <a href="#inet_ntoaman"><code>inet_ntoa()</code></a></p><h1 id="more-references"><span class="header-section-number">10</span> More References</h1><p>You’ve come this far, and now you’re screaming for more! Where else can you go to learn more about all this stuff?</p><h2 id="books"><span class="header-section-number">10.1</span> Books</h2><p></p><p>For old-school actual hold-it-in-your-hand pulp paper books, try some of the following excellent books. These redirect to affiliate links with a popular bookseller, giving me nice kickbacks. If you’re merely feeling generous, you can paypal a donation to <a href="mailto:beej@beej.us"><code>beej@beej.us</code></a>. <code>:-)</code></p><p><strong>Unix Network Programming, volumes 1-2</strong> by W. Richard Stevens. Published by Addison-Wesley Professional and Prentice Hall. ISBNs for volumes 1-2: <a href="https://beej.us/guide/url/unixnet1">978-0131411555</a><a href="#fn49" class="footnote-ref" id="fnref49"><sup>49</sup></a>, <a href="https://beej.us/guide/url/unixnet2">978-0130810816</a><a href="#fn50" class="footnote-ref" id="fnref50"><sup>50</sup></a>.</p><p><strong>Internetworking with TCP/IP, volume I</strong> by Douglas E. Comer. Published by Pearson. ISBN <a href="https://beej.us/guide/url/intertcp1">978-0136085300</a><a href="#fn51" class="footnote-ref" id="fnref51"><sup>51</sup></a>.</p><p><strong>TCP/IP Illustrated, volumes 1-3</strong> by W. Richard Stevens and Gary R. Wright. Published by Addison Wesley. ISBNs for volumes 1, 2, and 3 (and a 3-volume set): <a href="https://beej.us/guide/url/tcpi1">978-0201633467</a><a href="#fn52" class="footnote-ref" id="fnref52"><sup>52</sup></a>, <a href="https://beej.us/guide/url/tcpi2">978-0201633542</a><a href="#fn53" class="footnote-ref" id="fnref53"><sup>53</sup></a>, <a href="https://beej.us/guide/url/tcpi3">978-0201634952</a><a href="#fn54" class="footnote-ref" id="fnref54"><sup>54</sup></a>, (<a href="https://beej.us/guide/url/tcpi123">978-0201776317</a><a href="#fn55" class="footnote-ref" id="fnref55"><sup>55</sup></a>).</p><p><strong>TCP/IP Network Administration</strong> by Craig Hunt. Published by O’Reilly &amp; Associates, Inc. ISBN <a href="https://beej.us/guide/url/tcpna">978-0596002978</a><a href="#fn56" class="footnote-ref" id="fnref56"><sup>56</sup></a>.</p><p><strong>Advanced Programming in the UNIX Environment</strong> by W. Richard Stevens. Published by Addison Wesley. ISBN <a href="https://beej.us/guide/url/advunix">978-0321637734</a><a href="#fn57" class="footnote-ref" id="fnref57"><sup>57</sup></a>.</p><p></p><h2 id="web-references"><span class="header-section-number">10.2</span> Web References</h2><p></p><p>On the web:</p><p><strong><a href="https://cis.temple.edu/~giorgio/old/cis307s96/readings/docs/sockets.html">BSD Sockets: A Quick And Dirty Primer</a><a href="#fn58" class="footnote-ref" id="fnref58"><sup>58</sup></a></strong> (Unix system programming info, too!)</p><p><strong><a href="https://developerweb.net/?f=70">The Unix Socket FAQ</a><a href="#fn59" class="footnote-ref" id="fnref59"><sup>59</sup></a></strong></p><p><strong><a href="http://www.faqs.org/faqs/internet/tcp-ip/tcp-ip-faq/part1/">TCP/IP FAQ</a><a href="#fn60" class="footnote-ref" id="fnref60"><sup>60</sup></a></strong></p><p><strong><a href="https://tangentsoft.net/wskfaq/">The Winsock FAQ</a><a href="#fn61" class="footnote-ref" id="fnref61"><sup>61</sup></a></strong></p><p>And here are some relevant Wikipedia pages:</p><p><strong><a href="https://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley Sockets</a><a href="#fn62" class="footnote-ref" id="fnref62"><sup>62</sup></a></strong></p><p><strong><a href="https://en.wikipedia.org/wiki/Internet_Protocol">Internet Protocol (IP)</a><a href="#fn63" class="footnote-ref" id="fnref63"><sup>63</sup></a></strong></p><p><strong><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol (TCP)</a><a href="#fn64" class="footnote-ref" id="fnref64"><sup>64</sup></a></strong></p><p><strong><a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">User Datagram Protocol (UDP)</a><a href="#fn65" class="footnote-ref" id="fnref65"><sup>65</sup></a></strong></p><p><strong><a href="https://en.wikipedia.org/wiki/Client-server">Client-Server</a><a href="#fn66" class="footnote-ref" id="fnref66"><sup>66</sup></a></strong></p><p><strong><a href="https://en.wikipedia.org/wiki/Serialization">Serialization</a><a href="#fn67" class="footnote-ref" id="fnref67"><sup>67</sup></a></strong> (packing and unpacking data)</p><p></p><h2 id="rfcs"><span class="header-section-number">10.3</span> RFCs</h2><p> </p><p><a href="https://www.rfc-editor.org/">RFCs</a><a href="#fn68" class="footnote-ref" id="fnref68"><sup>68</sup></a>—the real dirt! These are documents that describe assigned numbers, programming APIs, and protocols that are used on the Internet. I’ve included links to a few of them here for your enjoyment, so grab a bucket of popcorn and put on your thinking cap:</p><p><strong><a href="https://tools.ietf.org/html/rfc1">RFC 1</a><a href="#fn69" class="footnote-ref" id="fnref69"><sup>69</sup></a></strong> —The First RFC; this gives you an idea of what the “Internet” was like just as it was coming to life, and an insight into how it was being designed from the ground up. (This RFC is completely obsolete, obviously!)</p><p> <strong><a href="https://tools.ietf.org/html/rfc768">RFC 768</a><a href="#fn70" class="footnote-ref" id="fnref70"><sup>70</sup></a></strong> —The User Datagram Protocol (UDP)</p><p> <strong><a href="https://tools.ietf.org/html/rfc791">RFC 791</a><a href="#fn71" class="footnote-ref" id="fnref71"><sup>71</sup></a></strong> —The Internet Protocol (IP)</p><p> <strong><a href="https://tools.ietf.org/html/rfc793">RFC 793</a><a href="#fn72" class="footnote-ref" id="fnref72"><sup>72</sup></a></strong> —The Transmission Control Protocol (TCP)</p><p> <strong><a href="https://tools.ietf.org/html/rfc854">RFC 854</a><a href="#fn73" class="footnote-ref" id="fnref73"><sup>73</sup></a></strong> —The Telnet Protocol</p><p> <strong><a href="https://tools.ietf.org/html/rfc959">RFC 959</a><a href="#fn74" class="footnote-ref" id="fnref74"><sup>74</sup></a></strong> —File Transfer Protocol (FTP)</p><p> <strong><a href="https://tools.ietf.org/html/rfc1350">RFC 1350</a><a href="#fn75" class="footnote-ref" id="fnref75"><sup>75</sup></a></strong> —The Trivial File Transfer Protocol (TFTP)</p><p> <strong><a href="https://tools.ietf.org/html/rfc1459">RFC 1459</a><a href="#fn76" class="footnote-ref" id="fnref76"><sup>76</sup></a></strong> —Internet Relay Chat Protocol (IRC)</p><p><strong><a href="https://tools.ietf.org/html/rfc1918">RFC 1918</a><a href="#fn77" class="footnote-ref" id="fnref77"><sup>77</sup></a></strong> —Address Allocation for Private Internets</p><p> <strong><a href="https://tools.ietf.org/html/rfc2131">RFC 2131</a><a href="#fn78" class="footnote-ref" id="fnref78"><sup>78</sup></a></strong> —Dynamic Host Configuration Protocol (DHCP)</p><p> <strong><a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a><a href="#fn79" class="footnote-ref" id="fnref79"><sup>79</sup></a></strong> —Hypertext Transfer Protocol (HTTP)</p><p> <strong><a href="https://tools.ietf.org/html/rfc2821">RFC 2821</a><a href="#fn80" class="footnote-ref" id="fnref80"><sup>80</sup></a></strong> —Simple Mail Transfer Protocol (SMTP)</p><p><strong><a href="https://tools.ietf.org/html/rfc3330">RFC 3330</a><a href="#fn81" class="footnote-ref" id="fnref81"><sup>81</sup></a></strong> —Special-Use IPv4 Addresses</p><p><strong><a href="https://tools.ietf.org/html/rfc3493">RFC 3493</a><a href="#fn82" class="footnote-ref" id="fnref82"><sup>82</sup></a></strong> —Basic Socket Interface Extensions for IPv6</p><p><strong><a href="https://tools.ietf.org/html/rfc3542">RFC 3542</a><a href="#fn83" class="footnote-ref" id="fnref83"><sup>83</sup></a></strong> —Advanced Sockets Application Program Interface (API) for IPv6</p><p><strong><a href="https://tools.ietf.org/html/rfc3849">RFC 3849</a><a href="#fn84" class="footnote-ref" id="fnref84"><sup>84</sup></a></strong> —IPv6 Address Prefix Reserved for Documentation</p><p> <strong><a href="https://tools.ietf.org/html/rfc3920">RFC 3920</a><a href="#fn85" class="footnote-ref" id="fnref85"><sup>85</sup></a></strong> —Extensible Messaging and Presence Protocol (XMPP)</p><p> <strong><a href="https://tools.ietf.org/html/rfc3977">RFC 3977</a><a href="#fn86" class="footnote-ref" id="fnref86"><sup>86</sup></a></strong> —Network News Transfer Protocol (NNTP)</p><p><strong><a href="https://tools.ietf.org/html/rfc4193">RFC 4193</a><a href="#fn87" class="footnote-ref" id="fnref87"><sup>87</sup></a></strong> —Unique Local IPv6 Unicast Addresses</p><p> <strong><a href="https://tools.ietf.org/html/rfc4506">RFC 4506</a><a href="#fn88" class="footnote-ref" id="fnref88"><sup>88</sup></a></strong> —External Data Representation Standard (XDR)</p><p>The IETF has a nice online tool for <a href="https://tools.ietf.org/rfc/">searching and browsing RFCs</a><a href="#fn89" class="footnote-ref" id="fnref89"><sup>89</sup></a>.</p><p> </p><section class="footnotes"><hr /><ol><li id="fn1"><p>https://www.linux.com/<a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>https://bsd.org/<a href="#fnref2" class="footnote-back">↩</a></p></li><li id="fn3"><p>https://learn.microsoft.com/en-us/windows/wsl/<a href="#fnref3" class="footnote-back">↩</a></p></li><li id="fn4"><p>https://cygwin.com/<a href="#fnref4" class="footnote-back">↩</a></p></li><li id="fn5"><p>https://www.tallyhawk.net/WinsockExamples/<a href="#fnref5" class="footnote-back">↩</a></p></li><li id="fn6"><p>http://www.catb.org/~esr/faqs/smart-questions.html<a href="#fnref6" class="footnote-back">↩</a></p></li><li id="fn7"><p>https://beej.us/guide/bgnet/examples/telnot.c<a href="#fnref7" class="footnote-back">↩</a></p></li><li id="fn8"><p>https://tools.ietf.org/html/rfc854<a href="#fnref8" class="footnote-back">↩</a></p></li><li id="fn9"><p>https://tools.ietf.org/html/rfc793<a href="#fnref9" class="footnote-back">↩</a></p></li><li id="fn10"><p>https://tools.ietf.org/html/rfc791<a href="#fnref10" class="footnote-back">↩</a></p></li><li id="fn11"><p>https://tools.ietf.org/html/rfc768<a href="#fnref11" class="footnote-back">↩</a></p></li><li id="fn12"><p>https://tools.ietf.org/html/rfc791<a href="#fnref12" class="footnote-back">↩</a></p></li><li id="fn13"><p>https://en.wikipedia.org/wiki/Vint_Cerf<a href="#fnref13" class="footnote-back">↩</a></p></li><li id="fn14"><p>https://en.wikipedia.org/wiki/ELIZA<a href="#fnref14" class="footnote-back">↩</a></p></li><li id="fn15"><p>https://www.iana.org/assignments/port-numbers<a href="#fnref15" class="footnote-back">↩</a></p></li><li id="fn16"><p>https://en.wikipedia.org/wiki/Doom_(1993_video_game)<a href="#fnref16" class="footnote-back">↩</a></p></li><li id="fn17"><p>https://en.wikipedia.org/wiki/Wilford_Brimley<a href="#fnref17" class="footnote-back">↩</a></p></li><li id="fn18"><p>https://tools.ietf.org/html/rfc1918<a href="#fnref18" class="footnote-back">↩</a></p></li><li id="fn19"><p>https://tools.ietf.org/html/rfc4193<a href="#fnref19" class="footnote-back">↩</a></p></li><li id="fn20"><p>https://www.iana.org/assignments/port-numbers<a href="#fnref20" class="footnote-back">↩</a></p></li><li id="fn21"><p>https://beej.us/guide/bgnet/examples/showip.c<a href="#fnref21" class="footnote-back">↩</a></p></li><li id="fn22"><p>https://tools.ietf.org/html/rfc1413<a href="#fnref22" class="footnote-back">↩</a></p></li><li id="fn23"><p>https://beej.us/guide/bgnet/examples/server.c<a href="#fnref23" class="footnote-back">↩</a></p></li><li id="fn24"><p>https://beej.us/guide/bgnet/examples/client.c<a href="#fnref24" class="footnote-back">↩</a></p></li><li id="fn25"><p>https://beej.us/guide/bgnet/examples/listener.c<a href="#fnref25" class="footnote-back">↩</a></p></li><li id="fn26"><p>https://beej.us/guide/bgnet/examples/talker.c<a href="#fnref26" class="footnote-back">↩</a></p></li><li id="fn27"><p>https://libevent.org/<a href="#fnref27" class="footnote-back">↩</a></p></li><li id="fn28"><p>https://beej.us/guide/bgnet/examples/poll.c<a href="#fnref28" class="footnote-back">↩</a></p></li><li id="fn29"><p>https://beej.us/guide/bgnet/examples/pollserver.c<a href="#fnref29" class="footnote-back">↩</a></p></li><li id="fn30"><p>https://libevent.org/<a href="#fnref30" class="footnote-back">↩</a></p></li><li id="fn31"><p>https://beej.us/guide/bgnet/examples/select.c<a href="#fnref31" class="footnote-back">↩</a></p></li><li id="fn32"><p>https://beej.us/guide/bgnet/examples/selectserver.c<a href="#fnref32" class="footnote-back">↩</a></p></li><li id="fn33"><p>https://en.wikipedia.org/wiki/Internet_Relay_Chat<a href="#fnref33" class="footnote-back">↩</a></p></li><li id="fn34"><p>https://beej.us/guide/bgnet/examples/pack.c<a href="#fnref34" class="footnote-back">↩</a></p></li><li id="fn35"><p>https://en.wikipedia.org/wiki/IEEE_754<a href="#fnref35" class="footnote-back">↩</a></p></li><li id="fn36"><p>https://beej.us/guide/bgnet/examples/ieee754.c<a href="#fnref36" class="footnote-back">↩</a></p></li><li id="fn37"><p>https://beej.us/guide/url/tpop<a href="#fnref37" class="footnote-back">↩</a></p></li><li id="fn38"><p>https://github.com/protobuf-c/protobuf-c<a href="#fnref38" class="footnote-back">↩</a></p></li><li id="fn39"><p>https://beej.us/guide/bgnet/examples/pack2.c<a href="#fnref39" class="footnote-back">↩</a></p></li><li id="fn40"><p>https://beej.us/guide/bgnet/examples/pack2.c<a href="#fnref40" class="footnote-back">↩</a></p></li><li id="fn41"><p>https://tools.ietf.org/html/rfc4506<a href="#fnref41" class="footnote-back">↩</a></p></li><li id="fn42"><p>https://beej.us/guide/bgnet/examples/broadcaster.c<a href="#fnref42" class="footnote-back">↩</a></p></li><li id="fn43"><p>http://www.unpbook.com/src.html<a href="#fnref43" class="footnote-back">↩</a></p></li><li id="fn44"><p>http://www.unpbook.com/src.html<a href="#fnref44" class="footnote-back">↩</a></p></li><li id="fn45"><p>https://www.openssl.org/<a href="#fnref45" class="footnote-back">↩</a></p></li><li id="fn46"><p>https://stackoverflow.com/questions/21323023/<a href="#fnref46" class="footnote-back">↩</a></p></li><li id="fn47"><p>https://www.iana.org/assignments/port-numbers<a href="#fnref47" class="footnote-back">↩</a></p></li><li id="fn48"><p>https://www.iana.org/assignments/port-numbers<a href="#fnref48" class="footnote-back">↩</a></p></li><li id="fn49"><p>https://beej.us/guide/url/unixnet1<a href="#fnref49" class="footnote-back">↩</a></p></li><li id="fn50"><p>https://beej.us/guide/url/unixnet2<a href="#fnref50" class="footnote-back">↩</a></p></li><li id="fn51"><p>https://beej.us/guide/url/intertcp1<a href="#fnref51" class="footnote-back">↩</a></p></li><li id="fn52"><p>https://beej.us/guide/url/tcpi1<a href="#fnref52" class="footnote-back">↩</a></p></li><li id="fn53"><p>https://beej.us/guide/url/tcpi2<a href="#fnref53" class="footnote-back">↩</a></p></li><li id="fn54"><p>https://beej.us/guide/url/tcpi3<a href="#fnref54" class="footnote-back">↩</a></p></li><li id="fn55"><p>https://beej.us/guide/url/tcpi123<a href="#fnref55" class="footnote-back">↩</a></p></li><li id="fn56"><p>https://beej.us/guide/url/tcpna<a href="#fnref56" class="footnote-back">↩</a></p></li><li id="fn57"><p>https://beej.us/guide/url/advunix<a href="#fnref57" class="footnote-back">↩</a></p></li><li id="fn58"><p>https://cis.temple.edu/~giorgio/old/cis307s96/readings/docs/sockets.html<a href="#fnref58" class="footnote-back">↩</a></p></li><li id="fn59"><p>https://developerweb.net/?f=70<a href="#fnref59" class="footnote-back">↩</a></p></li><li id="fn60"><p>http://www.faqs.org/faqs/internet/tcp-ip/tcp-ip-faq/part1/<a href="#fnref60" class="footnote-back">↩</a></p></li><li id="fn61"><p>https://tangentsoft.net/wskfaq/<a href="#fnref61" class="footnote-back">↩</a></p></li><li id="fn62"><p>https://en.wikipedia.org/wiki/Berkeley_sockets<a href="#fnref62" class="footnote-back">↩</a></p></li><li id="fn63"><p>https://en.wikipedia.org/wiki/Internet_Protocol<a href="#fnref63" class="footnote-back">↩</a></p></li><li id="fn64"><p>https://en.wikipedia.org/wiki/Transmission_Control_Protocol<a href="#fnref64" class="footnote-back">↩</a></p></li><li id="fn65"><p>https://en.wikipedia.org/wiki/User_Datagram_Protocol<a href="#fnref65" class="footnote-back">↩</a></p></li><li id="fn66"><p>https://en.wikipedia.org/wiki/Client-server<a href="#fnref66" class="footnote-back">↩</a></p></li><li id="fn67"><p>https://en.wikipedia.org/wiki/Serialization<a href="#fnref67" class="footnote-back">↩</a></p></li><li id="fn68"><p>https://www.rfc-editor.org/<a href="#fnref68" class="footnote-back">↩</a></p></li><li id="fn69"><p>https://tools.ietf.org/html/rfc1<a href="#fnref69" class="footnote-back">↩</a></p></li><li id="fn70"><p>https://tools.ietf.org/html/rfc768<a href="#fnref70" class="footnote-back">↩</a></p></li><li id="fn71"><p>https://tools.ietf.org/html/rfc791<a href="#fnref71" class="footnote-back">↩</a></p></li><li id="fn72"><p>https://tools.ietf.org/html/rfc793<a href="#fnref72" class="footnote-back">↩</a></p></li><li id="fn73"><p>https://tools.ietf.org/html/rfc854<a href="#fnref73" class="footnote-back">↩</a></p></li><li id="fn74"><p>https://tools.ietf.org/html/rfc959<a href="#fnref74" class="footnote-back">↩</a></p></li><li id="fn75"><p>https://tools.ietf.org/html/rfc1350<a href="#fnref75" class="footnote-back">↩</a></p></li><li id="fn76"><p>https://tools.ietf.org/html/rfc1459<a href="#fnref76" class="footnote-back">↩</a></p></li><li id="fn77"><p>https://tools.ietf.org/html/rfc1918<a href="#fnref77" class="footnote-back">↩</a></p></li><li id="fn78"><p>https://tools.ietf.org/html/rfc2131<a href="#fnref78" class="footnote-back">↩</a></p></li><li id="fn79"><p>https://tools.ietf.org/html/rfc2616<a href="#fnref79" class="footnote-back">↩</a></p></li><li id="fn80"><p>https://tools.ietf.org/html/rfc2821<a href="#fnref80" class="footnote-back">↩</a></p></li><li id="fn81"><p>https://tools.ietf.org/html/rfc3330<a href="#fnref81" class="footnote-back">↩</a></p></li><li id="fn82"><p>https://tools.ietf.org/html/rfc3493<a href="#fnref82" class="footnote-back">↩</a></p></li><li id="fn83"><p>https://tools.ietf.org/html/rfc3542<a href="#fnref83" class="footnote-back">↩</a></p></li><li id="fn84"><p>https://tools.ietf.org/html/rfc3849<a href="#fnref84" class="footnote-back">↩</a></p></li><li id="fn85"><p>https://tools.ietf.org/html/rfc3920<a href="#fnref85" class="footnote-back">↩</a></p></li><li id="fn86"><p>https://tools.ietf.org/html/rfc3977<a href="#fnref86" class="footnote-back">↩</a></p></li><li id="fn87"><p>https://tools.ietf.org/html/rfc4193<a href="#fnref87" class="footnote-back">↩</a></p></li><li id="fn88"><p>https://tools.ietf.org/html/rfc4506<a href="#fnref88" class="footnote-back">↩</a></p></li><li id="fn89"><p>https://tools.ietf.org/rfc/<a href="#fnref89" class="footnote-back">↩</a></p></li></ol></section>
</body>
</html>
